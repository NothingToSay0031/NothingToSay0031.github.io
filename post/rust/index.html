<!doctype html>
<html
  lang="en-us"
  
>
  <head>
    <meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, shrink-to-fit=no"
/>







  

<title>
  Rust Essentials | NothingToSay0031
</title>
<meta
  name="description"
  content="A language empowering everyone to build reliable and efficient software."
/>










<script>
  window.siteConfig = JSON.parse("{\"anchor_icon\":null,\"clipboard\":{\"copyright\":{\"content\":\"本文版权：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！\",\"count\":50,\"enable\":false},\"fail\":\"复制失败 (ﾟ⊿ﾟ)ﾂ\",\"success\":\"复制成功(*^▽^*)\"},\"code_block\":{\"expand\":true},\"icon_font\":\"4552607_tq6stt6tcg\",\"outdate\":{\"daysago\":180,\"enable\":false,\"message\":\"本文最后更新于 {time}，请注意文中内容可能已经发生变化。\"}}");
</script>











  
  
  
    
  

  
  
  
    
  

  
    

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  rel="preload"
  as="style"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
/>
<link
  rel="stylesheet"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
  media="print"
  onload="this.media='all'"
/>






  <link
    rel="preload"
    href="//at.alicdn.com/t/c/font_4552607_tq6stt6tcg.woff2"
    as="font"
    type="font/woff2"
    crossorigin="anonymous"
  />



  







  
 <link rel="stylesheet" href="https://nothingtosay0031.github.io/css/loader.min.2ad0e9bbffb534e893c0ecefc44787a277cf851387e8ad9dccfbc3a5f0886dbe.css" />




  <meta property="og:type" content="website" />
  <meta property="og:title" content="Rust Essentials | NothingToSay0031" />
  <meta
    property="og:description"
    content="A language empowering everyone to build reliable and efficient software."
  />
  <meta property="og:url" content="https://nothingtosay0031.github.io/post/rust/" />
  <meta
    property="og:site_name"
    content="NothingToSay0031"
  />
  <meta
    property="og:image"
    content="/"
  />
  <meta property="article:author" content="NothingToSay0031" />
  <meta property="article:published_time" content="2024-09-15T20:35:50&#43;00:00" />
  <meta property="article:modified_time" content="2024-09-15T20:35:50&#43;00:00" />
  
  
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:image" content="/" />
  
  
  
  
  




<link rel="shortcut icon" href="https://nothingtosay0031.github.io/favicon.ico">








  
 <link rel="stylesheet" href="https://nothingtosay0031.github.io/css/main.min.4e3ed4ec96a449612baa01e942ad2e62fab14c5e1e8f6b3eeb13d1cbc2e0dc67.css" />





  <link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css"
    onload="this.onload=null;this.rel='stylesheet'"
  />






  <link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/katex@0.16.9/dist/katex.min.css"
    onload="this.onload=null;this.rel='stylesheet'"
  />








  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js"
    
    
    
    
    integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"
  ></script>





  


  <link rel="stylesheet" href="https://npm.webcache.cn/@reimujs/aos@0.1.0/dist/aos.css" />




  </head>
  <body>
    
  <div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        
          <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
            <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="#ff5252" />
            <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z 
          M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95z" fill="#ff5252" />
          </svg>
        
      </div>
      <div class="loading-word">少女祈祷中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>


<div id="copy-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
</div>


    <div id="container">
      <div id="wrap">
        
<div id="header-nav">
  <nav id="main-nav">
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/">Home</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/archives">Archives</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/about">About</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/friend">Friend</a>
      </span>
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
    
  </nav>
</div>
<header id="header">
  
    <img fetchpriority="high" src="https://nothingtosay0031.github.io/images/banner.webp" alt="Rust Essentials">
  

  <div id="header-outer">
    <div id="header-title">
      
        
        
          
        
  
        
          <a href="https://nothingtosay0031.github.io/" id="logo">
            <h1 data-aos="slide-up">Rust Essentials</h1>
          </a>
        
      
  
      
        
        
        <h2 id="subtitle-wrap" data-aos="slide-down">
          
        </h2>
      
    </div>
  </div>
</header>
        <main id="content">
          
          <section id="main">
  <article
  class="h-entry article"
  itemprop="blogPost"
  itemscope
  itemtype="https://schema.org/BlogPosting"
>
  <div
    class="article-inner"
    data-aos="fade-up"
  >
    <div class="article-meta">
      <div class="article-date">
  <a
    href="https://nothingtosay0031.github.io/post/rust/"
    class="article-date-link"
    data-aos="zoom-in"
  >
    <time datetime="2024-09-15 20:35:50 &#43;0000 UTC" itemprop="datePublished"
      >2024-09-15</time
    >
    <time style="display: none;" id="post-update-time"
      >2024-09-15</time
    >
  </a>
</div>

      <div class="article-category">
  
</div>

    </div>
    <div class="hr-line"></div>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
      
        <h1 id="memory-management-in-rust---stack-vs-heap">
<a class="header-anchor" href="#memory-management-in-rust---stack-vs-heap"></a>
Memory Management in Rust - Stack vs. Heap
</h1><h2 id="introduction">
<a class="header-anchor" href="#introduction"></a>
Introduction
</h2><ul>
<li>Rust emphasizes <strong>memory safety</strong> without garbage collection.</li>
<li>This session revisits fundamental concepts like memory, functions, and how data is stored.</li>
<li>Many experienced engineers must revisit these basics to solve real-world issues like <strong>concurrent safety</strong>.</li>
</ul>
<h2 id="key-concepts">
<a class="header-anchor" href="#key-concepts"></a>
Key Concepts
</h2><ol>
<li><strong>Memory in Programming</strong>
<ul>
<li>
<p>Every program interacts with memory, whether <strong>stack</strong>, <strong>heap</strong>, or <strong>readonly data segments</strong> (e.g., <code>.RODATA</code> for string literals).</p>
</li>
<li>
<p>Example in Rust:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;hello world&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span></span></span></code></pre></div><ul>
<li><code>&quot;hello world&quot;</code> is stored in <code>.RODATA</code>.</li>
<li><code>.to_string()</code> allocates new memory on the <strong>heap</strong>, copying <code>&quot;hello world&quot;</code> to the heap.</li>
<li><code>s</code> is a variable on the <strong>stack</strong>, holding the pointer, length (11), and capacity (11) to this heap data.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Stack vs. Heap</strong>:
<ul>
<li><strong>Stack</strong>:
<ul>
<li>Functions allocate <strong>frames</strong> (memory) on the stack when invoked.</li>
<li>Frames contain <strong>registers</strong> (for context) and <strong>local variables</strong>.</li>
<li>Stack memory is managed efficiently, with memory allocation and deallocation happening as a function call starts and ends.</li>
<li><strong>Limitation</strong>: Stack size is predetermined; cannot dynamically resize. Storing large or dynamically sized data (e.g., strings) leads to stack overflow.</li>
</ul>
</li>
<li><strong>Heap</strong>:
<ul>
<li>Heap memory is used for data of <strong>unknown or dynamic size</strong>.</li>
<li>Allocations in the heap require explicit or automated memory management (e.g., using <code>malloc()</code> or Rust&rsquo;s ownership system).</li>
<li><strong>Flexible lifespan</strong>: Unlike the stack, heap-allocated memory can outlive the function call that created it, and data can be shared across threads.</li>
<li><strong>Drawbacks</strong>: Complex management, leading to issues like <strong>memory leaks</strong> or <strong>use after free</strong>.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="when-to-use-stack-vs-heap">
<a class="header-anchor" href="#when-to-use-stack-vs-heap"></a>
When to Use Stack vs. Heap
</h2><ul>
<li><strong>Stack</strong>:
<ul>
<li>Data size must be known at <strong>compile time</strong>.</li>
<li><strong>Efficient</strong> allocation (minimal system overhead).</li>
<li><strong>Short-lived</strong>: Stack memory is freed after function returns.</li>
</ul>
</li>
<li><strong>Heap</strong>:
<ul>
<li>Data is <strong>dynamic</strong> or its size isn’t known until runtime.</li>
<li>Data needs to be <strong>shared</strong> across multiple functions or threads.</li>
<li>Requires <strong>manual or automatic memory management</strong> to prevent leaks or invalid references.</li>
</ul>
</li>
</ul>
<h2 id="problems-with-heap-allocation">
<a class="header-anchor" href="#problems-with-heap-allocation"></a>
Problems with Heap Allocation
</h2><ol>
<li><strong>Memory Leaks</strong>: Forgetting to release heap memory.</li>
<li><strong>Thread Safety</strong>: Sharing heap memory between threads requires <strong>synchronization</strong> (e.g., locking) to avoid issues like <strong>use after free</strong> or <strong>heap out-of-bounds</strong>.</li>
<li><strong>Performance</strong>: Frequent heap allocations cause overhead, so strategies like <strong>pre-allocating memory</strong> are used to mitigate performance costs.</li>
</ol>
<h2 id="garbage-collection-gc-vs-automatic-reference-counting-arc">
<a class="header-anchor" href="#garbage-collection-gc-vs-automatic-reference-counting-arc"></a>
Garbage Collection (GC) vs. Automatic Reference Counting (ARC)
</h2><ul>
<li><strong>GC</strong>:
<ul>
<li>Traces and frees unused memory.</li>
<li>Efficient in memory throughput but introduces <strong>latency</strong> issues (e.g., &ldquo;Stop The World&rdquo; events), affecting responsiveness.</li>
<li>Example: <strong>Java</strong> uses GC but is unsuitable for real-time systems due to unpredictability in memory management.</li>
</ul>
</li>
<li><strong>ARC</strong>:
<ul>
<li>Manages memory through <strong>reference counting</strong>, freeing memory when the count reaches zero.</li>
<li>Common in languages like <strong>Swift</strong> and <strong>Objective-C</strong>.</li>
<li><strong>Lower throughput</strong> than GC but avoids unpredictable pauses, making ARC ideal for <strong>real-time applications</strong>.</li>
</ul>
</li>
</ul>
<h2 id="summary">
<a class="header-anchor" href="#summary"></a>
Summary
</h2><ul>
<li>Stack memory: <strong>static size</strong>, efficient, local to function calls.</li>
<li>Heap memory: <strong>dynamic size</strong>, flexible lifespan, more complex to manage.</li>
<li>Managing memory carefully in Rust helps achieve <strong>memory safety</strong> and <strong>efficient performance</strong>. Rust provides tools to handle heap and stack memory management with less room for mistakes (e.g., <strong>ownership and borrowing</strong>).</li>
</ul>
<h2 id="discussion">
<a class="header-anchor" href="#discussion"></a>
Discussion
</h2><ol>
<li><strong>Can you put data shared across multiple threads on the stack?</strong>
<ul>
<li>No, because stack memory is local to the current function. Use the heap for sharing data across threads.</li>
</ul>
</li>
<li><strong>Can you use a pointer to refer to stack memory?</strong>
<ul>
<li>Yes, but only within the function’s scope. Once the function ends, the stack frame is deallocated, making the pointer invalid. Use heap memory for pointers that need to outlive a function.</li>
</ul>
</li>
</ol>
<h1 id="essential-programming-concepts">
<a class="header-anchor" href="#essential-programming-concepts"></a>
Essential Programming Concepts
</h1><p>In the last lecture, we discussed the fundamentals of memory operations, focusing on stack and heap memory. Today, we’ll continue exploring essential programming concepts, divided into four main categories:</p>
<ol>
<li><strong>Data (Values &amp; Types, Pointers &amp; References)</strong></li>
<li><strong>Code (Functions, Methods, Closures, Interfaces &amp; Virtual Tables)</strong></li>
<li><strong>Execution Models (Concurrency vs. Parallelism, Sync vs. Async, Promises/async/await)</strong></li>
<li><strong>Programming Paradigms (Generic Programming)</strong></li>
</ol>
<p>These concepts are foundational, especially in understanding more advanced Rust features like ownership, dynamic dispatch, and concurrency.</p>
<h2 id="data-values-types-pointers-and-references">
<a class="header-anchor" href="#data-values-types-pointers-and-references"></a>
Data: Values, Types, Pointers, and References
</h2><p><strong>Values and Types:</strong></p>
<ul>
<li>A <strong>type</strong> defines characteristics like memory size, alignment, and valid operations for a value.</li>
<li>A <strong>value</strong> is an instance of a specific type. For example, <code>64u8</code> is a value of type <code>u8</code> (an 8-bit integer), which in memory is represented as <code>0x40</code> (64 in hexadecimal).</li>
<li>Values cannot exist without types. For example, the byte <code>0x40</code> could represent different data depending on the type—<code>64</code> if interpreted as an integer or <code>@</code> if interpreted as an ASCII character.</li>
</ul>
<p><strong>Types: Primitive and Composite:</strong></p>
<ul>
<li><strong>Primitive types</strong> include basic data like integers, floats, booleans, arrays, tuples, and pointers. These have fixed sizes and are often allocated on the stack.</li>
<li><strong>Composite types</strong> combine multiple primitive types:
<ul>
<li><strong>Structures (Product Types):</strong> Group related fields, like a <code>Person</code> structure with <code>name</code>, <code>age</code>, and <code>email</code>.</li>
<li><strong>Tagged Unions (Sum Types):</strong> Store one of several possible types, with an internal tag indicating which type is stored (e.g., <code>Optional</code> in Swift or <code>Maybe</code> in Haskell).</li>
<li><strong>Enumerations:</strong> Similar to tagged unions but less powerful; they represent distinct variants of a type.</li>
</ul>
</li>
</ul>
<p><strong>Pointers and References:</strong></p>
<ul>
<li>A <strong>pointer</strong> holds the memory address of a value and can be dereferenced to access the value.</li>
<li>A <strong>reference</strong> is a type-safe pointer that enforces access constraints. Unlike pointers, references can only be dereferenced to their original type, enhancing safety.</li>
<li><strong>Fat Pointers:</strong> Some references, such as to dynamically sized data (e.g., strings), include extra metadata like length and capacity in addition to the memory address.</li>
</ul>
<h2 id="code-functions-methods-closures-interfaces-and-virtual-tables">
<a class="header-anchor" href="#code-functions-methods-closures-interfaces-and-virtual-tables"></a>
Code: Functions, Methods, Closures, Interfaces, and Virtual Tables
</h2><p><strong>Functions, Methods, and Closures:</strong></p>
<ul>
<li>A <strong>function</strong> is a reusable block of code designed to perform a specific task. Modern languages often treat functions as first-class citizens, meaning they can be passed as arguments, returned from other functions, and stored in variables.</li>
<li>A <strong>method</strong> is a function associated with an object or class. It often operates on the object&rsquo;s internal state, using references like <code>self</code> in Python or <code>this</code> in Java.</li>
<li>A <strong>closure</strong> is a function combined with its surrounding context. Closures capture and store the values of variables from their lexical scope.</li>
</ul>
<p><strong>Interfaces and Virtual Tables:</strong></p>
<ul>
<li>An <strong>interface</strong> is an abstraction layer that separates the user from the implementation. It defines a contract that can be fulfilled by various concrete types.</li>
<li><strong>Dynamic Dispatch and Virtual Tables:</strong> In languages that support dynamic dispatch (e.g., Rust’s <code>trait</code>), interfaces are linked to implementations at runtime using a <strong>virtual table (vtable)</strong>. The vtable holds pointers to methods corresponding to the interface, enabling runtime polymorphism.</li>
</ul>
<h2 id="execution-models-concurrency-parallelism-sync-and-async">
<a class="header-anchor" href="#execution-models-concurrency-parallelism-sync-and-async"></a>
Execution Models: Concurrency, Parallelism, Sync, and Async
</h2><p><strong>Concurrency vs. Parallelism:</strong></p>
<ul>
<li><strong>Concurrency</strong> is the ability to manage multiple tasks simultaneously, but not necessarily at the same time. Tasks are interleaved, saving state and switching context.</li>
<li><strong>Parallelism</strong> is the simultaneous execution of multiple tasks using multiple cores. Concurrency provides the ability to handle many tasks; parallelism uses multiple resources to execute them.</li>
</ul>
<p><strong>Sync vs. Async:</strong></p>
<ul>
<li><strong>Synchronous</strong> operations block execution until they are completed, ensuring that tasks happen in a specific order. Most CPU instructions and function calls are synchronous.</li>
<li><strong>Asynchronous</strong> operations allow the program to perform other tasks while waiting for an I/O operation to complete, maximizing CPU utilization. For example, in <strong>async/await</strong>, <code>async</code> initiates an asynchronous task, and <code>await</code> pauses execution until the task is completed.</li>
</ul>
<p><strong>Promises and Async/Await:</strong></p>
<ul>
<li><strong>Promise</strong> is an object that represents the future result of an asynchronous operation. It has three states: pending, resolved (success), or rejected (failure).</li>
<li><strong>Async/await</strong> is syntactic sugar over promises. It simplifies writing asynchronous code by making it look and behave like synchronous code.</li>
</ul>
<h2 id="programming-paradigms-generic-programming">
<a class="header-anchor" href="#programming-paradigms-generic-programming"></a>
Programming Paradigms: Generic Programming
</h2><p><strong>Data Structure Generics:</strong></p>
<ul>
<li>
<p><strong>Generic Data Structures</strong> (parameterized types) allow you to define structures that operate on different types. For example:Here, <code>S</code> is a generic type, and the actual type for <code>S</code> is specified at runtime (e.g., <code>TcpStream</code>).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Connection</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">io</span>: <span class="nc">S</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">state</span>: <span class="nc">State</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<p><strong>Generic Algorithms:</strong></p>
<ul>
<li>In generic programming, functions and data structures are defined with type parameters, which can be substituted with any valid type. This increases code reusability and reduces redundancy.</li>
<li>A good example is a binary search algorithm. In non-generic code, different implementations would be needed for different types (e.g., integers, floats), but with generics, the same code can handle multiple types.</li>
</ul>
<h2 id="summary-1">
<a class="header-anchor" href="#summary-1"></a>
Summary
</h2><p>We covered essential concepts across four categories:</p>
<ol>
<li><strong>Data</strong> is represented by values and types, with differences between primitive and composite types. Pointers and references are essential for memory management.</li>
<li><strong>Code</strong> is structured using functions, methods, and closures. Interfaces and virtual tables enable abstraction and runtime polymorphism.</li>
<li><strong>Execution models</strong> explore how tasks are handled, focusing on concurrency, parallelism, and asynchronous programming.</li>
<li><strong>Generic programming</strong> allows for flexible, reusable code across different types.</li>
</ol>
<h1 id="rust-basics">
<a class="header-anchor" href="#rust-basics"></a>
Rust Basics
</h1><h2 id="introduction-1">
<a class="header-anchor" href="#introduction-1"></a>
Introduction
</h2><p>Welcome to the world of Rust! Today, we&rsquo;ll dive into Rust by creating and running your first Rust program. The approach is hands-on; you’ll set up your Rust environment, write code, and understand the basic features and syntax of Rust.</p>
<p><strong>Creating a Project</strong>: Generate a new Rust project with <code>cargo new</code></p>
<p><strong>Writing Your First Rust Program</strong></p>
<ul>
<li>Add dependencies in <code>Cargo.toml</code>:</li>
<li>Write the code in <code>src/main.rs</code>:</li>
</ul>
<h2 id="rust-features">
<a class="header-anchor" href="#rust-features"></a>
Rust Features
</h2><ol>
<li>
<p><strong>Cargo</strong>:</p>
<ul>
<li>Rust’s build system and package manager. Manages dependencies and project tasks.</li>
</ul>
</li>
<li>
<p><strong>Syntax</strong>:</p>
<ul>
<li>Similar to C/C++, with functions enclosed in <code>{}</code>, semicolons <code>;</code> separating expressions, and <code>::</code> for namespace access.</li>
</ul>
</li>
<li>
<p><strong>Type Inference</strong>:</p>
<ul>
<li>Rust supports type inference but requires explicit types for constants and static variables.</li>
</ul>
</li>
<li>
<p><strong>Immutability</strong>:</p>
<ul>
<li>Variables are immutable by default. Use <code>mut</code> to declare mutable variables.</li>
</ul>
</li>
<li>
<p><strong>Error Handling</strong>:</p>
<ul>
<li>
<p>Rust uses <code>Result&lt;T, E&gt;</code> for error handling. The <code>?</code> operator propagates errors. Example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reqwest</span>::<span class="n">blocking</span>::<span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="o">?</span><span class="p">.</span><span class="n">text</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>Control Flow</strong>:</p>
<ul>
<li>Supports <code>if</code>, <code>loop</code>, <code>while</code>, and <code>for</code> loops. <code>for</code> loops can iterate over any <code>IntoIterator</code> implementation.</li>
</ul>
</li>
<li>
<p><strong>Pattern Matching</strong>:</p>
<ul>
<li>
<p>Powerful feature using <code>match</code> to destructure and process enums and structs:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">match</span><span class="w"> </span><span class="n">event</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Event</span>::<span class="n">Join</span><span class="p">((</span><span class="n">uid</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;User </span><span class="si">{:?}</span><span class="s"> joined&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">uid</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Event</span>::<span class="n">Leave</span><span class="p">((</span><span class="n">uid</span><span class="p">,</span><span class="w"> </span><span class="n">tid</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;User </span><span class="si">{:?}</span><span class="s"> left </span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">uid</span><span class="p">,</span><span class="w"> </span><span class="n">tid</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Event</span>::<span class="n">Message</span><span class="p">((</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Broadcast: </span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>Data Structures</strong>:</p>
<ul>
<li><code>struct</code>, <code>enum</code>, and tuple types are used for defining complex data structures. Use <code>#[derive(Debug)]</code> for debugging output.</li>
</ul>
</li>
</ol>
<h2 id="project-structure-and-testing">
<a class="header-anchor" href="#project-structure-and-testing"></a>
Project Structure and Testing
</h2><ol>
<li>
<p><strong>Modules and Crates</strong>:</p>
<ul>
<li>Use <code>mod</code> to include modules. Crates can be libraries or executables, and can be organized into workspaces.</li>
</ul>
</li>
<li>
<p><strong>Testing</strong>:</p>
<ul>
<li>Write unit tests within the same file using <code>#[cfg(test)]</code>. For integration tests, use the <code>tests</code> directory.</li>
</ul>
</li>
</ol>
<h1 id="ownership-in-rust">
<a class="header-anchor" href="#ownership-in-rust"></a>
Ownership in Rust
</h1><p>This part focuses on Rust&rsquo;s unique ownership model, crucial for understanding memory safety without a garbage collector. Rust enforces strict rules on ownership and borrowing to manage memory efficiently.</p>
<h2 id="key-concepts-1">
<a class="header-anchor" href="#key-concepts-1"></a>
Key Concepts
</h2><ol>
<li><strong>Ownership Rules</strong>:
<ul>
<li><strong>Single Owner</strong>: Each value in Rust has exactly one owner.</li>
<li><strong>Transfer of Ownership</strong>: Ownership can be transferred, but there can only be one owner at a time.</li>
<li><strong>Scope-Based Destruction</strong>: When the owner goes out of scope, the value is dropped and memory is freed.</li>
</ul>
</li>
<li><strong>Move Semantics</strong>:
<ul>
<li>When a value is assigned to another variable or passed to a function, ownership is transferred (moved) from the original owner to the new one.</li>
<li>Example: In the provided code, moving <code>data</code> to <code>find_pos()</code> invalidates the original <code>data</code> in <code>main()</code>.</li>
</ul>
</li>
<li><strong>Copy Semantics</strong>:
<ul>
<li><strong>Copy Trait</strong>: Types that implement the <code>Copy</code> trait are copied bit-by-bit rather than moved. This avoids invalidating the original value.</li>
<li>Primitive types (e.g., integers, booleans) and fixed-size arrays implement <code>Copy</code>.</li>
<li>Types that do not implement <code>Copy</code> include heap-allocated types like <code>Vec</code> and <code>String</code>.</li>
</ul>
</li>
<li><strong>Borrowing</strong>:
<ul>
<li>When a value&rsquo;s ownership cannot be transferred but needs to be accessed, Rust allows borrowing. This will be covered in detail in the next part.</li>
</ul>
</li>
</ol>
<h2 id="code-examples-and-errors">
<a class="header-anchor" href="#code-examples-and-errors"></a>
Code Examples and Errors
</h2><ul>
<li>
<p><strong>Code Snippet</strong>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">data1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;sum of data1: </span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">data1</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;data1: </span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">data1</span><span class="p">);</span><span class="w"> </span><span class="c1">// error: data1 no longer accessible
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;sum of data: </span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">));</span><span class="w"> </span><span class="c1">// error: data no longer accessible
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">sum</span><span class="p">(</span><span class="n">data</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">data</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">acc</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>Errors occur because <code>data</code> and <code>data1</code> are no longer accessible after ownership is moved.</li>
</ul>
</li>
<li>
<p><strong>Copy vs. Move</strong>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">is_copy</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Copy</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">types_impl_copy_trait</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">is_copy</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// Valid, i32 implements Copy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">is_copy</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// Invalid, Vec does not implement Copy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<h2 id="summary-2">
<a class="header-anchor" href="#summary-2"></a>
Summary
</h2><p>Rust’s ownership model, involving Move and Copy semantics, provides robust memory safety by enforcing clear ownership rules. The model avoids issues associated with heap memory management in languages with garbage collection or manual memory management. Future parts will delve into borrowing and its role in this system.</p>
<h1 id="borrowing-in-rust">
<a class="header-anchor" href="#borrowing-in-rust"></a>
Borrowing in Rust
</h1><h2 id="ownership-basics">
<a class="header-anchor" href="#ownership-basics"></a>
Ownership Basics
</h2><p>In Rust, each value has a single owner, and ownership can be transferred via move semantics. If a value does not implement the <code>Copy</code> trait, ownership moves to the new owner, leaving the original owner unable to access the value. If a value implements <code>Copy</code>, it is duplicated, allowing both the original and new owner to access the value.</p>
<h2 id="borrow-semantics">
<a class="header-anchor" href="#borrow-semantics"></a>
Borrow Semantics
</h2><p>Borrowing allows temporary access to a value without transferring ownership, akin to renting a room. Rust uses references (<code>&amp;</code> for immutable, <code>&amp;mut</code> for mutable) to implement borrowing.</p>
<h2 id="immutable-references">
<a class="header-anchor" href="#immutable-references"></a>
Immutable References
</h2><ul>
<li>
<p><strong>Immutable Borrowing:</strong> By default, Rust provides immutable borrowing. Immutable references do not affect the ownership of the value but allow read access. Multiple immutable references are allowed simultaneously as long as there are no mutable references.</p>
</li>
<li>
<p><strong>Example Code:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">data_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">data</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;sum of data_ref: </span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">data_ref</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">sum</span><span class="p">(</span><span class="n">data</span>: <span class="kp">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">data</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">acc</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><ul>
<li><strong>Memory Addresses:</strong> The memory address of <code>data</code> remains constant. References like <code>data_ref</code> point to the same data but have different addresses.</li>
</ul>
</li>
</ul>
<h2 id="mutable-references">
<a class="header-anchor" href="#mutable-references"></a>
Mutable References
</h2><ul>
<li>
<p><strong>Mutable Borrowing:</strong> Mutable references allow modification of the value. Rust enforces strict rules to prevent unsafe behavior:</p>
<ol>
<li>Only one mutable reference is allowed at a time in a given scope.</li>
<li>Mutable references are mutually exclusive with immutable references.</li>
</ol>
</li>
<li>
<p><strong>Example Code:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">mut_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">mut_ref</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><ul>
<li><strong>Safety:</strong> Rust prevents multiple mutable references to avoid undefined behavior, ensuring data consistency and safety.</li>
</ul>
</li>
</ul>
<h2 id="lifetimes">
<a class="header-anchor" href="#lifetimes"></a>
Lifetimes
</h2><ul>
<li>
<p><strong>Lifetimes:</strong> Rust enforces that references must not outlive the data they point to. This prevents issues like use-after-free. Lifetimes ensure that borrowed data remains valid as long as the references are in use.</p>
</li>
<li>
<p><strong>Example Code:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">local_ref</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;r: </span><span class="si">{:p}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">local_ref</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="na">&#39;a</span> <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">&amp;</span><span class="n">a</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><ul>
<li><strong>Issue:</strong> This code is invalid because it returns a reference to a local variable, which will be dropped when the function exits.</li>
</ul>
</li>
</ul>
<h2 id="special-cases">
<a class="header-anchor" href="#special-cases"></a>
Special Cases
</h2><ul>
<li>
<p><strong>Stack and Heap:</strong> References to stack-allocated data should not be stored in heap-allocated structures if they outlive the stack scope.</p>
</li>
<li>
<p><strong>Example Code:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">data</span>: <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><ul>
<li><strong>Validity:</strong> This code compiles because the reference&rsquo;s lifetime aligns with the scope. However, storing references to local variables in heap-allocated structures is risky and often leads to unsafe behavior.</li>
</ul>
</li>
</ul>
<h2 id="rusts-guarantees">
<a class="header-anchor" href="#rusts-guarantees"></a>
Rust&rsquo;s Guarantees
</h2><ul>
<li>Rust guarantees memory safety by enforcing strict rules on ownership and borrowing. These include:
<ul>
<li>One owner per value.</li>
<li>Multiple immutable references allowed.</li>
<li>Only one mutable reference allowed, with no mutable and immutable references coexisting.</li>
</ul>
</li>
</ul>
<h2 id="discussion-1">
<a class="header-anchor" href="#discussion-1"></a>
Discussion
</h2><p>Why does mutable borrowing not implement the <code>Copy</code> trait? How can you modify the following code to compile while avoiding simultaneous immutable and mutable references?</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="n">last</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">arr</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;last: </span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>To fix the code, you need to ensure that you don&rsquo;t have both a mutable reference and an immutable reference active at the same time. Here&rsquo;s a revised version:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">last_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="n">last</span><span class="p">();</span><span class="w"> </span><span class="c1">// Create a temporary scope for immutable borrow
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">arr</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">last_ref</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;last: </span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>In this version, the immutable reference to <code>arr</code> (<code>last_ref</code>) is created and used within its own scope, ensuring it is no longer active by the time <code>arr</code> is mutated. This way, <code>arr.push(4)</code> occurs only after <code>last_ref</code> is no longer in use.</p>
<h1 id="arc-refcell-and-concurrency">
<a class="header-anchor" href="#arc-refcell-and-concurrency"></a>
Arc, RefCell, and Concurrency
</h1><h2 id="overview">
<a class="header-anchor" href="#overview"></a>
Overview
</h2><p>Rust&rsquo;s ownership model typically ensures that each value has a single owner. This rule prevents data races and ensures memory safety. However, certain scenarios, like implementing Directed Acyclic Graphs (DAGs) or managing shared mutable state across threads, challenge this model. Rust addresses these with specific types: <code>Rc</code>, <code>RefCell</code>, <code>Arc</code>, and synchronization primitives.</p>
<h2 id="reference-counting-rc-and-arc">
<a class="header-anchor" href="#reference-counting-rc-and-arc"></a>
Reference Counting: <code>Rc</code> and <code>Arc</code>
</h2><p><strong><code>Rc</code> (Reference Counted):</strong></p>
<ul>
<li>
<p><code>Rc</code> enables multiple owners of data. It maintains a reference count, incrementing with <code>clone()</code> and decrementing when dropped.</p>
</li>
<li>
<p>Example:
Here, <code>a</code>, <code>b</code>, and <code>c</code> all point to the same data on the heap. The data is only freed when the reference count reaches zero.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">rc</span>::<span class="n">Rc</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<p><strong><code>Arc</code> (Atomic Reference Counted):</strong></p>
<ul>
<li>
<p><code>Arc</code> is similar to <code>Rc</code> but is thread-safe, using atomic operations for reference counting.</p>
</li>
<li>
<p>Example:<code>Arc</code> allows sharing data across threads safely.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">sync</span>::<span class="n">Arc</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">data_clone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">data_clone</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}).</span><span class="n">join</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<h2 id="internal-mutability-cell-and-refcell">
<a class="header-anchor" href="#internal-mutability-cell-and-refcell"></a>
Internal Mutability: <code>Cell</code> and <code>RefCell</code>
</h2><table>
  <thead>
      <tr>
          <th>Feature</th>
          <th>Cell</th>
          <th>RefCell</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Purpose</strong></td>
          <td>Provides internal mutability for types that implement <code>Copy</code>.</td>
          <td>Provides internal mutability for non-<code>Copy</code> types, allowing runtime borrow checking.</td>
      </tr>
      <tr>
          <td><strong>Use Case</strong></td>
          <td>Suitable for simple, <code>Copy</code> types like integers or <code>&amp;str</code>.</td>
          <td>Suitable for types that do not implement <code>Copy</code> and where borrow checking at runtime is acceptable.</td>
      </tr>
      <tr>
          <td><strong>Borrowing Rules</strong></td>
          <td>No borrowing rules; allows modification without references.</td>
          <td>Enforces borrowing rules at runtime, allowing mutable and immutable references coexistence.</td>
      </tr>
      <tr>
          <td><strong>Error Handling</strong></td>
          <td>No runtime errors; does not panic.</td>
          <td>Violates borrowing rules result in runtime <code>panic</code>.</td>
      </tr>
      <tr>
          <td><strong>Performance</strong></td>
          <td>Zero-cost abstraction; no additional overhead.</td>
          <td>Slight runtime overhead due to borrow state tracking.</td>
      </tr>
      <tr>
          <td><strong>When to Use</strong></td>
          <td>Use when working with <code>Copy</code> types and you need to modify data even when it is immutably borrowed.</td>
          <td>Use when working with non-<code>Copy</code> types where you need to manage mutable and immutable references dynamically at runtime.</td>
      </tr>
  </tbody>
</table>
<p><strong><code>RefCell</code> :</strong></p>
<ul>
<li>
<p>Allows mutable access to data even when the <code>RefCell</code> itself is not mutable. It performs <strong>runtime checks</strong> to ensure only one mutable or multiple immutable borrows exist at a time.</p>
</li>
<li>
<p>Example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">RefCell</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">*</span><span class="n">v</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;data: </span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">borrow</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<h2 id="thread-safety-mutex-and-rwlock">
<a class="header-anchor" href="#thread-safety-mutex-and-rwlock"></a>
Thread Safety: <code>Mutex</code> and <code>RwLock</code>
</h2><ul>
<li>
<p>For thread safety with mutable data, <code>Mutex</code> provides exclusive access, while <code>RwLock</code> allows multiple readers or one writer.</p>
</li>
<li>
<p>Example with <code>Mutex</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">sync</span>::<span class="p">{</span><span class="n">Arc</span><span class="p">,</span><span class="w"> </span><span class="n">Mutex</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Mutex</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">data_clone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_clone</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">*</span><span class="n">data</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}).</span><span class="n">join</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;data: </span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<h2 id="implementing-a-mutable-dag">
<a class="header-anchor" href="#implementing-a-mutable-dag"></a>
Implementing a Mutable DAG
</h2><p>To create a DAG where nodes can be modified, use <code>Rc&lt;RefCell&lt;Node&gt;&gt;</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">RefCell</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">rc</span>::<span class="n">Rc</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[derive(Debug)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">Node</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">id</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">downstream</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">id</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">id</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">downstream</span>: <span class="nb">None</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">update_downstream</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">downstream</span>: <span class="nc">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">downstream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">downstream</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_downstream</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">downstream</span><span class="p">.</span><span class="n">as_ref</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">v</span><span class="o">|</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">clone</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">node1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Node</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">node2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Node</span>::<span class="n">new</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">node3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Node</span>::<span class="n">new</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">node4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Node</span>::<span class="n">new</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">node3</span><span class="p">.</span><span class="n">update_downstream</span><span class="p">(</span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="n">node4</span><span class="p">)));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">node1</span><span class="p">.</span><span class="n">update_downstream</span><span class="p">(</span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="n">node3</span><span class="p">)));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">node2</span><span class="p">.</span><span class="n">update_downstream</span><span class="p">(</span><span class="n">node1</span><span class="p">.</span><span class="n">get_downstream</span><span class="p">().</span><span class="n">unwrap</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;node1: </span><span class="si">{:?}</span><span class="s">, node2: </span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">node1</span><span class="p">,</span><span class="w"> </span><span class="n">node2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">node5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Node</span>::<span class="n">new</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">node3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node1</span><span class="p">.</span><span class="n">get_downstream</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">node3</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">().</span><span class="n">downstream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="n">node5</span><span class="p">)));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;node1: </span><span class="si">{:?}</span><span class="s">, node2: </span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">node1</span><span class="p">,</span><span class="w"> </span><span class="n">node2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="summary-3">
<a class="header-anchor" href="#summary-3"></a>
Summary
</h2><table>
  <thead>
      <tr>
          <th>Access Method</th>
          <th>Data</th>
          <th>Immutable Borrow</th>
          <th>Mutable Borrow</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Single Ownership</strong></td>
          <td><code>T</code></td>
          <td><code>&amp;T</code></td>
          <td><code>&amp;mut T</code></td>
      </tr>
      <tr>
          <td><strong>Single Thread Shared Ownership</strong></td>
          <td><code>Rc&lt;T&gt;</code></td>
          <td><code>&amp;Rc&lt;T&gt;</code></td>
          <td>Cannot get mutable borrow</td>
      </tr>
      <tr>
          <td><strong>Single Thread Shared Ownership</strong></td>
          <td><code>Rc&lt;RefCell&lt;T&gt;&gt;</code></td>
          <td><code>v.borrow()</code></td>
          <td><code>v.borrow_mut()</code></td>
      </tr>
      <tr>
          <td><strong>Multiple Thread Shared Ownership</strong></td>
          <td><code>Arc&lt;T&gt;</code></td>
          <td><code>&amp;Arc&lt;T&gt;</code></td>
          <td>Cannot get mutable borrow</td>
      </tr>
      <tr>
          <td><strong>Multiple Thread Shared Ownership</strong></td>
          <td><code>Arc&lt;Mutex&lt;T&gt;&gt;</code></td>
          <td><code>v.lock()</code></td>
          <td><code>v.lock()</code></td>
      </tr>
      <tr>
          <td><strong>Multiple Thread Shared Ownership</strong></td>
          <td><code>Arc&lt;RwLock&lt;T&gt;&gt;</code></td>
          <td><code>v.read()</code></td>
          <td><code>v.write()</code></td>
      </tr>
  </tbody>
</table>
<ul>
<li><strong><code>Rc</code></strong>: Used for single-threaded scenarios requiring multiple ownerships of data.</li>
<li><strong><code>Arc</code></strong>: Provides thread-safe reference counting.</li>
<li><strong><code>RefCell</code></strong>: Allows mutable access to data even if the container is immutable.</li>
<li><strong><code>Mutex</code>/<code>RwLock</code></strong>: Used for safe concurrent access to mutable data.</li>
</ul>
<p>Understanding these tools helps manage Rust&rsquo;s strict ownership rules while balancing performance and safety.</p>
<h1 id="lifetimes-in-rust">
<a class="header-anchor" href="#lifetimes-in-rust"></a>
Lifetimes in Rust
</h1><h2 id="introduction-to-lifetimes">
<a class="header-anchor" href="#introduction-to-lifetimes"></a>
Introduction to Lifetimes
</h2><ol>
<li><strong>Static Lifetime</strong>:
<ul>
<li>A value with a lifetime that spans the entire duration of the process is called a static lifetime.</li>
<li>Values with static lifetimes have references with static lifetimes, denoted by <code>'static</code>.</li>
<li>Examples include global variables, static variables, string literals, and heap memory using <code>Box::leak</code>.</li>
</ul>
</li>
<li><strong>Dynamic Lifetime</strong>:
<ul>
<li>A value defined within a scope, created on the stack or heap, has a dynamic lifetime.</li>
<li>The lifetime of such a value ends when its scope ends.</li>
<li>Dynamic lifetimes are denoted by lowercase characters or strings like <code>'a</code>, <code>'b</code>, or <code>'hello</code>.</li>
</ul>
</li>
<li><strong>Memory Allocation</strong>:
<ul>
<li>Memory allocated on the heap and stack has dynamic lifetimes.</li>
<li>Global variables, static variables, string literals, and code are compiled into segments like BSS/Data/RoData/Text and loaded into memory, giving them static lifetimes.</li>
<li>Function pointers also have static lifetimes as they reside in the Text segment and exist as long as the process is alive.</li>
</ul>
</li>
</ol>
<h2 id="how-the-compiler-determines-lifetimes">
<a class="header-anchor" href="#how-the-compiler-determines-lifetimes"></a>
How the Compiler Determines Lifetimes
</h2><ul>
<li>Rust ensures &ldquo;borrowed references do not outlive the data they point to.&rdquo; The compiler enforces this through <em>lifetime analysis</em>.</li>
</ul>
<h2 id="lifetime-annotations">
<a class="header-anchor" href="#lifetime-annotations"></a>
Lifetime Annotations
</h2><ul>
<li>
<p>Rust allows developers to explicitly annotate lifetimes to help the compiler understand how different references relate to each other.</p>
</li>
<li>
<p><strong>Example</strong>: The <code>max</code> function</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">max</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s1</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span> <span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span> <span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="na">&#39;a</span> <span class="kt">str</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>Why Lifetimes are Necessary</strong>:</p>
<ul>
<li>When you pass references to a function, the compiler doesn&rsquo;t know the relationship between their lifetimes unless you tell it.</li>
<li>Example: In a comparison function <code>max(&amp;s1, &amp;s2)</code>, without a lifetime specifier, the compiler can&rsquo;t guarantee that the reference returned from the function is valid.</li>
</ul>
</li>
</ul>
<h2 id="compiler-rules-for-inference">
<a class="header-anchor" href="#compiler-rules-for-inference"></a>
Compiler Rules for Inference
</h2><ul>
<li>Rust tries to minimize the burden of specifying lifetimes. It automatically infers lifetimes based on several rules:
<ol>
<li>All reference type parameters have independent lifetimes such as <strong><code>'a</code></strong>, <strong><code>'b</code></strong>, etc.</li>
<li>If there’s only one reference in the input, the output borrows that reference&rsquo;s lifetime.</li>
<li>If there’s a <code>self</code> reference (for struct methods), Rust assumes the output borrows <code>self</code>&rsquo;s lifetime.</li>
</ol>
</li>
</ul>
<h3 id="multiple-lifetimes-in-functions">
<a class="header-anchor" href="#multiple-lifetimes-in-functions"></a>
Multiple Lifetimes in Functions
</h3><ul>
<li>
<p>When a function takes multiple references as arguments, and they have different lifetimes, Rust can&rsquo;t automatically determine how they relate. Thus, you must manually specify the relationships using lifetime parameters.</p>
</li>
<li>
<p><strong>Example</strong>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">max</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="na">&#39;b</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s1</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span> <span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span>: <span class="kp">&amp;</span><span class="na">&#39;b</span> <span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="na">&#39;</span><span class="o">???</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="c1">// Compilor can&#39;t annotate the output lifetime.
</span></span></span></code></pre></div><ul>
<li>Here, <code>'a</code> and <code>'b</code> represent different lifetimes for <code>s1</code> and <code>s2</code>. We need to explicitly define which lifetime the returned reference should have.</li>
</ul>
</li>
</ul>
<h3 id="case-study-strtok-implementation-in-rust">
<a class="header-anchor" href="#case-study-strtok-implementation-in-rust"></a>
Case Study: <code>strtok</code> Implementation in Rust
</h3><p>Here&rsquo;s a Rust implementation of <code>strtok()</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">strtok</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">delimiter</span>: <span class="kt">char</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">delimiter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="o">..</span><span class="n">i</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">suffix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">delimiter</span><span class="p">.</span><span class="n">len_utf8</span><span class="p">())</span><span class="o">..</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">suffix</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">prefix</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">prefix</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;hello world&#34;</span><span class="p">.</span><span class="n">to_owned</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">as_str</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strtok</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;hello is: </span><span class="si">{}</span><span class="s">, s1: </span><span class="si">{}</span><span class="s">, s: </span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">hello</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><strong>Explanation:</strong></p>
<ol>
<li><strong>Input Parameters</strong>: The function takes a mutable reference to a string slice (<code>&amp;mut &amp;str</code>). This allows the function to mutate the string slice so that it can keep track of which part of the string remains for further tokenization.</li>
<li><strong>Delimiter</strong>: We split the string by the given delimiter (in this case, a <code>char</code>), which may span multiple bytes due to UTF-8 encoding.</li>
<li><strong>Finding the Delimiter</strong>: The function looks for the delimiter using <code>find()</code>. If it finds one, it creates a <code>prefix</code> slice containing everything before the delimiter and a <code>suffix</code> slice containing everything after the delimiter.</li>
<li><strong>Modifying the Input</strong>: The original string slice (<code>s</code>) is updated to point to the suffix, allowing for subsequent calls to <code>strtok()</code> to continue from where the previous one left off.</li>
<li><strong>Return</strong>: The function returns the <code>prefix</code> slice, or if no delimiter is found, it returns the entire remaining string and sets the original slice to an empty string.</li>
</ol>
<h4 id="the-problem">
<a class="header-anchor" href="#the-problem"></a>
The Problem
</h4><p>If you attempt to compile the above code without any lifetime annotations, you&rsquo;ll encounter a compilation error related to lifetimes. Specifically, Rust&rsquo;s borrow checker cannot automatically deduce the relationships between the lifetimes of the input references and the output reference.</p>
<p>In Rust, each reference has a <strong>lifetime</strong>, and the compiler uses these lifetimes to ensure references are valid. In our case, the input reference <code>&amp;mut &amp;str</code> needs a lifetime annotation because the returned string slice <code>&amp;str</code> is derived from it.</p>
<p>The compiler will infer lifetimes like this:</p>
<ul>
<li><code>&amp;mut &amp;str</code> becomes <code>&amp;'b mut &amp;'a str</code>.</li>
</ul>
<p>This means the <code>&amp;mut</code> reference (<code>'b</code>) has a different lifetime than the string slice it points to (<code>'a</code>). However, the return value is directly related to the lifetime of the original string slice (<code>'a</code>), not the <code>&amp;mut</code> reference itself.</p>
<h4 id="solution">
<a class="header-anchor" href="#solution"></a>
Solution
</h4><p>To resolve this, we need to explicitly annotate the lifetimes. Since the return value is tied to the lifetime of the original string slice (<code>'a</code>), we only need to annotate the input reference&rsquo;s <code>'a</code> lifetime. Here&rsquo;s how we can fix the code:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">strtok</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">delimiter</span>: <span class="kt">char</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="na">&#39;a</span> <span class="kt">str</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">delimiter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="o">..</span><span class="n">i</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">suffix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">delimiter</span><span class="p">.</span><span class="n">len_utf8</span><span class="p">())</span><span class="o">..</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">suffix</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">prefix</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">prefix</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h4 id="understanding-lifetimes">
<a class="header-anchor" href="#understanding-lifetimes"></a>
Understanding Lifetimes
</h4><ol>
<li><strong><code>'a</code> Lifetime</strong>: The <code>'a</code> lifetime annotation ensures that the returned string slice (<code>&amp;str</code>) is valid for as long as the original string slice (<code>&amp;'a str</code>) is valid. This guarantees that we don&rsquo;t return a reference that outlives its source.</li>
<li><strong>How Lifetimes Work</strong>: Rust enforces that references must not outlive the data they refer to. Lifetimes are a way of ensuring this by explicitly or implicitly associating references with the data they refer to.</li>
<li><strong>Implicit Lifetime Elision</strong>: In some cases, Rust can automatically infer lifetimes, but in more complex cases like this function, we need to manually annotate them. The compiler uses these annotations to track how long different references remain valid.</li>
</ol>
<h2 id="lifetime-in-data-structures">
<a class="header-anchor" href="#lifetime-in-data-structures"></a>
Lifetime in Data Structures
</h2><ul>
<li>
<p>Structs with references require lifetime annotations, as their fields must live as long as the references they contain.</p>
</li>
<li>
<p><strong>Example</strong>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Employee</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="na">&#39;b</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span> <span class="kt">str</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">title</span>: <span class="kp">&amp;</span><span class="na">&#39;b</span> <span class="kt">str</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">age</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>In this case, the lifetimes of the <code>name</code> and <code>title</code> fields must be at least as long as the struct’s lifetime. Here, the struct <code>Employee</code> contains two string slices, each with its own lifetime (<code>'a</code> and <code>'b</code>). The lifetimes <code>'a</code> and <code>'b</code> ensure that the <code>Employee</code> struct does not outlive the string slices it refers to.</p>
</li>
</ul>
<h2 id="summary-4">
<a class="header-anchor" href="#summary-4"></a>
Summary
</h2><ol>
<li><strong>Static and Dynamic Lifetimes</strong>: Lifetimes in Rust can be static or dynamic. Static lifetimes apply to data that lives for the entire duration of the program (e.g., string literals), whereas dynamic lifetimes depend on the scope of variables and the relationships between references.</li>
<li><strong>Borrow Checker</strong>: Rust&rsquo;s borrow checker ensures references are always valid. When references have different lifetimes, the compiler checks whether they are used correctly and ensures that no reference outlives the data it refers to.</li>
<li><strong>Manual Lifetime Annotations</strong>: When automatic lifetime elision doesn&rsquo;t work, developers must manually annotate lifetimes to clarify the relationships between references and ensure correct ownership and borrowing semantics.</li>
<li><strong>Lifetimes in Functions</strong>: In functions, lifetimes are typically added to reference types in parameters and return values. The goal is to express constraints between lifetimes of inputs and outputs so that the compiler can check whether references are valid at runtime.</li>
<li><strong>Lifetimes in Structs</strong>: Structs with references also require lifetime annotations. These lifetimes ensure that the struct itself does not outlive the references it contains.</li>
</ol>
<p>According to the ownership rules, the lifetime of a value can be determined; it can persist until the owner leaves the scope. However, the lifetime of a reference cannot exceed that of the value. Within the same scope, this is obvious. However, when a function call occurs, the compiler needs to determine the constraints between the lifetimes of parameters and return values through the function’s signature.</p>
<p>In most cases, the compiler can automatically add lifetime constraints based on the rules in the context. If it cannot automatically add them, the developer needs to manually add the constraints. Generally, we only need to determine which parameter’s lifetime is related to the return value. For data structures, when there are internal references, we need to annotate the lifetimes of the references.</p>
<p>By understanding these principles, you&rsquo;ll be able to write safe, efficient Rust code that correctly handles lifetimes and borrowing, avoiding memory issues common in lower-level languages like C or C++.</p>
<h1 id="memory-management-the-lifecycle-of-a-value">
<a class="header-anchor" href="#memory-management-the-lifecycle-of-a-value"></a>
Memory Management: The Lifecycle of a Value
</h1><p>Throughout our learning journey, we&rsquo;ve delved into ownership and lifetimes in Rust. By now, you should have a solid understanding of Rust’s core concepts in memory management.</p>
<p>Rust solves the problem of managing heap memory safely and efficiently using a unique ownership model, avoiding the need for manual memory management like in C/C++, and without resorting to garbage collection (GC) as in Java or .NET. This also avoids the overhead introduced by runtime systems like GC or reference counting (ARC).</p>
<p>However, the ownership model introduces many new concepts like Move, Copy, Borrow, and lifetime management, making it somewhat challenging to learn. But have you noticed that many of these concepts, such as Copy semantics and value lifetimes, implicitly exist in other languages? Rust simply defines them more explicitly and clearly.</p>
<h2 id="memory-management-overview">
<a class="header-anchor" href="#memory-management-overview"></a>
Memory Management Overview
</h2><ul>
<li><strong>Stack Memory</strong> is very efficient for allocation and deallocation because its size is known at compile-time, but it’s limited in handling values with dynamic size or long lifetimes beyond the scope of a function. That’s where <strong>Heap Memory</strong> comes in.</li>
<li>Heap memory is flexible, but managing its lifecycle can be problematic in many languages. Different languages handle this in their own ways:
<ul>
<li><strong>C</strong>: Manual memory management, which can lead to errors.</li>
<li><strong>C++</strong>: Adds smart pointers to help, but still requires some manual control.</li>
<li><strong>Java/DotNet</strong>: Use GC to manage heap memory fully.</li>
</ul>
</li>
<li><strong>Rust</strong> ties heap memory’s lifecycle to its corresponding stack memory, eliminating the need for a full-blown runtime like GC. In cases where heap memory needs to outlive the stack, Rust offers mechanisms like <em>leak</em> to allow memory to persist beyond scope.</li>
</ul>
<h2 id="value-creation">
<a class="header-anchor" href="#value-creation"></a>
Value Creation
</h2><p>When you create a value, depending on its nature, it may reside in the <strong>stack</strong> or <strong>heap</strong>. Generally:</p>
<ul>
<li>If the value&rsquo;s size is known at compile time, it goes on the stack.</li>
<li>If its size is dynamic or it has a longer required lifetime, it goes on the heap.</li>
</ul>
<h2 id="structs-in-rust">
<a class="header-anchor" href="#structs-in-rust"></a>
Structs in Rust
</h2><p>When Rust lays out memory for structs, it optimizes their layout for memory alignment and performance. For example, it may rearrange fields in memory (e.g., placing <code>A, C, B</code> instead of <code>A, B, C</code>) to minimize the performance penalties from misaligned memory accesses. This optimization is automatic, though it can be overridden with the <code>#[repr]</code> attribute for interoperability with C code.</p>
<h2 id="enums-in-rust">
<a class="header-anchor" href="#enums-in-rust"></a>
Enums in Rust
</h2><p>Rust&rsquo;s <code>enum</code> is a <strong>tagged union</strong>: its size is the size of the largest variant plus the size of the tag. For example:</p>
<ul>
<li>A simple <code>Option</code> enum (like <code>Option&lt;u8&gt;</code>) takes 2 bytes: 1 byte for the tag (indicating <code>None</code> or <code>Some</code>) and 1 byte for the <code>u8</code>.</li>
<li>A more complex enum like <code>Result&lt;Vec&lt;u8&gt;, String&gt;</code> will have a size based on the largest variant plus the tag.</li>
</ul>
<p>Rust optimizes memory layouts for enums to minimize waste. For instance, if a type like <code>Option&lt;&amp;u8&gt;</code> is used, Rust cleverly uses the fact that null pointers (which are never valid in Rust) can be used to represent <code>None</code>, without requiring extra space.</p>
<h2 id="memory-layout-of-rust-data-structures">
<a class="header-anchor" href="#memory-layout-of-rust-data-structures"></a>
Memory Layout of Rust Data Structures
</h2><p>To better understand the memory footprint of different data structures in Rust, we can run a code example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">HashMap</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">enum</span> <span class="nc">E</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">A</span><span class="p">(</span><span class="kt">f64</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">B</span><span class="p">(</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">C</span><span class="p">(</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">show_size</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="n">header</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="s">&#34;</span><span class="si">{:&lt;24}</span><span class="s"> </span><span class="si">{:&gt;4}</span><span class="s">    </span><span class="si">{}</span><span class="s">    </span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="s">&#34;Type&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;T&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Option&lt;T&gt;&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Result&lt;T, io::Error&gt;&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;-&#34;</span><span class="p">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="cp">$t</span>:<span class="nc">ty</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="s">&#34;</span><span class="si">{:&lt;24}</span><span class="s"> </span><span class="si">{:4}</span><span class="s"> </span><span class="si">{:8}</span><span class="s"> </span><span class="si">{:12}</span><span class="s">&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="fm">stringify!</span><span class="p">(</span><span class="cp">$t</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="cp">$t</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="cp">$t</span><span class="o">&gt;&gt;</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="cp">$t</span><span class="p">,</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;&gt;</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">show_size!</span><span class="p">(</span><span class="n">header</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">show_size!</span><span class="p">(</span><span class="kt">u8</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">show_size!</span><span class="p">(</span><span class="kt">f64</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">show_size!</span><span class="p">(</span><span class="o">&amp;</span><span class="kt">u8</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">show_size!</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">show_size!</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">show_size!</span><span class="p">(</span><span class="nb">String</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">show_size!</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">show_size!</span><span class="p">(</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">show_size!</span><span class="p">(</span><span class="n">E</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>The <code>show_size</code> macro prints the size of each type, as well as the sizes of <code>Option</code> and <code>Result</code> variants.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Type                        T    Option&lt;T&gt;    Result&lt;T, io::Error&gt;
</span></span><span class="line"><span class="cl">----------------------------------------------------------------
</span></span><span class="line"><span class="cl">u8                          1        2           16
</span></span><span class="line"><span class="cl">f64                         8       16           16
</span></span><span class="line"><span class="cl">&amp;u8                         8        8           16
</span></span><span class="line"><span class="cl">Box&lt;u8&gt;                     8        8           16
</span></span><span class="line"><span class="cl">&amp;[u8]                      16       16           16
</span></span><span class="line"><span class="cl">String                     24       24           24
</span></span><span class="line"><span class="cl">Vec&lt;u8&gt;                    24       24           24
</span></span><span class="line"><span class="cl">HashMap&lt;String, String&gt;    48       48           48
</span></span><span class="line"><span class="cl">E                          56       56           56
</span></span></code></pre></div><p>Notably, types like <code>Option&lt;&amp;u8&gt;</code>, <code>Box&lt;u8&gt;</code>, <code>Vec&lt;u8&gt;</code>, and <code>HashMap</code> don’t consume extra space when used with <code>Option</code>, due to Rust’s optimizations. The tag value for <code>Option</code> uses the null pointer for <code>None</code>, avoiding any overhead for such types.</p>
<p>This efficient memory layout reduces unnecessary padding and makes Rust&rsquo;s enums memory-efficient.</p>
<h2 id="using-values">
<a class="header-anchor" href="#using-values"></a>
Using Values
</h2><p>When you assign or pass values around, Rust differentiates between <strong>Copy</strong> and <strong>Move</strong>.</p>
<ul>
<li>Both involve a shallow bitwise memory copy, but in the case of <strong>Copy</strong>, you can still use the original variable, while in <strong>Move</strong>, you cannot.</li>
<li>Rust ensures efficient copying and moving, especially for small values like primitive types and stack pointers to heap data.</li>
</ul>
<p>For large data structures like arrays, moving them around could be inefficient. Instead, Rust often recommends passing by reference (<code>&amp;</code>) to avoid deep copying.</p>
<p>Rust&rsquo;s data structures like <code>Vec</code> and <code>String</code> dynamically grow as needed during use. But if memory becomes too large for the data held, methods like <code>shrink_to_fit</code> can be used to reduce memory usage.</p>
<h2 id="destroying-values">
<a class="header-anchor" href="#destroying-values"></a>
Destroying Values
</h2><p>When a value goes out of scope, Rust automatically drops it using the <strong>Drop trait</strong>. This is similar to a destructor in object-oriented languages. Rust will recursively drop fields within structs or elements in collections.</p>
<p>For complex structures like <code>structs</code> or collections (<code>HashMap</code>, <code>Vec</code>), Rust ensures that all inner elements are dropped properly and safely.</p>
<h3 id="heap-memory-release">
<a class="header-anchor" href="#heap-memory-release"></a>
Heap Memory Release
</h3><p>Rust’s ownership model ensures that memory is released safely without needing to worry about double frees or memory leaks. Since values can only have one owner, the process of memory release is straightforward.</p>
<p>Other languages often rely on garbage collection or manual memory management, which can lead to complex and error-prone systems. Rust simplifies this by ensuring clear ownership and efficient memory usage.</p>
<h3 id="example-file-resource-management">
<a class="header-anchor" href="#example-file-resource-management"></a>
Example: File Resource Management
</h3><p>Rust’s <code>Drop trait</code> isn’t limited to just memory management. It can also be used to release other resources, like file handles, sockets, or locks. For example, when you create a file and write data to it in Rust, the file will automatically be closed when it goes out of scope, without needing an explicit <code>close()</code> call:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">prelude</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">create</span><span class="p">(</span><span class="s">&#34;foo.txt&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="sa">b</span><span class="s">&#34;hello world&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Other languages like Java or Python typically require explicit resource management calls like <code>close()</code>, but Rust’s ownership model ensures resources are released automatically when they are no longer needed.</p>
<h2 id="conclusion">
<a class="header-anchor" href="#conclusion"></a>
Conclusion
</h2><p>We’ve explored Rust’s memory management, from value creation to usage and destruction. Rust’s memory layout and ownership model provide both performance and safety by managing memory more explicitly. Understanding where values reside (stack vs. heap), how data structures like <code>Vec</code> and <code>String</code> manage memory, and how Rust automates resource cleanup (without a runtime like GC) can help you write more efficient, safe, and clear Rust code.</p>
<p>Lastly, a quick question: How much memory does <code>Result&lt;String, ()&gt;</code> occupy, and why?</p>
<h1 id="type-system-in-rust">
<a class="header-anchor" href="#type-system-in-rust"></a>
Type System in Rust
</h1><h2 id="introduction-to-type-systems">
<a class="header-anchor" href="#introduction-to-type-systems"></a>
Introduction to Type Systems
</h2><p>The type system is a core component of a programming language, largely shaping the user experience and the safety of the programs written in that language. In the world of machine code, without types, instructions only deal with immediate values or memory, and data stored in memory are just byte streams.</p>
<p>Thus, the type system can be viewed as a tool for the compiler to perform static checks on data at compile time or for the language to perform dynamic checks at runtime, ensuring that the data being operated on matches the expected type.</p>
<p>This explains why Rust has strict type checks that often result in compilation errors.</p>
<h2 id="basic-concepts-and-classifications-of-type-systems">
<a class="header-anchor" href="#basic-concepts-and-classifications-of-type-systems"></a>
Basic Concepts and Classifications of Type Systems
</h2><p>Before diving into Rust&rsquo;s type system, let’s clarify some concepts related to type systems to ensure we’re on the same page.</p>
<p>As mentioned in Lecture 2, a type distinguishes values and includes information about the length, alignment in memory, and allowable operations of those values.</p>
<p>For instance, the <code>u32</code> type represents an unsigned 32-bit integer, occupying 4 bytes, with an alignment of 4 bytes, and a value range from 0 to 4G. It supports operations like addition, subtraction, and comparisons, allowing expressions like <code>1 + 2</code> or <code>i &lt;= 3</code>.</p>
<p>A type system is essentially a system for defining, checking, and manipulating types. Based on different operational phases, types can be categorized in various ways:</p>
<ol>
<li>
<p><strong>Strong vs. Weak Typing</strong>: Strongly typed languages (like Rust) do not allow implicit type conversions, while weakly typed languages (like C/C++ and JavaScript) do.</p>
</li>
<li>
<p><strong>Static vs. Dynamic Typing</strong>: This is based on when type checks occur—either at compile time (static) or runtime (dynamic). Static systems can be further divided into explicit static (like Rust, Java, Swift) and implicit static (like Haskell).</p>
</li>
<li>
<p><strong>Polymorphism</strong>: A vital concept in type systems. In dynamic systems, polymorphism is achieved through duck typing, while in static systems, it can be realized through:</p>
<ul>
<li><strong>Parametric Polymorphism</strong>: Code operates on a type that meets certain constraints rather than a specific type.</li>
<li><strong>Ad-hoc Polymorphism</strong>: The same behavior can have multiple implementations (e.g., function overloading).</li>
<li><strong>Subtype Polymorphism</strong>: Subtypes can be treated as their parent type.</li>
</ul>
</li>
</ol>
<p>In Rust, parametric polymorphism is supported through generics, ad-hoc polymorphism through traits, and subtype polymorphism through trait objects.</p>
<h2 id="rusts-type-system">
<a class="header-anchor" href="#rusts-type-system"></a>
Rust&rsquo;s Type System
</h2><p>Now that we have a grasp of basic concepts and classifications, let&rsquo;s examine Rust&rsquo;s type system.</p>
<p>In terms of the previous classifications, Rust does not allow implicit type conversions, making it a strongly typed language. It employs a static type system that ensures type correctness at compile time, meaning Rust is both strongly and statically typed, contributing to its type safety.</p>
<h3 id="understanding-type-safety">
<a class="header-anchor" href="#understanding-type-safety"></a>
Understanding Type Safety
</h3><p>Type safety ensures that code can only access memory in ways that are permitted, based on the types involved. For example, if you have an array of <code>u64</code> data of length 4, any access must occur within the array&rsquo;s bounds, and only operations permitted for <code>u64</code> types can be performed.</p>
<p>Weakly typed languages like C/C++ may allow implicit conversions, potentially leading to unsafe memory access or incorrect data reads. In contrast, Rust&rsquo;s strict type system avoids these pitfalls.</p>
<p>Rust also separates read and write access to memory, enforcing stricter controls on memory safety, meaning code can only access authorized memory using permitted methods and permissions.</p>
<p>In Rust, all expressions have types, making types ubiquitous in the language.</p>
<h3 id="unit-type">
<a class="header-anchor" href="#unit-type"></a>
Unit Type
</h3><p>You may wonder about expressions without explicit types, like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">if</span><span class="w"> </span><span class="n">has_work</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">do_something</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>In Rust, the return type of a scope, whether it&rsquo;s an if-else block or a function, is the type of the last expression evaluated. If no value is returned, the return type defaults to the unit type <code>()</code>, which has a single value of <code>()</code>.</p>
<p>The unit type is widely used, for example, in error handling like <code>Result&lt;(), Error&gt;</code> where only errors are of concern, or in data structures like <code>HashSet</code>, which is essentially a type alias for <code>HashMap&lt;K, ()&gt;</code>.</p>
<h2 id="data-types-in-rust">
<a class="header-anchor" href="#data-types-in-rust"></a>
Data Types in Rust
</h2><p>Rust&rsquo;s primitive types include characters, integers, floating-point numbers, booleans, arrays, tuples, slices, pointers, references, and functions. The Rust standard library also supports rich composite types.</p>
<p>You can create your own composite types using structs and enums, which have been covered in earlier lessons.</p>
<h2 id="type-inference">
<a class="header-anchor" href="#type-inference"></a>
Type Inference
</h2><p>As a static type system, Rust can guarantee type safety at compile time, but explicit type annotations can be tedious. Rust&rsquo;s type inference allows it to deduce types based on variable usage context, reducing the need for explicit annotations.</p>
<p>For example, consider the following code snippet that creates a <code>BTreeMap</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">BTreeMap</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BTreeMap</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;world&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;map: </span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">map</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Here, the Rust compiler infers that the keys and values of the <code>BTreeMap</code> are string references. However, if you remove the <code>insert</code> statement, the compiler will raise an error indicating it cannot infer the type for parameter <code>K</code>.</p>
<p>In some situations, explicit type declarations are necessary. For example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">even_numbers</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numbers</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span></span></span></code></pre></div><p>This way, you can still leverage type inference for the inner types.</p>
<h2 id="using-generics-for-parametric-polymorphism">
<a class="header-anchor" href="#using-generics-for-parametric-polymorphism"></a>
Using Generics for Parametric Polymorphism
</h2><p>Rust uses generics to avoid requiring developers to write multiple implementations for different types. Generics include both generic data structures and generic functions.</p>
<h3 id="generic-data-structures">
<a class="header-anchor" href="#generic-data-structures"></a>
Generic Data Structures
</h3><p>Rust supports generics in data structures, enhancing code reuse. For example, the <code>Option</code> enum allows for a type parameter <code>T</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="generic-functions">
<a class="header-anchor" href="#generic-functions"></a>
Generic Functions
</h3><p>Similarly, functions can use generics. For example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">id</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">x</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>The Rust compiler applies monomorphization, generating multiple versions of the function for each specific type used.</p>
<h3 id="summary-of-generics">
<a class="header-anchor" href="#summary-of-generics"></a>
Summary of Generics
</h3><p>We introduced the basic concepts of type systems and the specifics of Rust&rsquo;s type system. We discussed the characteristics of Rust, including its attributes, data structures, type inference, and support for generics.</p>
<p>In Rust:</p>
<ul>
<li>It is a strong, static, explicit type system.</li>
<li>Type inference reduces the need for type annotations.</li>
<li>Generics provide a robust way to implement parametric polymorphism.</li>
</ul>
<p>In the next lecture, we will cover ad-hoc polymorphism and subtype polymorphism.</p>
<h2 id="discussion-2">
<a class="header-anchor" href="#discussion-2"></a>
Discussion
</h2><p>Consider the following code that fails to compile. Can you modify it to work correctly?</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="p">{</span><span class="n">BufWriter</span><span class="p">,</span><span class="w"> </span><span class="n">Write</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">net</span>::<span class="n">TcpStream</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[derive(Debug)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">MyWriter</span><span class="o">&lt;</span><span class="n">W</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">writer</span>: <span class="nc">W</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">W</span>: <span class="nc">Write</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MyWriter</span><span class="o">&lt;</span><span class="n">W</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">addr</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TcpStream</span>::<span class="n">connect</span><span class="p">(</span><span class="s">&#34;127.0.0.1:8080&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">writer</span>: <span class="nc">BufWriter</span>::<span class="n">new</span><span class="p">(</span><span class="n">stream</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">writer</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">writer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyWriter</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;127.0.0.1:8080&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">writer</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#34;hello world!&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="method-1">
<a class="header-anchor" href="#method-1"></a>
Method 1
</h3><p>The <code>MyWriter::new</code> method does not return a specific <code>MyWriter</code> instance because <code>MyWriter&lt;W&gt;</code> requires a generic parameter <code>W</code>. Although a <code>BufWriter&lt;TcpStream&gt;</code> is created inside the method, <code>MyWriter::new</code> does not explicitly inform the compiler of the concrete type for <code>W</code>, leading to a compilation failure.</p>
<p>In the corrected code, passing <code>BufWriter::new(stream)</code> as an argument to the <code>new</code> method explicitly specifies the type for <code>W</code>, allowing the compiler to construct the <code>MyWriter</code> instance correctly. Here’s the revised code:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="p">{</span><span class="n">BufWriter</span><span class="p">,</span><span class="w"> </span><span class="n">Write</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">net</span>::<span class="n">TcpStream</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[derive(Debug)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">MyWriter</span><span class="o">&lt;</span><span class="n">W</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">writer</span>: <span class="nc">W</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">W</span>: <span class="nc">Write</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MyWriter</span><span class="o">&lt;</span><span class="n">W</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">writer</span>: <span class="nc">W</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">writer</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">writer</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TcpStream</span>::<span class="n">connect</span><span class="p">(</span><span class="s">&#34;127.0.0.1:8080&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">writer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyWriter</span>::<span class="n">new</span><span class="p">(</span><span class="n">BufWriter</span>::<span class="n">new</span><span class="p">(</span><span class="n">stream</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">writer</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#34;hello world!&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>This correction ensures that the <code>MyWriter</code> constructor accepts any object implementing the <code>Write</code> trait, and it creates the <code>TcpStream</code> and <code>BufWriter</code> in the <code>main</code> function.</p>
<h3 id="method-2">
<a class="header-anchor" href="#method-2"></a>
Method 2
</h3><p>The reason the original code does not compile is that in <code>MyWriter::new</code>, the return type is <code>Self</code>, but <code>Self</code>’s generic parameter <code>W</code> needs to be explicitly defined during the call. Here, <code>W</code> is implicitly defined as a type implementing the <code>Write</code> trait, but since <code>BufWriter</code> wraps a <code>TcpStream</code>, you need to specify <code>W</code> explicitly.</p>
<p>The solution is to fix the generic type to <code>BufWriter&lt;TcpStream&gt;</code> for <code>MyWriter</code>. The implementation of <code>MyWriter</code> is fixed to use <code>BufWriter&lt;TcpStream&gt;</code>, avoiding generic inference issues. You can modify the code as follows to compile successfully:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="p">{</span><span class="n">BufWriter</span><span class="p">,</span><span class="w"> </span><span class="n">Write</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">net</span>::<span class="n">TcpStream</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[derive(Debug)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">MyWriter</span><span class="o">&lt;</span><span class="n">W</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">writer</span>: <span class="nc">W</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">MyWriter</span><span class="o">&lt;</span><span class="n">BufWriter</span><span class="o">&lt;</span><span class="n">TcpStream</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">addr</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TcpStream</span>::<span class="n">connect</span><span class="p">(</span><span class="n">addr</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">writer</span>: <span class="nc">BufWriter</span>::<span class="n">new</span><span class="p">(</span><span class="n">stream</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">writer</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">writer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyWriter</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;127.0.0.1:8080&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">writer</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#34;hello world!&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="comparison-of-the-two-methods">
<a class="header-anchor" href="#comparison-of-the-two-methods"></a>
Comparison of the Two Methods
</h3><p>Both methods address the same issue: the compiler needs to know the specific type of the generic parameter. However, they differ in their approach regarding <strong>generic parameter usage</strong> and <strong>flexibility</strong>.</p>
<h4 id="method-1-1">
<a class="header-anchor" href="#method-1-1"></a>
Method 1
</h4><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="o">&lt;</span><span class="n">W</span>: <span class="nc">Write</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MyWriter</span><span class="o">&lt;</span><span class="n">W</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">writer</span>: <span class="nc">W</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">writer</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><strong>Characteristics:</strong></p>
<ol>
<li><strong>Generic Flexibility</strong>: This approach allows <code>MyWriter</code> to accept any type implementing the <code>Write</code> trait, enhancing code reusability with types like <code>File</code>, <code>Vec&lt;u8&gt;</code>, etc.</li>
<li><strong>Constructor Flexibility</strong>: The <code>MyWriter::new</code> method can take any compatible object, making the code more general-purpose.</li>
<li><strong>User-Controlled Creation</strong>: Users create the <code>TcpStream</code> and wrap it in a <code>BufWriter</code> before passing it to <code>MyWriter</code>, providing greater flexibility.</li>
</ol>
<h4 id="method-2-1">
<a class="header-anchor" href="#method-2-1"></a>
Method 2
</h4><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="w"> </span><span class="n">MyWriter</span><span class="o">&lt;</span><span class="n">BufWriter</span><span class="o">&lt;</span><span class="n">TcpStream</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">addr</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TcpStream</span>::<span class="n">connect</span><span class="p">(</span><span class="n">addr</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">writer</span>: <span class="nc">BufWriter</span>::<span class="n">new</span><span class="p">(</span><span class="n">stream</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><strong>Characteristics:</strong></p>
<ol>
<li><strong>Fixed Generic Type</strong>: The generic parameter is constrained to <code>BufWriter&lt;TcpStream&gt;</code>, limiting its applicability to this specific combination.</li>
<li><strong>Encapsulated Construction</strong>: <code>MyWriter::new</code> directly handles the creation of <code>TcpStream</code>, simplifying the user experience.</li>
<li><strong>Simplified Invocation</strong>: Users only need to pass an address string to <code>MyWriter::new</code>, hiding the complexity of stream construction.</li>
</ol>
<h4 id="summary-comparison">
<a class="header-anchor" href="#summary-comparison"></a>
Summary Comparison:
</h4><table>
  <thead>
      <tr>
          <th>Aspect</th>
          <th>Method 1 (Flexible Generics)</th>
          <th>Method 2 (Fixed Generics)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Generic Flexibility</strong></td>
          <td>High: Accepts any type implementing <code>Write</code></td>
          <td>Low: Only accepts <code>BufWriter&lt;TcpStream&gt;</code></td>
      </tr>
      <tr>
          <td><strong>Usage Complexity</strong></td>
          <td>User creates and passes the <code>Write</code> object</td>
          <td><code>MyWriter</code> constructs and encapsulates the stream</td>
      </tr>
      <tr>
          <td><strong>Suitable Scenarios</strong></td>
          <td>Ideal for reusable code needing multiple <code>Write</code> types</td>
          <td>Best for simple use cases targeting a specific stream</td>
      </tr>
      <tr>
          <td><strong>Code Control</strong></td>
          <td>User decides how to create the <code>Write</code> object</td>
          <td><code>MyWriter</code> controls all construction details</td>
      </tr>
      <tr>
          <td><strong>Call Simplicity</strong></td>
          <td>Requires user to set up the object first</td>
          <td>Simplified call with only an address string</td>
      </tr>
  </tbody>
</table>
<h4 id="which-method-is-better">
<a class="header-anchor" href="#which-method-is-better"></a>
Which Method is Better?
</h4><ul>
<li><strong>Method 1</strong> is more flexible, suitable for scenarios requiring extensibility (e.g., supporting multiple output types). It offers users more control but increases complexity.</li>
<li><strong>Method 2</strong> is simpler and easier to use, suitable for cases that don’t need extra extensibility. It focuses on a specific use case, hiding complexity from the user.</li>
</ul>
<p>The choice between the two methods depends on the desired balance between flexibility and simplicity.</p>
<h2 id="references">
<a class="header-anchor" href="#references"></a>
References
</h2><p>For insights on how various languages handle generics, refer to this resource: <a href="https://thume.ca/2019/07/14/a-tour-of-metaprogramming-models-for-generics/">Models of Generics and Metaprogramming: Go, Rust, Swift, D and More</a>.</p>
<h1 id="type-system-using-traits-to-define-interfaces">
<a class="header-anchor" href="#type-system-using-traits-to-define-interfaces"></a>
Type System: Using Traits to Define Interfaces
</h1><p>Hello, I&rsquo;m Chen Tian.</p>
<p>In our previous lesson, we gained insights into the essence of Rust&rsquo;s type system. The type system acts as a tool for defining, checking, and managing types, ensuring that the data types we are working with for operations are as expected.</p>
<p>With Rust&rsquo;s powerful support for generics, we can conveniently define and use generic data structures and functions, enhancing the flexibility of input and output types and improving code reuse.</p>
<p>Today, we&rsquo;ll delve into two other forms of polymorphism: ad-hoc polymorphism and subtype polymorphism, exploring their purposes, implementations, and uses.</p>
<h2 id="recap-of-polymorphism-types">
<a class="header-anchor" href="#recap-of-polymorphism-types"></a>
Recap of Polymorphism Types
</h2><ul>
<li><strong>Ad-hoc Polymorphism</strong>: This includes operator overloading, where the same operation has different implementations.</li>
<li><strong>Subtype Polymorphism</strong>: Using a subtype as a supertype, such as treating a <code>Cat</code> as an <code>Animal</code>.</li>
</ul>
<p>Both forms of polymorphism in Rust are closely tied to traits, so we&rsquo;ll first understand what traits are and how to use them for these types of polymorphism.</p>
<h2 id="what-are-traits">
<a class="header-anchor" href="#what-are-traits"></a>
What are Traits?
</h2><p>Traits are Rust&rsquo;s way of defining interfaces, specifying the behaviors that types using these interfaces must implement. You can think of traits as akin to interfaces in Java, protocols in Swift, or type classes in Haskell.</p>
<p>In complex system development, it’s crucial to separate interfaces from implementations. This design principle isolates callers from implementers, allowing them to develop independently as long as they adhere to the interface.</p>
<p>Traits enable us to extract behaviors from data structures, allowing shared behavior across multiple types. They can also serve as constraints in generic programming, ensuring that parameterized types adhere to specified behaviors.</p>
<h2 id="basic-traits">
<a class="header-anchor" href="#basic-traits"></a>
Basic Traits
</h2><p>Let’s look at how to define a basic trait, using the <code>std::io::Write</code> trait from the standard library as an example. This trait outlines a set of method signatures:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Write</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">flush</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Other methods with default implementations...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Methods in traits can have default implementations, meaning you only need to implement specific methods, while others come with a default behavior.</p>
<p>When defining methods, you’ll notice the keywords <code>Self</code> and <code>self</code>:</p>
<ul>
<li><strong>Self</strong>: Represents the type implementing the trait.</li>
<li><strong>self</strong>: Used as the first parameter in methods (e.g., <code>&amp;self</code> or <code>&amp;mut self</code>).</li>
</ul>
<p>To better understand this, let’s implement a <code>BufBuilder</code> struct that conforms to the <code>Write</code> trait.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Write</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">BufBuilder</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">buf</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">BufBuilder</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">buf</span>: <span class="nb">Vec</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="mi">1024</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Implement Debug for BufBuilder
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Debug</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">BufBuilder</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">buf</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Write</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">BufBuilder</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">buf</span><span class="p">.</span><span class="n">extend_from_slice</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">len</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">flush</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BufBuilder</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">buf</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="sa">b</span><span class="s">&#34;Hello world!&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Here, we implemented <code>write</code> and <code>flush</code>, using default implementations for the rest. Once a type implements a trait, all methods in that trait become available.</p>
<h2 id="basic-trait-exercise">
<a class="header-anchor" href="#basic-trait-exercise"></a>
Basic Trait Exercise
</h2><p>Now, let’s define a trait to solidify our understanding. We’ll create a <code>Parse</code> trait for a string parser that converts parts of a string into a specific type.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Parse</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">parse</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Next, we can implement the <code>Parse</code> trait for <code>u8</code>, where it extracts numbers from a string.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">regex</span>::<span class="n">Regex</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Parse</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">parse</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">re</span>: <span class="nc">Regex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Regex</span>::<span class="n">new</span><span class="p">(</span><span class="sa">r</span><span class="s">&#34;^[0-9]+&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">captures</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">re</span><span class="p">.</span><span class="n">captures</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">captures</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="n">map_or</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">as_str</span><span class="p">().</span><span class="n">parse</span><span class="p">().</span><span class="n">unwrap_or</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="mi">0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[test]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">parse_should_work</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="kt">u8</span>::<span class="n">parse</span><span class="p">(</span><span class="s">&#34;123abc&#34;</span><span class="p">),</span><span class="w"> </span><span class="mi">123</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="kt">u8</span>::<span class="n">parse</span><span class="p">(</span><span class="s">&#34;abcd&#34;</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="enhancing-code-reusability">
<a class="header-anchor" href="#enhancing-code-reusability"></a>
Enhancing Code Reusability
</h3><p>To reduce code duplication for types like <code>f64</code>, we can leverage generics and traits. We need to impose constraints that ensure types can be parsed.</p>
<ol>
<li>The type must implement the <code>FromStr</code> trait.</li>
<li>The type must also implement the <code>Default</code> trait for handling unparseable strings.</li>
</ol>
<p>Here’s a more generic <code>Parse</code> trait implementation:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="kt">str</span>::<span class="n">FromStr</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">regex</span>::<span class="n">Regex</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Parse</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">parse</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Parse</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">T</span>: <span class="nc">FromStr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Default</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">parse</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">re</span>: <span class="nc">Regex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Regex</span>::<span class="n">new</span><span class="p">(</span><span class="sa">r</span><span class="s">&#34;^[0-9]+(\.[0-9]+)?&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nb">Default</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">captures</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">re</span><span class="p">.</span><span class="n">captures</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">captures</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="n">map_or</span><span class="p">(</span><span class="n">d</span><span class="p">(),</span><span class="w"> </span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">as_str</span><span class="p">().</span><span class="n">parse</span><span class="p">().</span><span class="n">unwrap_or</span><span class="p">(</span><span class="n">d</span><span class="p">()))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">d</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="returning-results-instead-of-defaults">
<a class="header-anchor" href="#returning-results-instead-of-defaults"></a>
Returning Results Instead of Defaults
</h3><p>To handle parsing errors better, we can modify our trait to return a <code>Result</code>, allowing us to define an associated error type.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Parse</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">parse</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="bp">Self</span><span class="p">,</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Parse</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">T</span>: <span class="nc">FromStr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Default</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">parse</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="bp">Self</span><span class="p">,</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">re</span>: <span class="nc">Regex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Regex</span>::<span class="n">new</span><span class="p">(</span><span class="sa">r</span><span class="s">&#34;^[0-9]+(\.[0-9]+)?&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">captures</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">re</span><span class="p">.</span><span class="n">captures</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">captures</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="n">map_or</span><span class="p">(</span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;failed to capture&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">()),</span><span class="w"> </span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">s</span><span class="p">.</span><span class="n">as_str</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">.</span><span class="n">parse</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="s">&#34;failed to parse captured string&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">})</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;failed to parse string&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="generic-traits">
<a class="header-anchor" href="#generic-traits"></a>
Generic Traits
</h2><p>We can also define a <code>Concat</code> trait that allows concatenation of various types, showcasing the utility of generics in traits. The <code>std::ops::Add</code> trait is a good example of this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="implementing-add-for-complex-numbers">
<a class="header-anchor" href="#implementing-add-for-complex-numbers"></a>
Implementing Add for Complex Numbers
</h3><p>Let’s define a <code>Complex</code> struct and implement the <code>Add</code> trait:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Add</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[derive(Debug)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">Complex</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">real</span>: <span class="kt">f64</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">imagine</span>: <span class="kt">f64</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">real</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">real</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">imagine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">imagine</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">imagine</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">real</span><span class="p">,</span><span class="w"> </span><span class="n">imagine</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">real</span>: <span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">imagine</span>: <span class="mf">1.0</span><span class="w"> </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">real</span>: <span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="n">imagine</span>: <span class="mf">3.0</span><span class="w"> </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="reference-implementations">
<a class="header-anchor" href="#reference-implementations"></a>
Reference Implementations
</h3><p>To avoid moving ownership, we can implement the <code>Add</code> trait for <code>&amp;Complex</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Complex</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Complex</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Complex</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">real</span>: <span class="nc">self</span><span class="p">.</span><span class="n">real</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">real</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">imagine</span>: <span class="nc">self</span><span class="p">.</span><span class="n">imagine</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">imagine</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="trait-inheritance-in-rust">
<a class="header-anchor" href="#trait-inheritance-in-rust"></a>
Trait Inheritance in Rust
</h2><p>In Rust, one trait can &ldquo;inherit&rdquo; associated types and methods from another trait. For instance, if we define <code>trait B: A</code>, any type <code>T</code> implementing <code>trait B</code> must also implement <code>trait A</code>. This allows <code>trait B</code> to utilize associated types and methods from <code>trait A</code>.</p>
<p>Trait inheritance is useful for extending the capabilities of traits. Many common traits leverage this, such as <code>AsyncWriteExt</code> in the Tokio library and <code>StreamExt</code> in the futures library. For example, <code>StreamExt</code> provides default implementations of its methods, which are available to all types that implement the <code>Stream</code> trait:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">StreamExt</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="nc">Stream</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span></code></pre></div><p>Thus, if you implement the <code>Stream</code> trait, you can directly use methods from <code>StreamExt</code>, which is very convenient.</p>
<h3 id="summary-of-traits">
<a class="header-anchor" href="#summary-of-traits"></a>
Summary of Traits
</h3><p>At this point, we have covered the basics of traits. To summarize:</p>
<ul>
<li><strong>Traits as Abstractions</strong>: Traits serve as abstractions for similar behaviors across different data structures.</li>
<li><strong>Associated Types</strong>: When behavior is tied to specific data, like the <code>Parse</code> trait for string parsing, associated types allow for flexibility in defining the types related to behavior until the trait is implemented.</li>
<li><strong>Generic Traits</strong>: The same trait behavior can have multiple implementations for the same type, such as with the <code>From</code> trait, utilizing generics.</li>
</ul>
<p>Rust&rsquo;s traits can be likened to a Swiss Army knife, accommodating a variety of scenarios requiring interface definitions.</p>
<p>Special polymorphism involves different implementations of the same behavior. By defining a trait and implementing it for various types, we achieve this polymorphism. The <code>Add</code> trait is a classic example, offering different handling for addition operations based on the types involved. The <code>Service</code> trait represents a less obvious case, where different handling occurs based on varying web request URLs.</p>
<p>This comprehensive approach demonstrates the versatility and power of traits in Rust, allowing for clean and flexible code design.</p>
<h1 id="dynamic-dispatch-in-rust">
<a class="header-anchor" href="#dynamic-dispatch-in-rust"></a>
Dynamic Dispatch in Rust
</h1><h2 id="understanding-subtype-polymorphism">
<a class="header-anchor" href="#understanding-subtype-polymorphism"></a>
Understanding Subtype Polymorphism
</h2><p>Strictly speaking, subtype polymorphism is often considered a feature of object-oriented languages. If an object <code>A</code> is a subclass of object <code>B</code>, then an instance of <code>A</code> can be used in any context where an instance of <code>B</code> is expected. For example, both cats and dogs are animals, so if a function requires an animal, it can accept either a cat or a dog.</p>
<p>Although Rust does not have classes and subclasses, it can achieve a similar relationship between traits and the types that implement those traits. Here&rsquo;s a demonstration:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Cat</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">Dog</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">name</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">&#39;static</span> <span class="kt">str</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Cat</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">name</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">&#39;static</span> <span class="kt">str</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="s">&#34;Cat&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Dog</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">name</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">&#39;static</span> <span class="kt">str</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="s">&#34;Dog&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">name</span><span class="p">(</span><span class="n">animal</span>: <span class="nc">impl</span><span class="w"> </span><span class="n">Animal</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">&#39;static</span> <span class="kt">str</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">animal</span><span class="p">.</span><span class="n">name</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">cat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cat</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;cat: </span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">(</span><span class="n">cat</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>In this example, <code>impl Animal</code> is a shorthand for <code>T: Animal</code>, meaning the <code>name</code> function can accept any type that implements the <code>Animal</code> trait. This leads to static dispatch, where the specific types are determined at compile time.</p>
<h2 id="dynamic-dispatch">
<a class="header-anchor" href="#dynamic-dispatch"></a>
Dynamic Dispatch
</h2><p>Static dispatch is efficient, but in many cases, the type cannot be determined at compile time. For instance, when writing a formatting tool, you might define a <code>Formatter</code> trait with various implementations:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Formatter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">format</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">input</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">MarkdownFormatter</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Formatter</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MarkdownFormatter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">format</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">input</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">input</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">formatted with Markdown formatter&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">RustFormatter</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Formatter</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">RustFormatter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">format</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">input</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">input</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">formatted with Rust formatter&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">HtmlFormatter</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Formatter</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">HtmlFormatter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">format</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">input</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">input</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">formatted with HTML formatter&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>The specific formatting method may only be known at runtime when the file is opened and its contents analyzed. Furthermore, a file might require multiple formatting tools.</p>
<p>If you use a <code>Vec</code> to hold all necessary formatters, how do you define the type for the <code>formatters</code> parameter?</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">format</span><span class="p">(</span><span class="n">input</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">formatters</span>: <span class="nb">Vec</span><span class="p">(</span><span class="o">???</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">formatter</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">formatters</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">formatter</span><span class="p">.</span><span class="n">format</span><span class="p">(</span><span class="n">input</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Since <code>Vec&lt;&gt;</code> requires consistent types, and here we cannot provide a single concrete type, we use a trait object, denoted as <code>&amp;dyn Trait</code> or <code>Box&lt;dyn Trait&gt;</code>. The <code>dyn</code> keyword helps indicate that what follows is a trait.</p>
<p>Thus, the code can be rewritten as:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">format</span><span class="p">(</span><span class="n">input</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">formatters</span>: <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="k">dyn</span><span class="w"> </span><span class="n">Formatter</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">formatter</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">formatters</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">formatter</span><span class="p">.</span><span class="n">format</span><span class="p">(</span><span class="n">input</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>This allows runtime construction of a list of formatters to be passed to the <code>format</code> function, enabling dynamic dispatch.</p>
<h2 id="mechanism-of-trait-objects">
<a class="header-anchor" href="#mechanism-of-trait-objects"></a>
Mechanism of Trait Objects
</h2><p>When using a trait for dynamic dispatch, a specific type reference can be assigned to <code>&amp;Formatter</code>. For example, assigning a reference to <code>HtmlFormatter</code> creates a trait object, which consists of a &ldquo;fat pointer.&rdquo; This fat pointer contains one pointer to the data and another to a virtual function table (vtable).</p>
<p>The vtable is a static table generated by Rust during compilation, containing information about the concrete type, such as size, alignment, and a series of function pointers for the methods supported by the interface, such as <code>format()</code>.</p>
<p>When <code>formatter.format()</code> is called at runtime, the method can be located via the vtable, enabling the specific implementation to be executed.</p>
<h3 id="object-safety-in-trait-objects">
<a class="header-anchor" href="#object-safety-in-trait-objects"></a>
Object Safety in Trait Objects
</h3><p>Not all traits can produce trait objects. A trait must be object-safe to be used as a trait object. A trait is object-safe if all its methods satisfy the following conditions:</p>
<ol>
<li>The return type cannot be <code>Self</code>.</li>
<li>The method cannot have any generic parameters.</li>
</ol>
<p>This requirement exists because, when using a trait object, the concrete type of the trait is unknown. If a method returns <code>Self</code>, there is ambiguity since the specific type is not available. For example, the <code>Clone</code> trait cannot generate a trait object because its <code>clone()</code> method returns <code>Self</code>.</p>
<p>Similarly, traits with generic parameters cannot produce trait objects because generics require type information known at compile time, while trait objects are resolved at runtime.</p>
<h2 id="understanding-vtable-in-rust">
<a class="header-anchor" href="#understanding-vtable-in-rust"></a>
Understanding <code>vtable</code> in Rust
</h2><p>Some may wonder why I say that &ldquo;a vtable is generated for each type&rsquo;s implementation of every trait.&rdquo; While this isn&rsquo;t explicitly mentioned in any public documentation, we can explore this data structure by printing its address to track its behavior. Below is a code snippet that you can run to deepen your understanding of <code>vtable</code>.</p>
<h3 id="demo-code">
<a class="header-anchor" href="#demo-code"></a>
Demo Code
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="p">{</span><span class="n">Debug</span><span class="p">,</span><span class="w"> </span><span class="n">Display</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">transmute</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello world!&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;goodbye world!&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Creating Display/Debug trait objects for s1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">w1</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Display</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">w2</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Debug</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Creating Display/Debug trait objects for s2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">w3</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Display</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">w4</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Debug</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Unsafe transmute to get addresses of the trait objects and their vtables
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">addr1</span><span class="p">,</span><span class="w"> </span><span class="n">vtable1</span><span class="p">)</span>: <span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">transmute</span><span class="p">(</span><span class="n">w1</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">addr2</span><span class="p">,</span><span class="w"> </span><span class="n">vtable2</span><span class="p">)</span>: <span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">transmute</span><span class="p">(</span><span class="n">w2</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">addr3</span><span class="p">,</span><span class="w"> </span><span class="n">vtable3</span><span class="p">)</span>: <span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">transmute</span><span class="p">(</span><span class="n">w3</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">addr4</span><span class="p">,</span><span class="w"> </span><span class="n">vtable4</span><span class="p">)</span>: <span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">transmute</span><span class="p">(</span><span class="n">w4</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Print the addresses of s1, s2, and the main function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="s">&#34;s1: </span><span class="si">{:p}</span><span class="s">, s2: </span><span class="si">{:p}</span><span class="s">, main(): </span><span class="si">{:p}</span><span class="s">&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Print addresses of the trait objects and their vtables
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;addr1: 0x</span><span class="si">{:x}</span><span class="s">, vtable1: 0x</span><span class="si">{:x}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">addr1</span><span class="p">,</span><span class="w"> </span><span class="n">vtable1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;addr2: 0x</span><span class="si">{:x}</span><span class="s">, vtable2: 0x</span><span class="si">{:x}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">addr2</span><span class="p">,</span><span class="w"> </span><span class="n">vtable2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;addr3: 0x</span><span class="si">{:x}</span><span class="s">, vtable3: 0x</span><span class="si">{:x}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">addr3</span><span class="p">,</span><span class="w"> </span><span class="n">vtable3</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;addr4: 0x</span><span class="si">{:x}</span><span class="s">, vtable4: 0x</span><span class="si">{:x}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">addr4</span><span class="p">,</span><span class="w"> </span><span class="n">vtable4</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Assert that the pointers to the same data are equal
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">addr1</span><span class="p">,</span><span class="w"> </span><span class="n">addr2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">addr3</span><span class="p">,</span><span class="w"> </span><span class="n">addr4</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Assert that the vtables for the same type and trait are equal
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// Here both are String + Display
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">vtable1</span><span class="p">,</span><span class="w"> </span><span class="n">vtable3</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Here both are String + Debug
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">vtable2</span><span class="p">,</span><span class="w"> </span><span class="n">vtable4</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>This example illustrates how Rust manages trait objects and the underlying <code>vtable</code> mechanism. By examining the addresses, you can see that Rust creates a separate vtable for each type&rsquo;s implementation of each trait, reinforcing the type system&rsquo;s flexibility and power.</p>
<h2 id="summary-5">
<a class="header-anchor" href="#summary-5"></a>
Summary
</h2><p>We have covered the definition and usage of traits, including basic traits, associated types, and generic traits. We reviewed how traits enable static dispatch and how trait objects facilitate dynamic dispatch.</p>
<p>Trait objects can be thought of as a powerful tool in Rust, allowing developers to define behaviors abstractly and implement them flexibly.</p>
<h2 id="discussion-3">
<a class="header-anchor" href="#discussion-3"></a>
Discussion
</h2><ol>
<li>Does the following code compile? Why or why not?</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="p">{</span><span class="n">fs</span>::<span class="n">File</span><span class="p">,</span><span class="w"> </span><span class="n">io</span>::<span class="n">Write</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">create</span><span class="p">(</span><span class="s">&#34;/tmp/test_write_trait&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">w</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="k">dyn</span><span class="w"> </span><span class="n">Write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">w</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="sa">b</span><span class="s">&#34;hello &#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">w1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w</span><span class="p">.</span><span class="n">by_ref</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">w1</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="sa">b</span><span class="s">&#34;world&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>The error occurs because the <code>by_ref</code> method requires the type to be <code>Sized</code>, but <code>dyn Write</code> is a trait object and doesn&rsquo;t have a known size at compile time. Trait objects in Rust do not implement the <code>Sized</code> trait, which means you can&rsquo;t use methods that require <code>Self: Sized</code> on them. Here’s how you can adjust your code:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="p">{</span><span class="n">fs</span>::<span class="n">File</span><span class="p">,</span><span class="w"> </span><span class="n">io</span>::<span class="n">Write</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">create</span><span class="p">(</span><span class="s">&#34;/tmp/test_write_trait&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">w</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="k">dyn</span><span class="w"> </span><span class="n">Write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">w</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="sa">b</span><span class="s">&#34;hello &#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">w1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">by_ref</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">w1</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="sa">b</span><span class="s">&#34;world&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>This way, you avoid the trait object and maintain the ability to call <code>by_ref</code>.</p>
<ol start="2">
<li>For those interested, the <code>Iterator</code> trait in Rust includes an associated type <code>Item</code> and a <code>next()</code> method that must be implemented. The <code>next()</code> method should return <code>Some(Item)</code> if another value is available, or <code>None</code> if not. Read the following code and consider how to implement the <code>SentenceIter</code> iterator:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">SentenceIter</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">s</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span> <span class="nc">mut</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">delimiter</span>: <span class="kt">char</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">SentenceIter</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span> <span class="nc">mut</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">delimiter</span>: <span class="kt">char</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">delimiter</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SentenceIter</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="p">;</span><span class="w"> </span><span class="c1">// Consider what type Item should be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Implement next method to make the following test pass
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="fm">todo!</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[test]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">it_works</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;This is the 1st sentence. This is the 2nd sentence.&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SentenceIter</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;.&#39;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="s">&#34;This is the 1st sentence.&#34;</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="s">&#34;This is the 2nd sentence.&#34;</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;a。 b。 c&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sentences</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SentenceIter</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;。&#39;</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;sentences: </span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">sentences</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>To implement the <code>SentenceIter</code> iterator for splitting a string into sentences based on a delimiter, you&rsquo;ll need to define the associated type <code>Item</code> and implement the <code>next()</code> method. Here&rsquo;s how you can do it:</p>
<p><strong>Define <code>Item</code></strong>: The type of each item returned by the iterator should be a <code>String</code> (or a string slice <code>&amp;str</code>).</p>
<p><strong>Implement <code>next()</code></strong>: In the <code>next()</code> method, you&rsquo;ll need to find the next sentence in the string, update the internal state, and return the found sentence.</p>
<p>Here&rsquo;s the complete code:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">SentenceIter</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">s</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span> <span class="nc">mut</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">delimiter</span>: <span class="kt">char</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">SentenceIter</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span> <span class="nc">mut</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">delimiter</span>: <span class="kt">char</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">delimiter</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SentenceIter</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">;</span><span class="w"> </span><span class="c1">// The type returned by the iterator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Check if there&#39;s any string left to process
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span><span class="w"> </span><span class="c1">// No more sentences
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Find the position of the delimiter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">delimiter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// Split the string at the delimiter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">sentence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">s</span><span class="p">[</span><span class="o">..</span><span class="n">pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">s</span><span class="p">[</span><span class="n">pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="p">];</span><span class="w"> </span><span class="c1">// Update self.s to point to the rest of the string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">sentence</span><span class="p">.</span><span class="n">trim</span><span class="p">().</span><span class="n">to_string</span><span class="p">())</span><span class="w"> </span><span class="c1">// Return the sentence as a String
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// No more delimiters, return the rest of the string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">sentence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">s</span><span class="p">);</span><span class="w"> </span><span class="c1">// Take ownership of the remaining string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;&#34;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Clear the string reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">sentence</span><span class="p">.</span><span class="n">trim</span><span class="p">().</span><span class="n">to_string</span><span class="p">())</span><span class="w"> </span><span class="c1">// Return the last sentence
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[test]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">it_works</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;This is the 1st sentence. This is the 2nd sentence.&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SentenceIter</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;.&#39;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="s">&#34;This is the 1st sentence.&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">()));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="s">&#34;This is the 2nd sentence.&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">()));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;a。 b。 c&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sentences</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SentenceIter</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;。&#39;</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;sentences: </span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">sentences</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><ul>
<li><strong><code>next()</code> Method</strong>:
<ul>
<li>Checks if there are any characters left in the string.</li>
<li>If a delimiter is found, it splits the string, updates <code>self.s</code>, and returns the trimmed sentence.</li>
<li>If no delimiter is found, it takes the remaining string, clears <code>self.s</code>, and returns it.</li>
</ul>
</li>
</ul>
<h2 id="additional-reading">
<a class="header-anchor" href="#additional-reading"></a>
Additional Reading
</h2><p>When using traits, two important considerations arise:</p>
<ol>
<li>
<p><strong>Orphan Rule</strong>: At least one of either the trait or the implementing type must be defined in the current crate. You cannot implement a trait for a type that is defined in another crate unless you also defined the trait.</p>
</li>
<li>
<p><strong>Async Functions in Traits</strong>: There is currently no standardized way to implement async functions in traits. If you are interested, refer to the <code>async_trait</code> crate, which allows for seamless integration of async functions in trait implementations. However, using <code>async_trait</code> incurs an additional heap allocation on each call, but this is often acceptable for most applications.</p>
</li>
</ol>
<h1 id="key-traits-to-master">
<a class="header-anchor" href="#key-traits-to-master"></a>
Key Traits to Master
</h1><p>When developing software systems, it&rsquo;s crucial to clarify requirements and conduct architectural analysis and design. During this process, appropriately defining and using traits can enhance the extensibility of the code structure, making the system highly flexible.</p>
<p>Previously, in the &ldquo;Get Hands Dirty&rdquo; series, we briefly explored the immense power of traits, using the <code>From</code> and <code>TryFrom</code> traits for type conversion (in Lecture 5), and the <code>Deref</code> trait (in Lecture 6) to allow access to methods of internal structures without exposing their implementation.</p>
<p>With your growing understanding of traits from the previous lectures, you&rsquo;ll find that effectively using these traits can lead to clearer code structures that align with Rust&rsquo;s ecosystem practices. For instance, if a data structure implements the <code>Debug</code> trait, you can easily print it using the <code>{:?}</code> formatter; if it implements <code>From</code>, you can directly use the <code>into()</code> method for type conversion.</p>
<h2 id="traits">
<a class="header-anchor" href="#traits"></a>
Traits
</h2><p>The Rust standard library defines a wealth of standard traits. Let’s enumerate some you may already know:</p>
<ul>
<li><strong>Clone/Copy</strong>: Define deep and shallow copy behaviors.</li>
<li><strong>Read/Write</strong>: Specify I/O read/write behaviors.</li>
<li><strong>Iterator</strong>: Specify iterator behaviors.</li>
<li><strong>Debug</strong>: Define how data should be displayed for debugging.</li>
<li><strong>Default</strong>: Define how to generate a default value for a type.</li>
<li><strong>From/TryFrom</strong>: Specify how types convert between each other.</li>
</ul>
<p>We will also learn about several other essential traits related to memory allocation and deallocation, marker traits for type safety, operator traits, and those for formatting (Debug/Display/Default).</p>
<h2 id="memory-related-traits-clonecopydrop">
<a class="header-anchor" href="#memory-related-traits-clonecopydrop"></a>
Memory-Related Traits: Clone/Copy/Drop
</h2><p>Let’s dive into memory-related traits: <code>Clone</code>, <code>Copy</code>, and <code>Drop</code>. We’ve touched on these when discussing ownership, but now we’ll explore their definitions and use cases in more depth.</p>
<h3 id="clone-trait">
<a class="header-anchor" href="#clone-trait"></a>
Clone Trait
</h3><p>Here’s the definition of the <code>Clone</code> trait:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Clone</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">clone_from</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">source</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source</span><span class="p">.</span><span class="n">clone</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>The <code>Clone</code> trait has two methods: <code>clone()</code> and <code>clone_from()</code>, with the latter having a default implementation, allowing you to typically only implement <code>clone()</code>. You might wonder about the utility of <code>clone_from()</code>. While <code>a.clone_from(&amp;b)</code> seems equivalent to <code>a = b.clone()</code>, the former avoids unnecessary memory allocation, enhancing efficiency if <code>a</code> already exists.</p>
<p>You can derive <code>Clone</code> using the <code>#[derive(Clone)]</code> macro, simplifying your code. For instance, consider the following <code>Developer</code> struct and <code>Language</code> enum:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="cp">#[derive(Clone, Debug)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">Developer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">age</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">lang</span>: <span class="nc">Language</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[derive(Clone, Debug)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">enum</span> <span class="nc">Language</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Rust</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">TypeScript</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Elixir</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Haskell</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Developer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">name</span>: <span class="s">&#34;Tyr&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">age</span>: <span class="mi">18</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">lang</span>: <span class="nc">Language</span>::<span class="n">Rust</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">dev1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dev</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;dev: </span><span class="si">{:?}</span><span class="s">, addr of dev name: </span><span class="si">{:p}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">as_str</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;dev1: </span><span class="si">{:?}</span><span class="s">, addr of dev1 name: </span><span class="si">{:p}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">dev1</span><span class="p">,</span><span class="w"> </span><span class="n">dev1</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">as_str</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>If <code>Language</code> does not implement <code>Clone</code>, attempting to derive <code>Clone</code> for <code>Developer</code> will result in a compilation error. When you run this code, you’ll see that the <code>String</code> type&rsquo;s heap memory is also cloned, indicating that <code>Clone</code> performs a deep copy.</p>
<h3 id="copy-trait">
<a class="header-anchor" href="#copy-trait"></a>
Copy Trait
</h3><p>In contrast to <code>Clone</code>, the <code>Copy</code> trait is a marker trait without any additional methods. Its definition is as follows:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Copy</span>: <span class="nb">Clone</span> <span class="p">{}</span><span class="w">
</span></span></span></code></pre></div><p>To implement the <code>Copy</code> trait, a type must first implement <code>Clone</code>, followed by implementing an empty <code>Copy</code> trait. You might question the utility of such a trait; however, it serves as a trait bound for type safety checks.</p>
<p>Like <code>Clone</code>, if all fields in a structure implement <code>Copy</code>, you can derive it using <code>#[derive(Copy)]</code>. For instance, modifying the previous code to include <code>Copy</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="cp">#[derive(Clone, Copy, Debug)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">Developer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">age</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">lang</span>: <span class="nc">Language</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[derive(Clone, Copy, Debug)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">enum</span> <span class="nc">Language</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Rust</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">TypeScript</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Elixir</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Haskell</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>This code will fail to compile because <code>String</code> does not implement <code>Copy</code>. Therefore, the <code>Developer</code> struct can only be cloned, not copied. If a type implements <code>Copy</code>, it will be copied during assignment and function calls; otherwise, ownership will be transferred.</p>
<p>You might wonder why immutable references implement <code>Copy</code>, while mutable references (<code>&amp;mut T</code>) do not. If mutable references could implement <code>Copy</code>, it would violate ownership rules, allowing multiple mutable references in the same scope. Rust&rsquo;s standard library carefully considers which structures can be <code>Copy</code> and which cannot.</p>
<h3 id="drop-trait">
<a class="header-anchor" href="#drop-trait"></a>
Drop Trait
</h3><p>We previously discussed the <code>Drop</code> trait in the context of memory management. Its definition is as follows:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Most of the time, you won’t need to implement the <code>Drop</code> trait, as the system automatically drops each field of a data structure in sequence. However, you might want to implement it in two scenarios:</p>
<ol>
<li>To perform specific actions when a data structure&rsquo;s lifetime ends, such as logging.</li>
<li>To manage resource recovery, especially if the compiler cannot infer what additional resources are used.</li>
</ol>
<p>For example, the <code>MutexGuard</code> implements <code>Drop</code> to release lock resources:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MutexGuard</span><span class="o">&lt;</span><span class="nb">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cp">#[inline]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">poison</span><span class="p">.</span><span class="n">done</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">poison</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">raw_unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Importantly, the <code>Copy</code> and <code>Drop</code> traits are mutually exclusive; they cannot coexist. If you try to implement <code>Copy</code> for a type that also implements <code>Drop</code>, the compiler will throw an error. This makes sense, as <code>Copy</code> signifies a shallow copy, while <code>Drop</code> is for releasing resources.</p>
<p>To illustrate, consider the following code where a raw pointer is taken from heap memory. This <code>RawBuffer</code> struct can implement <code>Copy</code>, but if you also implement <code>Drop</code>, it could lead to memory leaks:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="p">{</span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="n">slice</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[derive(Clone, Copy)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">RawBuffer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">ptr</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">len</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">RawBuffer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">into_boxed_slice</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">len</span>: <span class="nc">slice</span><span class="p">.</span><span class="n">len</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">ptr</span>: <span class="nb">Box</span>::<span class="n">into_raw</span><span class="p">(</span><span class="n">slice</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Debug</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">RawBuffer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="nb">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">as_ref</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;{:p}: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">RawBuffer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">slice</span>::<span class="n">from_raw_parts</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">buf</span>: <span class="nc">RawBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">into</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">use_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;buf: </span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">use_buffer</span><span class="p">(</span><span class="n">buf</span>: <span class="nc">RawBuffer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;buf to die: </span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">drop</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w"> </span><span class="c1">// This will drop buf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>For memory safety, is memory leakage more harmful than &ldquo;use after free&rdquo;? Clearly, the latter is more dangerous. Rust prioritizes memory safety, ensuring that even if developers neglect proper memory management, memory safety issues won’t arise.</p>
<h2 id="marker-traits-sizedsendsyncunpin">
<a class="header-anchor" href="#marker-traits-sizedsendsyncunpin"></a>
Marker Traits: Sized/Send/Sync/Unpin
</h2><p>We’ve covered memory-related traits, now let’s look at marker traits. We already saw one: <code>Copy</code>. Rust also supports several other marker traits: <code>Sized</code>, <code>Send</code>, <code>Sync</code>, and <code>Unpin</code>.</p>
<p><strong>Sized</strong><br>
The <code>Sized</code> trait marks types with a known size. When using generic parameters, the Rust compiler automatically adds a <code>Sized</code> constraint. For example, with <code>Data&lt;T&gt;</code> and its processing function <code>process_data</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Data</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">inner</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">process_data</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span>: <span class="nc">Data</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">todo!</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>This is equivalent to:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Data</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">inner</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">process_data</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span>: <span class="nc">Data</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">todo!</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Most of the time, we want this automatic constraint since it allows fixed-size types to be passed as function arguments. Without it, if <code>T</code> is unsized, the function won’t compile. If you need <code>T</code> to be unsized, you can use <code>?Sized</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Cow</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">B</span>: <span class="nb">ToOwned</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Borrowed</span><span class="p">(</span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">B</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Owned</span><span class="p">(</span><span class="o">&lt;</span><span class="n">B</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">ToOwned</span><span class="o">&gt;</span>::<span class="n">Owned</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Here, <code>B</code> can be unsized, like <code>[T]</code> or <code>str</code>, but note that <code>Borrowed(&amp;'a B)</code> has a fixed size because it’s a reference.</p>
<p><strong>Send/Sync</strong><br>
Now, let’s discuss <code>Send</code> and <code>Sync</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="n">auto</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="n">auto</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span></code></pre></div><p>These are unsafe auto traits, meaning the compiler automatically implements them in appropriate contexts. <code>Send</code> allows types to be transferred between threads, while <code>Sync</code> means that a reference to the type can be safely shared across threads. For a type to be <code>Sync</code>, <code>&amp;T</code> must also be <code>Send</code>.</p>
<p>For custom data structures, if all fields implement <code>Send</code>/<code>Sync</code>, then the structure inherits these traits. Most primitive types support them, but exceptions include:</p>
<ul>
<li>Raw pointers (<code>*const T</code>, <code>*mut T</code>)</li>
<li><code>UnsafeCell</code> (does not implement <code>Sync</code>)</li>
<li>Reference counting (<code>Rc</code>), which is not <code>Send</code> or <code>Sync</code></li>
</ul>
<p>Attempting to use <code>Rc</code> across threads will result in a compile error. For instance:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">rc_is_not_send_and_sync</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;c= </span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>This won’t compile.</p>
<p><strong>RefCell and Threading</strong><br>
<code>RefCell</code> implements <code>Send</code>, but not <code>Sync</code>, making it usable in threads. For instance:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">refcell_is_send</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;a= </span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>This compiles successfully. However, using <code>Arc&lt;RefCell&lt;T&gt;&gt;</code> is problematic:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">refcell_is_not_sync</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;c= </span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>This fails because <code>RefCell</code> is not <code>Sync</code>.</p>
<p>To safely share mutable data across threads, use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">sync</span>::<span class="p">{</span><span class="n">Arc</span><span class="p">,</span><span class="w"> </span><span class="n">Mutex</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">arc_mutex_is_send_sync</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Mutex</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">*</span><span class="n">g</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">handle</span><span class="p">.</span><span class="n">join</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="traits-for-type-conversion-fromintoasrefasmut">
<a class="header-anchor" href="#traits-for-type-conversion-fromintoasrefasmut"></a>
Traits for Type Conversion: From/Into/AsRef/AsMut
</h2><p>After understanding marker traits, let’s look at traits related to type conversion. Often, you need to convert between different data structures.</p>
<h3 id="frominto">
<a class="header-anchor" href="#frominto"></a>
From/Into
</h3><p>The <code>From</code> and <code>Into</code> traits facilitate value type conversions:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Into</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">into</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Implementing <code>From</code> automatically provides <code>Into</code>. For example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">s</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="s">&#34;Hello world!&#34;</span><span class="p">.</span><span class="n">into</span><span class="p">();</span><span class="w">
</span></span></span></code></pre></div><h3 id="asrefasmut">
<a class="header-anchor" href="#asrefasmut"></a>
AsRef/AsMut
</h3><p><code>AsRef</code> and <code>AsMut</code> are for reference conversions:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">T</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">AsMut</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">as_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>They allow flexibility in accepting different types. For example, <code>std::fs::File::open</code> can accept <code>String</code>, <code>&amp;str</code>, or <code>Path</code>.</p>
<h2 id="operators-derefderefmut">
<a class="header-anchor" href="#operators-derefderefmut"></a>
Operators: Deref/DerefMut
</h2><p>The <code>Deref</code> and <code>DerefMut</code> traits allow operator overloading:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span>::<span class="n">Target</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">DerefMut</span>: <span class="nc">Deref</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Target</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>They enable seamless interaction with types like smart pointers:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Buffer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span>::<span class="n">Target</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>This allows you to directly access methods of <code>Vec&lt;T&gt;</code> through <code>Buffer&lt;T&gt;</code> without needing explicit access to its inner structure.</p>
<p>By understanding these traits, you can leverage Rust&rsquo;s capabilities for safe and flexible type conversions and operations.</p>
<h2 id="other-traits-debugdisplaydefault">
<a class="header-anchor" href="#other-traits-debugdisplaydefault"></a>
Other Traits: Debug/Display/Default
</h2><p>Now that we have a solid understanding of operator-related traits, let&rsquo;s take a look at some commonly used traits: <code>Debug</code>, <code>Display</code>, and <code>Default</code>.</p>
<h3 id="debug-and-display">
<a class="header-anchor" href="#debug-and-display"></a>
Debug and Display
</h3><p>First, let’s examine <code>Debug</code> and <code>Display</code>. Their definitions are as follows:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Debug</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nb">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Display</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nb">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Both <code>Debug</code> and <code>Display</code> have the same signature, taking <code>&amp;self</code> and <code>&amp;mut Formatter</code>. So why have two traits with identical signatures?</p>
<p>The reason is that <code>Debug</code> is designed for developers to print data structures for debugging purposes, while <code>Display</code> is intended for user-friendly representation. This is why <code>Debug</code> can be derived automatically with macros, whereas <code>Display</code> must be manually implemented. When printing, <code>Debug</code> uses <code>{:?}</code> and <code>Display</code> uses <code>{}</code>.</p>
<h3 id="default-trait">
<a class="header-anchor" href="#default-trait"></a>
Default Trait
</h3><p>Now, let&rsquo;s look at the <code>Default</code> trait, which is defined as follows:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Default</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">default</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>The <code>Default</code> trait provides a default value for types. It can also be generated automatically using the <code>#[derive(Default)]</code> macro, provided every field in the type implements the <code>Default</code> trait. This allows us to partially initialize a data structure and use <code>Default::default()</code> for the remaining fields.</p>
<h3 id="example-usage-of-debug-display-and-default">
<a class="header-anchor" href="#example-usage-of-debug-display-and-default"></a>
Example Usage of Debug, Display, and Default
</h3><p>Here’s a unified example showcasing how to use <code>Debug</code>, <code>Display</code>, and <code>Default</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Struct can derive Default, but all fields must implement Default
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#[derive(Clone, Debug, Default)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">Developer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">age</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">lang</span>: <span class="nc">Language</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Enum cannot derive Default
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#[allow(dead_code)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[derive(Clone, Debug)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">enum</span> <span class="nc">Language</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Rust</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">TypeScript</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Elixir</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Haskell</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Manually implement Default for the enum
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Default</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Language</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">default</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Language</span>::<span class="n">Rust</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Developer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Use ..Default::default() for remaining fields
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">name</span>: <span class="nc">name</span><span class="p">.</span><span class="n">to_owned</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="o">..</span><span class="nb">Default</span>::<span class="n">default</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Implement Display for Developer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Developer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="nb">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">write!</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">f</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="s">&#34;{}({} years old): {:?} developer&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">age</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">lang</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Using T::default()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">dev1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Developer</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Using Default::default(), but type cannot be inferred; must provide type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">dev2</span>: <span class="nc">Developer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Default</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Using T::new
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">dev3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Developer</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;Tyr&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;dev1: </span><span class="si">{}</span><span class="se">\n</span><span class="s">dev2: </span><span class="si">{}</span><span class="se">\n</span><span class="s">dev3: </span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">dev1</span><span class="p">,</span><span class="w"> </span><span class="n">dev2</span><span class="p">,</span><span class="w"> </span><span class="n">dev3</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>The implementation of these traits is straightforward, as demonstrated in the code above.</p>
<h2 id="summary-6">
<a class="header-anchor" href="#summary-6"></a>
Summary
</h2><p>We introduced several fundamental traits related to memory management, type conversion, operator overloading, and data representation, along with marker traits that help the compiler enforce type safety.</p>
<p>Traits occupy a central role in Rust development. A well-designed trait can significantly enhance the usability and extensibility of the entire system.</p>
<p>Many excellent third-party libraries build their capabilities around traits, such as the <code>Service</code> trait in the <code>tower-service</code> library mentioned earlier, and the <code>Parser</code> trait in the <code>nom</code> parser combinator library, which you may frequently use in the future.</p>
<p>Traits implement late binding, which you may recall from earlier discussions about foundational programming concepts. Late binding provides immense flexibility in software development.</p>
<p>From a data perspective, data structures represent concrete data through late binding, and generic structures provide late binding for concrete data structures. From a code perspective, functions are expressions implementing a specific behavior with late binding, and generic functions represent late binding for functions. So what does late binding mean for traits?</p>
<p>Traits represent late binding of behavior. We can define many behaviors of the system through traits without knowing the specific data structures to be processed. This is why I frequently referred to &ldquo;defining behaviors&rdquo; when explaining standard traits.</p>

      
    </div>
    <footer class="article-footer">
      

      

      

      

      

      

      
      <ul class="article-tag-list" itemprop="keywords">
  
</ul>

    </footer>
  </div>
  
    
  <nav
    id="article-nav"
    data-aos="fade-up"
  >
    
      <div class="article-nav-link-wrap article-nav-link-left">
        
          
          
            <img
              data-src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202412220910158.jpg"
              data-sizes="auto"
              alt="Interesting C&#43;&#43; Code Snippets"
              class="lazyload"
            />
          
        
        <a href="https://nothingtosay0031.github.io/post/arm/"></a>
        <div class="article-nav-caption">Newer</div>
        <h3 class="article-nav-title">
          
            Interesting C&#43;&#43; Code Snippets
          
        </h3>
      </div>
    

    
      <div class="article-nav-link-wrap article-nav-link-right">
        
          
          
            <img
              data-src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202412220910158.jpg"
              data-sizes="auto"
              alt="Shadertoy Projects"
              class="lazyload"
            />
          
        
        <a href="https://nothingtosay0031.github.io/post/shadertoy/"></a>
        <div class="article-nav-caption">Older</div>
        <h3 class="article-nav-title">
          
            Shadertoy Projects
          
        </h3>
      </div>
    
  </nav>


  
</article>










</section>
          
            <aside id="sidebar">
  <div class="sidebar-wrapper wrap-sticky">
    <div
      class="sidebar-wrap"
      data-aos="fade-up"
    >
      
        <div class="sidebar-toc-sidebar">
          <div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#memory-management-in-rust---stack-vs-heap">Memory Management in Rust - Stack vs. Heap</a>
      <ul>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#key-concepts">Key Concepts</a></li>
        <li><a href="#when-to-use-stack-vs-heap">When to Use Stack vs. Heap</a></li>
        <li><a href="#problems-with-heap-allocation">Problems with Heap Allocation</a></li>
        <li><a href="#garbage-collection-gc-vs-automatic-reference-counting-arc">Garbage Collection (GC) vs. Automatic Reference Counting (ARC)</a></li>
        <li><a href="#summary">Summary</a></li>
        <li><a href="#discussion">Discussion</a></li>
      </ul>
    </li>
    <li><a href="#essential-programming-concepts">Essential Programming Concepts</a>
      <ul>
        <li><a href="#data-values-types-pointers-and-references">Data: Values, Types, Pointers, and References</a></li>
        <li><a href="#code-functions-methods-closures-interfaces-and-virtual-tables">Code: Functions, Methods, Closures, Interfaces, and Virtual Tables</a></li>
        <li><a href="#execution-models-concurrency-parallelism-sync-and-async">Execution Models: Concurrency, Parallelism, Sync, and Async</a></li>
        <li><a href="#programming-paradigms-generic-programming">Programming Paradigms: Generic Programming</a></li>
        <li><a href="#summary-1">Summary</a></li>
      </ul>
    </li>
    <li><a href="#rust-basics">Rust Basics</a>
      <ul>
        <li><a href="#introduction-1">Introduction</a></li>
        <li><a href="#rust-features">Rust Features</a></li>
        <li><a href="#project-structure-and-testing">Project Structure and Testing</a></li>
      </ul>
    </li>
    <li><a href="#ownership-in-rust">Ownership in Rust</a>
      <ul>
        <li><a href="#key-concepts-1">Key Concepts</a></li>
        <li><a href="#code-examples-and-errors">Code Examples and Errors</a></li>
        <li><a href="#summary-2">Summary</a></li>
      </ul>
    </li>
    <li><a href="#borrowing-in-rust">Borrowing in Rust</a>
      <ul>
        <li><a href="#ownership-basics">Ownership Basics</a></li>
        <li><a href="#borrow-semantics">Borrow Semantics</a></li>
        <li><a href="#immutable-references">Immutable References</a></li>
        <li><a href="#mutable-references">Mutable References</a></li>
        <li><a href="#lifetimes">Lifetimes</a></li>
        <li><a href="#special-cases">Special Cases</a></li>
        <li><a href="#rusts-guarantees">Rust&rsquo;s Guarantees</a></li>
        <li><a href="#discussion-1">Discussion</a></li>
      </ul>
    </li>
    <li><a href="#arc-refcell-and-concurrency">Arc, RefCell, and Concurrency</a>
      <ul>
        <li><a href="#overview">Overview</a></li>
        <li><a href="#reference-counting-rc-and-arc">Reference Counting: <code>Rc</code> and <code>Arc</code></a></li>
        <li><a href="#internal-mutability-cell-and-refcell">Internal Mutability: <code>Cell</code> and <code>RefCell</code></a></li>
        <li><a href="#thread-safety-mutex-and-rwlock">Thread Safety: <code>Mutex</code> and <code>RwLock</code></a></li>
        <li><a href="#implementing-a-mutable-dag">Implementing a Mutable DAG</a></li>
        <li><a href="#summary-3">Summary</a></li>
      </ul>
    </li>
    <li><a href="#lifetimes-in-rust">Lifetimes in Rust</a>
      <ul>
        <li><a href="#introduction-to-lifetimes">Introduction to Lifetimes</a></li>
        <li><a href="#how-the-compiler-determines-lifetimes">How the Compiler Determines Lifetimes</a></li>
        <li><a href="#lifetime-annotations">Lifetime Annotations</a></li>
        <li><a href="#compiler-rules-for-inference">Compiler Rules for Inference</a>
          <ul>
            <li><a href="#multiple-lifetimes-in-functions">Multiple Lifetimes in Functions</a></li>
            <li><a href="#case-study-strtok-implementation-in-rust">Case Study: <code>strtok</code> Implementation in Rust</a>
              <ul>
                <li><a href="#the-problem">The Problem</a></li>
                <li><a href="#solution">Solution</a></li>
                <li><a href="#understanding-lifetimes">Understanding Lifetimes</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#lifetime-in-data-structures">Lifetime in Data Structures</a></li>
        <li><a href="#summary-4">Summary</a></li>
      </ul>
    </li>
    <li><a href="#memory-management-the-lifecycle-of-a-value">Memory Management: The Lifecycle of a Value</a>
      <ul>
        <li><a href="#memory-management-overview">Memory Management Overview</a></li>
        <li><a href="#value-creation">Value Creation</a></li>
        <li><a href="#structs-in-rust">Structs in Rust</a></li>
        <li><a href="#enums-in-rust">Enums in Rust</a></li>
        <li><a href="#memory-layout-of-rust-data-structures">Memory Layout of Rust Data Structures</a></li>
        <li><a href="#using-values">Using Values</a></li>
        <li><a href="#destroying-values">Destroying Values</a>
          <ul>
            <li><a href="#heap-memory-release">Heap Memory Release</a></li>
            <li><a href="#example-file-resource-management">Example: File Resource Management</a></li>
          </ul>
        </li>
        <li><a href="#conclusion">Conclusion</a></li>
      </ul>
    </li>
    <li><a href="#type-system-in-rust">Type System in Rust</a>
      <ul>
        <li><a href="#introduction-to-type-systems">Introduction to Type Systems</a></li>
        <li><a href="#basic-concepts-and-classifications-of-type-systems">Basic Concepts and Classifications of Type Systems</a></li>
        <li><a href="#rusts-type-system">Rust&rsquo;s Type System</a>
          <ul>
            <li><a href="#understanding-type-safety">Understanding Type Safety</a></li>
            <li><a href="#unit-type">Unit Type</a></li>
          </ul>
        </li>
        <li><a href="#data-types-in-rust">Data Types in Rust</a></li>
        <li><a href="#type-inference">Type Inference</a></li>
        <li><a href="#using-generics-for-parametric-polymorphism">Using Generics for Parametric Polymorphism</a>
          <ul>
            <li><a href="#generic-data-structures">Generic Data Structures</a></li>
            <li><a href="#generic-functions">Generic Functions</a></li>
            <li><a href="#summary-of-generics">Summary of Generics</a></li>
          </ul>
        </li>
        <li><a href="#discussion-2">Discussion</a>
          <ul>
            <li><a href="#method-1">Method 1</a></li>
            <li><a href="#method-2">Method 2</a></li>
            <li><a href="#comparison-of-the-two-methods">Comparison of the Two Methods</a>
              <ul>
                <li><a href="#method-1-1">Method 1</a></li>
                <li><a href="#method-2-1">Method 2</a></li>
                <li><a href="#summary-comparison">Summary Comparison:</a></li>
                <li><a href="#which-method-is-better">Which Method is Better?</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#references">References</a></li>
      </ul>
    </li>
    <li><a href="#type-system-using-traits-to-define-interfaces">Type System: Using Traits to Define Interfaces</a>
      <ul>
        <li><a href="#recap-of-polymorphism-types">Recap of Polymorphism Types</a></li>
        <li><a href="#what-are-traits">What are Traits?</a></li>
        <li><a href="#basic-traits">Basic Traits</a></li>
        <li><a href="#basic-trait-exercise">Basic Trait Exercise</a>
          <ul>
            <li><a href="#enhancing-code-reusability">Enhancing Code Reusability</a></li>
            <li><a href="#returning-results-instead-of-defaults">Returning Results Instead of Defaults</a></li>
          </ul>
        </li>
        <li><a href="#generic-traits">Generic Traits</a>
          <ul>
            <li><a href="#implementing-add-for-complex-numbers">Implementing Add for Complex Numbers</a></li>
            <li><a href="#reference-implementations">Reference Implementations</a></li>
          </ul>
        </li>
        <li><a href="#trait-inheritance-in-rust">Trait Inheritance in Rust</a>
          <ul>
            <li><a href="#summary-of-traits">Summary of Traits</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#dynamic-dispatch-in-rust">Dynamic Dispatch in Rust</a>
      <ul>
        <li><a href="#understanding-subtype-polymorphism">Understanding Subtype Polymorphism</a></li>
        <li><a href="#dynamic-dispatch">Dynamic Dispatch</a></li>
        <li><a href="#mechanism-of-trait-objects">Mechanism of Trait Objects</a>
          <ul>
            <li><a href="#object-safety-in-trait-objects">Object Safety in Trait Objects</a></li>
          </ul>
        </li>
        <li><a href="#understanding-vtable-in-rust">Understanding <code>vtable</code> in Rust</a>
          <ul>
            <li><a href="#demo-code">Demo Code</a></li>
          </ul>
        </li>
        <li><a href="#summary-5">Summary</a></li>
        <li><a href="#discussion-3">Discussion</a></li>
        <li><a href="#additional-reading">Additional Reading</a></li>
      </ul>
    </li>
    <li><a href="#key-traits-to-master">Key Traits to Master</a>
      <ul>
        <li><a href="#traits">Traits</a></li>
        <li><a href="#memory-related-traits-clonecopydrop">Memory-Related Traits: Clone/Copy/Drop</a>
          <ul>
            <li><a href="#clone-trait">Clone Trait</a></li>
            <li><a href="#copy-trait">Copy Trait</a></li>
            <li><a href="#drop-trait">Drop Trait</a></li>
          </ul>
        </li>
        <li><a href="#marker-traits-sizedsendsyncunpin">Marker Traits: Sized/Send/Sync/Unpin</a></li>
        <li><a href="#traits-for-type-conversion-fromintoasrefasmut">Traits for Type Conversion: From/Into/AsRef/AsMut</a>
          <ul>
            <li><a href="#frominto">From/Into</a></li>
            <li><a href="#asrefasmut">AsRef/AsMut</a></li>
          </ul>
        </li>
        <li><a href="#operators-derefderefmut">Operators: Deref/DerefMut</a></li>
        <li><a href="#other-traits-debugdisplaydefault">Other Traits: Debug/Display/Default</a>
          <ul>
            <li><a href="#debug-and-display">Debug and Display</a></li>
            <li><a href="#default-trait">Default Trait</a></li>
            <li><a href="#example-usage-of-debug-display-and-default">Example Usage of Debug, Display, and Default</a></li>
          </ul>
        </li>
        <li><a href="#summary-6">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
        </div>
        <div class="sidebar-common-sidebar hidden">
          
<div class="sidebar-author">
  <img
    data-src="https://nothingtosay0031.github.io/avatar/../avatar.webp"
    data-sizes="auto"
    alt="NothingToSay0031"
    class="lazyload"
  />
  <div class="sidebar-author-name">NothingToSay0031</div>
  <div class="sidebar-description">又是一个做水果蛋糕的好天气啊！</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div>
    
    <div class="sidebar-state-number">24</div>
  </div>
  <div class="sidebar-state-category">
    <div>Categories</div>
    <div class="sidebar-state-number">
      0
    </div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tags</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-email sidebar-social-icon">
      <a
        href="mailto:jhwzju@gmail.com"
        itemprop="url"
        target="_blank"
        aria-label="email"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-github sidebar-social-icon">
      <a
        href="https://github.com/NothingToSay0031"
        itemprop="url"
        target="_blank"
        aria-label="github"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-linkedin sidebar-social-icon">
      <a
        href="https://www.linkedin.com/in/hongweiji"
        itemprop="url"
        target="_blank"
        aria-label="linkedin"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/"
        aria-label="Home"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Home</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/archives"
        aria-label="Archives"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Archives</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/about"
        aria-label="About"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">About</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/friend"
        aria-label="Friend"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Friend</div>
    </div>
  
</div>

        </div>
      

      
        <div class="sidebar-btn-wrapper" style="position:static">
          <div class="sidebar-toc-btn current"></div>
          <div class="sidebar-common-btn"></div>
        </div>
      
    </div>
  </div>

  
</aside>

          
        </main>
        



  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  



<footer id="footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div id="footer-info">
    <div>
      <span class="icon-copyright"></span>
      2021 -
      2025
      <span class="footer-info-sep rotate"></span>
      NothingToSay0031
    </div>
    
      <div>
        Powered by&nbsp;<a
          href="https://gohugo.io/"
          target="_blank"
          >Hugo</a
        >&nbsp; Theme.<a
          href="https://github.com/D-Sketon/hugo-theme-reimu"
          target="_blank"
          >Reimu</a
        >
      </div>
    
    
      <div>
        <span class="icon-brush"
          >&nbsp;
            61.7k
          </span
        >
        &nbsp;|&nbsp;
        <span class="icon-coffee">&nbsp;
          
          

          05:04
        </span>
      </div>
    
    
    
    
      <div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv"
          >Number of visits&nbsp;<span
            id="busuanzi_value_site_pv"
          ></span
        ></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv"
          >Number of visitors&nbsp;<span
            id="busuanzi_value_site_uv"
          ></span
        ></span>
      </div>
    
  </div>
</footer>

        
          <div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div>
        
        <div id="mask" class="hide"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar">
        <div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#memory-management-in-rust---stack-vs-heap">Memory Management in Rust - Stack vs. Heap</a>
      <ul>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#key-concepts">Key Concepts</a></li>
        <li><a href="#when-to-use-stack-vs-heap">When to Use Stack vs. Heap</a></li>
        <li><a href="#problems-with-heap-allocation">Problems with Heap Allocation</a></li>
        <li><a href="#garbage-collection-gc-vs-automatic-reference-counting-arc">Garbage Collection (GC) vs. Automatic Reference Counting (ARC)</a></li>
        <li><a href="#summary">Summary</a></li>
        <li><a href="#discussion">Discussion</a></li>
      </ul>
    </li>
    <li><a href="#essential-programming-concepts">Essential Programming Concepts</a>
      <ul>
        <li><a href="#data-values-types-pointers-and-references">Data: Values, Types, Pointers, and References</a></li>
        <li><a href="#code-functions-methods-closures-interfaces-and-virtual-tables">Code: Functions, Methods, Closures, Interfaces, and Virtual Tables</a></li>
        <li><a href="#execution-models-concurrency-parallelism-sync-and-async">Execution Models: Concurrency, Parallelism, Sync, and Async</a></li>
        <li><a href="#programming-paradigms-generic-programming">Programming Paradigms: Generic Programming</a></li>
        <li><a href="#summary-1">Summary</a></li>
      </ul>
    </li>
    <li><a href="#rust-basics">Rust Basics</a>
      <ul>
        <li><a href="#introduction-1">Introduction</a></li>
        <li><a href="#rust-features">Rust Features</a></li>
        <li><a href="#project-structure-and-testing">Project Structure and Testing</a></li>
      </ul>
    </li>
    <li><a href="#ownership-in-rust">Ownership in Rust</a>
      <ul>
        <li><a href="#key-concepts-1">Key Concepts</a></li>
        <li><a href="#code-examples-and-errors">Code Examples and Errors</a></li>
        <li><a href="#summary-2">Summary</a></li>
      </ul>
    </li>
    <li><a href="#borrowing-in-rust">Borrowing in Rust</a>
      <ul>
        <li><a href="#ownership-basics">Ownership Basics</a></li>
        <li><a href="#borrow-semantics">Borrow Semantics</a></li>
        <li><a href="#immutable-references">Immutable References</a></li>
        <li><a href="#mutable-references">Mutable References</a></li>
        <li><a href="#lifetimes">Lifetimes</a></li>
        <li><a href="#special-cases">Special Cases</a></li>
        <li><a href="#rusts-guarantees">Rust&rsquo;s Guarantees</a></li>
        <li><a href="#discussion-1">Discussion</a></li>
      </ul>
    </li>
    <li><a href="#arc-refcell-and-concurrency">Arc, RefCell, and Concurrency</a>
      <ul>
        <li><a href="#overview">Overview</a></li>
        <li><a href="#reference-counting-rc-and-arc">Reference Counting: <code>Rc</code> and <code>Arc</code></a></li>
        <li><a href="#internal-mutability-cell-and-refcell">Internal Mutability: <code>Cell</code> and <code>RefCell</code></a></li>
        <li><a href="#thread-safety-mutex-and-rwlock">Thread Safety: <code>Mutex</code> and <code>RwLock</code></a></li>
        <li><a href="#implementing-a-mutable-dag">Implementing a Mutable DAG</a></li>
        <li><a href="#summary-3">Summary</a></li>
      </ul>
    </li>
    <li><a href="#lifetimes-in-rust">Lifetimes in Rust</a>
      <ul>
        <li><a href="#introduction-to-lifetimes">Introduction to Lifetimes</a></li>
        <li><a href="#how-the-compiler-determines-lifetimes">How the Compiler Determines Lifetimes</a></li>
        <li><a href="#lifetime-annotations">Lifetime Annotations</a></li>
        <li><a href="#compiler-rules-for-inference">Compiler Rules for Inference</a>
          <ul>
            <li><a href="#multiple-lifetimes-in-functions">Multiple Lifetimes in Functions</a></li>
            <li><a href="#case-study-strtok-implementation-in-rust">Case Study: <code>strtok</code> Implementation in Rust</a>
              <ul>
                <li><a href="#the-problem">The Problem</a></li>
                <li><a href="#solution">Solution</a></li>
                <li><a href="#understanding-lifetimes">Understanding Lifetimes</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#lifetime-in-data-structures">Lifetime in Data Structures</a></li>
        <li><a href="#summary-4">Summary</a></li>
      </ul>
    </li>
    <li><a href="#memory-management-the-lifecycle-of-a-value">Memory Management: The Lifecycle of a Value</a>
      <ul>
        <li><a href="#memory-management-overview">Memory Management Overview</a></li>
        <li><a href="#value-creation">Value Creation</a></li>
        <li><a href="#structs-in-rust">Structs in Rust</a></li>
        <li><a href="#enums-in-rust">Enums in Rust</a></li>
        <li><a href="#memory-layout-of-rust-data-structures">Memory Layout of Rust Data Structures</a></li>
        <li><a href="#using-values">Using Values</a></li>
        <li><a href="#destroying-values">Destroying Values</a>
          <ul>
            <li><a href="#heap-memory-release">Heap Memory Release</a></li>
            <li><a href="#example-file-resource-management">Example: File Resource Management</a></li>
          </ul>
        </li>
        <li><a href="#conclusion">Conclusion</a></li>
      </ul>
    </li>
    <li><a href="#type-system-in-rust">Type System in Rust</a>
      <ul>
        <li><a href="#introduction-to-type-systems">Introduction to Type Systems</a></li>
        <li><a href="#basic-concepts-and-classifications-of-type-systems">Basic Concepts and Classifications of Type Systems</a></li>
        <li><a href="#rusts-type-system">Rust&rsquo;s Type System</a>
          <ul>
            <li><a href="#understanding-type-safety">Understanding Type Safety</a></li>
            <li><a href="#unit-type">Unit Type</a></li>
          </ul>
        </li>
        <li><a href="#data-types-in-rust">Data Types in Rust</a></li>
        <li><a href="#type-inference">Type Inference</a></li>
        <li><a href="#using-generics-for-parametric-polymorphism">Using Generics for Parametric Polymorphism</a>
          <ul>
            <li><a href="#generic-data-structures">Generic Data Structures</a></li>
            <li><a href="#generic-functions">Generic Functions</a></li>
            <li><a href="#summary-of-generics">Summary of Generics</a></li>
          </ul>
        </li>
        <li><a href="#discussion-2">Discussion</a>
          <ul>
            <li><a href="#method-1">Method 1</a></li>
            <li><a href="#method-2">Method 2</a></li>
            <li><a href="#comparison-of-the-two-methods">Comparison of the Two Methods</a>
              <ul>
                <li><a href="#method-1-1">Method 1</a></li>
                <li><a href="#method-2-1">Method 2</a></li>
                <li><a href="#summary-comparison">Summary Comparison:</a></li>
                <li><a href="#which-method-is-better">Which Method is Better?</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#references">References</a></li>
      </ul>
    </li>
    <li><a href="#type-system-using-traits-to-define-interfaces">Type System: Using Traits to Define Interfaces</a>
      <ul>
        <li><a href="#recap-of-polymorphism-types">Recap of Polymorphism Types</a></li>
        <li><a href="#what-are-traits">What are Traits?</a></li>
        <li><a href="#basic-traits">Basic Traits</a></li>
        <li><a href="#basic-trait-exercise">Basic Trait Exercise</a>
          <ul>
            <li><a href="#enhancing-code-reusability">Enhancing Code Reusability</a></li>
            <li><a href="#returning-results-instead-of-defaults">Returning Results Instead of Defaults</a></li>
          </ul>
        </li>
        <li><a href="#generic-traits">Generic Traits</a>
          <ul>
            <li><a href="#implementing-add-for-complex-numbers">Implementing Add for Complex Numbers</a></li>
            <li><a href="#reference-implementations">Reference Implementations</a></li>
          </ul>
        </li>
        <li><a href="#trait-inheritance-in-rust">Trait Inheritance in Rust</a>
          <ul>
            <li><a href="#summary-of-traits">Summary of Traits</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#dynamic-dispatch-in-rust">Dynamic Dispatch in Rust</a>
      <ul>
        <li><a href="#understanding-subtype-polymorphism">Understanding Subtype Polymorphism</a></li>
        <li><a href="#dynamic-dispatch">Dynamic Dispatch</a></li>
        <li><a href="#mechanism-of-trait-objects">Mechanism of Trait Objects</a>
          <ul>
            <li><a href="#object-safety-in-trait-objects">Object Safety in Trait Objects</a></li>
          </ul>
        </li>
        <li><a href="#understanding-vtable-in-rust">Understanding <code>vtable</code> in Rust</a>
          <ul>
            <li><a href="#demo-code">Demo Code</a></li>
          </ul>
        </li>
        <li><a href="#summary-5">Summary</a></li>
        <li><a href="#discussion-3">Discussion</a></li>
        <li><a href="#additional-reading">Additional Reading</a></li>
      </ul>
    </li>
    <li><a href="#key-traits-to-master">Key Traits to Master</a>
      <ul>
        <li><a href="#traits">Traits</a></li>
        <li><a href="#memory-related-traits-clonecopydrop">Memory-Related Traits: Clone/Copy/Drop</a>
          <ul>
            <li><a href="#clone-trait">Clone Trait</a></li>
            <li><a href="#copy-trait">Copy Trait</a></li>
            <li><a href="#drop-trait">Drop Trait</a></li>
          </ul>
        </li>
        <li><a href="#marker-traits-sizedsendsyncunpin">Marker Traits: Sized/Send/Sync/Unpin</a></li>
        <li><a href="#traits-for-type-conversion-fromintoasrefasmut">Traits for Type Conversion: From/Into/AsRef/AsMut</a>
          <ul>
            <li><a href="#frominto">From/Into</a></li>
            <li><a href="#asrefasmut">AsRef/AsMut</a></li>
          </ul>
        </li>
        <li><a href="#operators-derefderefmut">Operators: Deref/DerefMut</a></li>
        <li><a href="#other-traits-debugdisplaydefault">Other Traits: Debug/Display/Default</a>
          <ul>
            <li><a href="#debug-and-display">Debug and Display</a></li>
            <li><a href="#default-trait">Default Trait</a></li>
            <li><a href="#example-usage-of-debug-display-and-default">Example Usage of Debug, Display, and Default</a></li>
          </ul>
        </li>
        <li><a href="#summary-6">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
      </div>
      <div class="sidebar-common-sidebar hidden">
        
<div class="sidebar-author">
  <img
    data-src="https://nothingtosay0031.github.io/avatar/../avatar.webp"
    data-sizes="auto"
    alt="NothingToSay0031"
    class="lazyload"
  />
  <div class="sidebar-author-name">NothingToSay0031</div>
  <div class="sidebar-description">又是一个做水果蛋糕的好天气啊！</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div>
    
    <div class="sidebar-state-number">24</div>
  </div>
  <div class="sidebar-state-category">
    <div>Categories</div>
    <div class="sidebar-state-number">
      0
    </div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tags</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-email sidebar-social-icon">
      <a
        href="mailto:jhwzju@gmail.com"
        itemprop="url"
        target="_blank"
        aria-label="email"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-github sidebar-social-icon">
      <a
        href="https://github.com/NothingToSay0031"
        itemprop="url"
        target="_blank"
        aria-label="github"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-linkedin sidebar-social-icon">
      <a
        href="https://www.linkedin.com/in/hongweiji"
        itemprop="url"
        target="_blank"
        aria-label="linkedin"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/"
        aria-label="Home"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Home</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/archives"
        aria-label="Archives"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Archives</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/about"
        aria-label="About"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">About</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/friend"
        aria-label="Friend"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Friend</div>
    </div>
  
</div>

      </div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    
    






  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js"
    
    
    
    
    integrity="sha384-3gT/vsepWkfz/ff7PpWNUeMzeWoH3cDhm/A8jM7ouoAK0/fP/9bcHHR5kHq2nf&#43;e" crossorigin="anonymous"
  ></script>




  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js"
    
    
    
    
    integrity="sha384-J08i8An/QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"
  ></script>









  
      
      <script src="https://nothingtosay0031.github.io/js/main.js" integrity="" crossorigin="anonymous" ></script>
      



  





  
      
      <script src="https://nothingtosay0031.github.io/js/aos.js" integrity="" crossorigin="anonymous" ></script>
      

  <script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", aosInit);
    } else {
      aosInit();
    }
  </script>








  
      
      <script src="https://nothingtosay0031.github.io/js/pjax_main.js" integrity="" crossorigin="anonymous" data-pjax></script>
      





  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/mouse-firework@0.0.6/dist/index.umd.js"
    
    
    
    
    integrity="sha384-vkGvf25gm1C1PbcoD5dNfc137HzNL/hr1RKA5HniJOaawtvUmH5lTVFgFAruE9Ge" crossorigin="anonymous"
  ></script>


<script>
  if (window.firework) {
    const options = JSON.parse("{\"excludeelements\":[\"a\",\"button\"],\"particles\":[{\"colors\":[\"#ff5252\",\"#ff7c7c\",\"#ffafaf\",\"#ffd0d0\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"emit\"],\"number\":20,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.3,0.5],\"radius\":[16,32]}},{\"colors\":[\"#ff0000\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"diffuse\"],\"number\":1,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.2,0.5],\"lineWidth\":6,\"radius\":20}}]}");
    options.excludeElements = options.excludeelements;
    delete options.excludeelements;
    window.firework(options);
  }
</script>








<div id="lazy-script">
  <div>
    
    
      





  
      
      <script src="https://nothingtosay0031.github.io/js/insert_highlight.js" integrity="" crossorigin="anonymous" data-pjax></script>
      

      
      
      
      
      <script type="module" data-pjax>
        const PhotoSwipeLightbox = (await safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe-lightbox.esm.min.js", "sha384-DiL6M\/gG\u002bwmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF\/N6lrZi\/")).default;

        const pswp = () => {
          if (_$$('.article-entry a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-entry',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")
            }).init();
          }
          if(_$$('.article-gallery a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-gallery',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")
            }).init();
          }
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script>
      












    
    
  </div>
</div>




  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js"
    
    async
    
    
    integrity="sha384-0M75wtSkhjIInv4coYlaJU83&#43;OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id&#43;S" crossorigin="anonymous"
  ></script>





  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then((registrations) => {
        for (let registration of registrations) {
          registration.unregister();
        }
      });
    }
  </script>


<script>
  const reimuCopyright = String.raw`
   ______     ______     __     __    __     __  __    
  /\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
  \ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
   \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
    \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                    
  `;
  console.log(String.raw`%c ${reimuCopyright}`, "color: #ff5252;");
  console.log(
    "%c Theme.Reimu" + " %c https://github.com/D-Sketon/hugo-theme-reimu ",
    "color: white; background: #ff5252; padding:5px 0;",
    "padding:4px;border:1px solid #ff5252;",
  );
</script>

  </body>
</html>
