<!doctype html>
<html
  lang="en-us"
  
>
  <head>
    <meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, shrink-to-fit=no"
/>







  

<title>
  NVIDIA RTXPT: Code Walkthrough | NothingToSay0031
</title>
<meta
  name="description"
  content="Real-time path tracing library and sample."
/>










<script>
  window.siteConfig = JSON.parse("{\"anchor_icon\":null,\"clipboard\":{\"copyright\":{\"content\":\"本文版权：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！\",\"count\":50,\"enable\":false},\"fail\":\"复制失败 (ﾟ⊿ﾟ)ﾂ\",\"success\":\"复制成功(*^▽^*)\"},\"code_block\":{\"expand\":true},\"icon_font\":\"4552607_tq6stt6tcg\",\"outdate\":{\"daysago\":180,\"enable\":false,\"message\":\"本文最后更新于 {time}，请注意文中内容可能已经发生变化。\"}}");
</script>











  
  
  
    
  

  
  
  
    
  

  
    

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  rel="preload"
  as="style"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
/>
<link
  rel="stylesheet"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
  media="print"
  onload="this.media='all'"
/>






  <link
    rel="preload"
    href="//at.alicdn.com/t/c/font_4552607_tq6stt6tcg.woff2"
    as="font"
    type="font/woff2"
    crossorigin="anonymous"
  />



  







  
 <link rel="stylesheet" href="https://nothingtosay0031.github.io/css/loader.min.2ad0e9bbffb534e893c0ecefc44787a277cf851387e8ad9dccfbc3a5f0886dbe.css" />




  <meta property="og:type" content="website" />
  <meta property="og:title" content="NVIDIA RTXPT: Code Walkthrough | NothingToSay0031" />
  <meta
    property="og:description"
    content="Real-time path tracing library and sample."
  />
  <meta property="og:url" content="https://nothingtosay0031.github.io/post/rtxpt/" />
  <meta
    property="og:site_name"
    content="NothingToSay0031"
  />
  <meta
    property="og:image"
    content="/"
  />
  <meta property="article:author" content="NothingToSay0031" />
  <meta property="article:published_time" content="2025-05-09T20:25:47&#43;08:00" />
  <meta property="article:modified_time" content="2025-05-09T20:25:47&#43;08:00" />
  
  
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:image" content="/" />
  
  
  
  
  




<link rel="shortcut icon" href="https://nothingtosay0031.github.io/favicon.ico">








  
 <link rel="stylesheet" href="https://nothingtosay0031.github.io/css/main.min.4e3ed4ec96a449612baa01e942ad2e62fab14c5e1e8f6b3eeb13d1cbc2e0dc67.css" />





  <link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css"
    onload="this.onload=null;this.rel='stylesheet'"
  />






  <link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/katex@0.16.9/dist/katex.min.css"
    onload="this.onload=null;this.rel='stylesheet'"
  />








  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js"
    
    
    
    
    integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"
  ></script>





  


  <link rel="stylesheet" href="https://npm.webcache.cn/@reimujs/aos@0.1.0/dist/aos.css" />




  </head>
  <body>
    
  <div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        
          <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
            <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="#ff5252" />
            <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z 
          M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95z" fill="#ff5252" />
          </svg>
        
      </div>
      <div class="loading-word">少女祈祷中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>


<div id="copy-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
</div>


    <div id="container">
      <div id="wrap">
        
<div id="header-nav">
  <nav id="main-nav">
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/">Home</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/archives">Archives</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/about">About</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/friend">Friend</a>
      </span>
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
    
  </nav>
</div>
<header id="header">
  
    <img fetchpriority="high" src="https://nothingtosay0031.github.io/images/banner.webp" alt="NVIDIA RTXPT: Code Walkthrough">
  

  <div id="header-outer">
    <div id="header-title">
      
        
        
          
        
  
        
          <a href="https://nothingtosay0031.github.io/" id="logo">
            <h1 data-aos="slide-up">NVIDIA RTXPT: Code Walkthrough</h1>
          </a>
        
      
  
      
        
        
        <h2 id="subtitle-wrap" data-aos="slide-down">
          
        </h2>
      
    </div>
  </div>
</header>
        <main id="content">
          
          <section id="main">
  <article
  class="h-entry article"
  itemprop="blogPost"
  itemscope
  itemtype="https://schema.org/BlogPosting"
>
  <div
    class="article-inner"
    data-aos="fade-up"
  >
    <div class="article-meta">
      <div class="article-date">
  <a
    href="https://nothingtosay0031.github.io/post/rtxpt/"
    class="article-date-link"
    data-aos="zoom-in"
  >
    <time datetime="2025-05-09 20:25:47 &#43;0800 CST" itemprop="datePublished"
      >2025-05-09</time
    >
    <time style="display: none;" id="post-update-time"
      >2025-05-09</time
    >
  </a>
</div>

      <div class="article-category">
  
</div>

    </div>
    <div class="hr-line"></div>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
      
        <p>这篇博客主要探讨了 NVIDIA 开源的 <a href="https://github.com/NVIDIA-RTX/RTXPT">RTX Path Tracing (RTXPT)</a> 项目。路径追踪的基础知识我是在 TU Wien 的 Rendering 课程上学习的，当时也写了一篇<a href="https://nothingtosay0031.github.io/post/mis_nee/">关于 MIS 和 NEE 的博客</a>，但一直没有真正编写过完整的 Path Tracing 代码，对 NEE 和 BSDF 在 MIS 中的正确计算也只是略知一二。最近看到这个项目，觉得是个很好的学习机会，正好可以深入理解这些概念。虽然这个库还实现了许多实时路径追踪的优化算法，但本篇主要聚焦于 MIS 和 NEE 的实现过程。</p>
<h1 id="raygen-shader">
<a class="header-anchor" href="#raygen-shader"></a>
<code>RayGen</code> Shader
</h1><p>我们来开始解析 NVIDIA RTXPT 代码中的 <code>Sample.hlsl</code> 文件，并从 <code>RayGen</code> (光线生成) 着色器入手。这部分是路径追踪的起点，负责为每个像素生成初始光线并驱动整个追踪过程。</p>
<p>在 DirectX Raytracing (DXR) 中，<code>RayGen</code> 着色器是光线追踪管线的入口点。对于屏幕上的每一个像素（或者说，每一个调度），<code>RayGen</code> 着色器都会被执行一次。它的主要任务是：</p>
<ol>
<li><strong>初始化</strong>：设置当前像素的追踪环境和状态。</li>
<li><strong>生成主光线</strong> (Primary Ray)：根据相机参数计算从视点出发，穿过当前像素的光线。</li>
<li><strong>驱动光线追踪</strong>：调用光线追踪的核心逻辑，模拟光线在场景中的传播、碰撞和着色。</li>
<li><strong>收集结果</strong>：将最终计算得到的颜色写入输出纹理。</li>
</ol>
<p>现在，让我们深入 <code>Sample.hlsl</code> 中的 <code>RayGen</code> 函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hlsl" data-lang="hlsl"><span class="line"><span class="cl"><span class="p">[</span><span class="n">shader</span><span class="p">(</span><span class="s">&#34;raygeneration&#34;</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">RayGen</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 获取当前像素坐标</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint2</span> <span class="n">pixelPos</span> <span class="o">=</span> <span class="n">DispatchRaysIndex</span><span class="p">().</span><span class="n">xy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 初始化工作上下文 (WorkingContext)</span>
</span></span><span class="line"><span class="cl">    <span class="n">PathTracer</span><span class="o">::</span><span class="n">WorkingContext</span> <span class="n">workingContext</span> <span class="o">=</span> <span class="n">getWorkingContext</span><span class="p">(</span> <span class="n">pixelPos</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 根据不同的路径追踪模式进行初始化</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE!=PATH_TRACER_MODE_REFERENCE</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 对于非参考模式，启动稳定平面相关的路径追踪过程</span>
</span></span><span class="line"><span class="cl">    <span class="n">workingContext</span><span class="p">.</span><span class="n">stablePlanes</span><span class="p">.</span><span class="n">StartPathTracingPass</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE!=PATH_TRACER_MODE_FILL_STABLE_PLANES</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 对于非填充稳定平面模式，重置调试信息</span>
</span></span><span class="line"><span class="cl">    <span class="n">workingContext</span><span class="p">.</span><span class="n">debug</span><span class="p">.</span><span class="n">Reset</span><span class="p">(</span><span class="mo">0</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 子采样索引，这里固定为0，注释表明是为了降噪引导缓冲区的稳定性</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint</span> <span class="n">subSampleIndex</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// PathState 用于存储和管理一条光路的所有状态信息</span>
</span></span><span class="line"><span class="cl">    <span class="n">PathState</span> <span class="n">path</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 初始化路径状态并设置主光线</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    - EmptyPathInitialize: 初始化路径的基本状态 (如像素ID，相机像素锥角等)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    - computeCameraRay: 根据像素位置计算相机光线</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    - SetupPathPrimaryRay: 将计算出的相机光线设置到path状态中</span>
</span></span><span class="line"><span class="cl">    <span class="n">path</span> <span class="o">=</span> <span class="n">PathTracer</span><span class="o">::</span><span class="n">EmptyPathInitialize</span><span class="p">(</span><span class="n">pixelPos</span><span class="p">,</span> <span class="n">g_Const</span><span class="p">.</span><span class="n">ptConsts</span><span class="p">.</span><span class="n">camera</span><span class="p">.</span><span class="n">PixelConeSpreadAngle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">PathTracer</span><span class="o">::</span><span class="n">SetupPathPrimaryRay</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">Bridge</span><span class="o">::</span><span class="n">computeCameraRay</span><span class="p">(</span><span class="n">pixelPos</span><span class="p">,</span> <span class="cm">/*subSampleIndex*/</span><span class="mo">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4. 【可选】根据稳定平面模式处理首次命中</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE==PATH_TRACER_MODE_FILL_STABLE_PLANES</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果是 PATH_TRACER_MODE_FILL_STABLE_PLANES 模式，</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 光线的首次命中信息会从预计算的“基础稳定平面”(base stable plane, index 0)加载，</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 而不是实际追踪主光线。这是一种优化手段，可以复用之前计算的结果。</span>
</span></span><span class="line"><span class="cl">    <span class="n">firstHitFromBasePlane</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// lastOrigin = path.origin; // 记录光线起点，这里被注释掉了</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化用于构建稳定平面的次表面位置法线信息 (如果处于该模式)</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE_BUILD_STABLE_PLANES==1</span>
</span></span><span class="line"><span class="cl">    <span class="n">u_SecondarySurfacePositionNormal</span><span class="p">[</span><span class="n">pixelPos</span><span class="p">]</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 5. 主路径追踪循环</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    只要光线路径仍然有效 (isActive)，就继续调用 nextHit 进行下一次弹射处理</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">isActive</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="n">nextHit</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span> <span class="c1">// false 参数表示不跳过稳定平面探索</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 6. 数据清理：处理 NaN 或 无穷大值</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    防止计算过程中出现非法数值导致最终结果异常</span>
</span></span><span class="line"><span class="cl">    <span class="n">SanitizeNaNs</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="c1">// 7. 【可选】根据稳定平面模式提交降噪器相关的光照信息</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE==PATH_TRACER_MODE_FILL_STABLE_PLANES</span>
</span></span><span class="line"><span class="cl">    <span class="n">workingContext</span><span class="p">.</span><span class="n">stablePlanes</span><span class="p">.</span><span class="n">CommitDenoiserRadiance</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">getStablePlaneIndex</span><span class="p">(),</span> <span class="n">path</span><span class="p">.</span><span class="n">denoiserSampleHitTFromPlane</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">denoiserDiffRadianceHitDist</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">denoiserSpecRadianceHitDist</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">secondaryL</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">hasFlag</span><span class="p">(</span><span class="n">PathFlags</span><span class="o">::</span><span class="n">stablePlaneBaseScatterDiff</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">hasFlag</span><span class="p">(</span><span class="n">PathFlags</span><span class="o">::</span><span class="n">stablePlaneOnDeltaBranch</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">hasFlag</span><span class="p">(</span><span class="n">PathFlags</span><span class="o">::</span><span class="n">stablePlaneOnDominantBranch</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif    </span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 8. 根据不同的路径追踪模式，计算最终的路径光照贡献</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float3</span> <span class="n">pathRadiance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE==PATH_TRACER_MODE_REFERENCE</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 参考模式：直接使用路径累计的光照 (path.L)</span>
</span></span><span class="line"><span class="cl">    <span class="n">pathRadiance</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">L</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#elif PATH_TRACER_MODE==PATH_TRACER_MODE_BUILD_STABLE_PLANES</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 构建稳定平面模式：完成稳定平面的构建过程，并返回相应光照</span>
</span></span><span class="line"><span class="cl">    <span class="n">pathRadiance</span> <span class="o">=</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">stablePlanes</span><span class="p">.</span><span class="n">CompletePathTracingBuild</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">L</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#elif PATH_TRACER_MODE==PATH_TRACER_MODE_FILL_STABLE_PLANES</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 填充稳定平面模式：使用稳定平面数据完成光照计算</span>
</span></span><span class="line"><span class="cl">    <span class="n">pathRadiance</span> <span class="o">=</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">stablePlanes</span><span class="p">.</span><span class="n">CompletePathTracingFill</span><span class="p">(</span><span class="n">g_Const</span><span class="p">.</span><span class="n">ptConsts</span><span class="p">.</span><span class="n">denoisingEnabled</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="c1">// 调试相关的可视化功能 (如果启用)</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE==PATH_TRACER_MODE_BUILD_STABLE_PLANES &amp;&amp; ENABLE_DEBUG_DELTA_TREE_VIZUALISATION</span>
</span></span><span class="line"><span class="cl">    <span class="n">DeltaTreeVizExplorePixel</span><span class="p">(</span><span class="n">workingContext</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span> <span class="c1">// 调试可视化时可能直接返回</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 9. 输出最终颜色</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE!=PATH_TRACER_MODE_BUILD_STABLE_PLANES</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果不是构建稳定平面模式，则将计算得到的 pathRadiance 写入输出纹理 u_Output</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// alpha 设置为 1 对截图很重要</span>
</span></span><span class="line"><span class="cl">    <span class="n">u_Output</span><span class="p">[</span><span class="n">pixelPos</span><span class="p">]</span> <span class="o">=</span> <span class="kt">float4</span><span class="p">(</span> <span class="n">pathRadiance</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>    
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 下面是一些调试打印的示例代码，已被注释</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>主要逻辑梳理：</strong></p>
<ol>
<li>
<p><strong>获取像素坐标 (<code>DispatchRaysIndex().xy</code>)</strong>: 这是 DXR 的标准操作，用于确定当前线程处理哪个像素。</p>
</li>
<li>
<p><strong>初始化 <code>WorkingContext</code> (<code>getWorkingContext</code>)</strong>:</p>
<ul>
<li><code>getWorkingContext</code> 函数会打包该像素进行路径追踪所需的各种上下文信息，包括：
<ul>
<li><code>ptConsts</code>: 路径追踪相关的常量（如最大弹射次数、场景信息等）。</li>
<li><code>pixelPos</code>: 当前像素坐标。</li>
<li><code>debug</code>: 调试相关的上下文和资源。</li>
<li><code>stablePlanes</code>: “稳定平面” (Stable Planes) 技术的上下文。这是一种用于在复杂光照条件下（尤其是多次弹射后）提高性能和稳定性的技术，通过缓存和复用某些表面上的光照信息来实现。</li>
</ul>
</li>
<li>根据 <code>PATH_TRACER_MODE</code> (路径追踪模式，如参考模式、构建稳定平面模式、填充稳定平面模式)，可能会有不同的初始化步骤，特别是与 <code>stablePlanes</code> 相关的。</li>
</ul>
</li>
<li>
<p><strong>路径和主光线设置 (<code>PathTracer::EmptyPathInitialize</code>, <code>Bridge::computeCameraRay</code>, <code>PathTracer::SetupPathPrimaryRay</code>)</strong>:</p>
<ul>
<li><code>PathState</code> 结构体是核心，它封装了一条光路在追踪过程中的所有状态（例如当前光线起点、方向、吞吐量、已弹射次数、累积光照等）。</li>
<li><code>EmptyPathInitialize</code> 初始化一个空的 <code>PathState</code>。</li>
<li><code>computeCameraRay</code> (在 <code>PathTracerBridgeDonut.hlsli</code> 中) 根据相机模型（如透视投影）计算出对应当前 <code>pixelPos</code> 的主光线（起点和方向）。</li>
<li><code>SetupPathPrimaryRay</code> 将这条主光线的信息填充到 <code>PathState</code> 中。</li>
</ul>
</li>
<li>
<p><strong><code>PATH_TRACER_MODE_FILL_STABLE_PLANES</code> 特殊处理</strong>:</p>
<ul>
<li>如果处于这个模式，代码会调用 <code>firstHitFromBasePlane</code>。这个函数非常关键，它表明在某些模式下，<strong>主光线的第一次碰撞并不通过实际的 <code>TraceRay</code> 调用来寻找</strong>，而是直接从一个预先计算或缓存的“基础稳定平面” (base stable plane) 中加载命中信息。这通常用于利用时序或空域上的光照缓存来加速渲染。</li>
<li><code>firstHitFromBasePlane</code> 会重建光线，并根据加载的命中信息（<code>PackedHitInfo</code>）来决定是内联处理未命中情况（调用 <code>PathTracer::HandleMiss</code>）还是准备调用命中着色器。
<ul>
<li>如果使用 <code>USE_HIT_OBJECT_EXTENSION</code> (NVAPI Hit Object 扩展)，它会构造一个 <code>NvHitObject</code> 并通过 <code>NvInvokeHitObject</code> 来执行相应的 ClosestHit 着色器。</li>
<li>否则，它会通过一些技巧（重新投射一条微小偏移的光线）来确保标准的 <code>TraceRay</code> 能够命中同一个三角形并触发正确的着色器。这是一个兼容性处理，目标是简化API后移除。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>主路径追踪循环 (<code>while (path.isActive()) nextHit(...)</code>)</strong>:</p>
<ul>
<li>这是路径追踪的核心迭代部分。只要 <code>path.isActive()</code> 返回真（意味着光线没有终止，例如达到最大深度、能量过低或打到背景等），就会调用 <code>nextHit</code>。</li>
<li><code>nextHit</code> 函数负责：
<ul>
<li>根据当前 <code>PathState</code> 中的散射光线信息（通常由上一个 <code>HandleHit</code> 或 <code>HandleMiss</code> 生成）进行下一次光线投射（<code>TraceRay</code> 或 <code>TraceRayInline</code>）。</li>
<li>当光线投射完成后，会触发场景中的 <code>ClosestHit</code> (如果命中几何体) 或 <code>Miss</code> (如果未命中任何物体) 着色器。这些着色器会更新 <code>PathState</code>（例如，计算表面材质交互、生成新的散射光线、累积光照等）。</li>
</ul>
</li>
<li>我们将在后续文章中详细解析 <code>nextHit</code> 和相关的命中/未命中着色器。</li>
</ul>
</li>
<li>
<p><strong>结果处理与输出</strong>:</p>
<ul>
<li><code>SanitizeNaNs</code>: 检查并修正路径光照 <code>path.L</code> 和吞吐量 <code>path.thp</code> 中的 <code>NaN</code> (Not a Number) 或无穷大值，保证输出的健壮性。</li>
<li>根据 <code>PATH_TRACER_MODE</code> 的不同，<code>pathRadiance</code> 的最终计算方式也不同：
<ul>
<li><code>REFERENCE</code> (参考模式): 直接使用路径追踪累积的光照 <code>path.L</code>。</li>
<li><code>BUILD_STABLE_PLANES</code> (构建稳定平面模式): 调用 <code>workingContext.stablePlanes.CompletePathTracingBuild</code>，这可能涉及到将当前路径追踪的结果用于构建或更新稳定平面的数据结构。</li>
<li><code>FILL_STABLE_PLANES</code> (填充稳定平面模式): 调用 <code>workingContext.stablePlanes.CompletePathTracingFill</code>，这可能意味着主要依赖稳定平面中存储的信息来计算最终颜色，当前路径追踪的结果可能用于调制或补充。</li>
</ul>
</li>
<li>最后，如果不是在构建稳定平面模式（该模式可能不直接输出图像，而是生成数据），则将 <code>pathRadiance</code> 写入到输出纹理 <code>u_Output</code> 中。</li>
</ul>
</li>
</ol>
<p><strong>总结 <code>RayGen</code> 的核心职责</strong></p>
<p><code>RayGen</code> 着色器为每个像素精心策划了路径追踪的“第一步”。它不仅生成初始相机光线，还根据不同的运行模式（尤其是与“稳定平面”相关的模式）采取不同的初始化策略。最核心的是它驱动的 <code>while (path.isActive()) nextHit(...)</code> 循环，这个循环不断地投射光线、处理碰撞、更新路径状态，直到光路终止。</p>
<p>接下来，我们将深入探讨 <code>nextHit</code> 函数的实现，以及 <code>ClosestHit</code> 和 <code>Miss</code> 着色器是如何与 <code>PathState</code> 交互来模拟复杂的光线传播和材质表现的。</p>
<h1 id="深入-nexthit-与-firsthitfrombaseplane">
<a class="header-anchor" href="#%e6%b7%b1%e5%85%a5-nexthit-%e4%b8%8e-firsthitfrombaseplane"></a>
深入 <code>nextHit</code> 与 <code>firstHitFromBasePlane</code>
</h1><p>在上一节中，我们分析了 <code>RayGen</code> 着色器如何初始化路径追踪并发出主光线。现在，我们将目光投向光线在场景中“弹射”的核心逻辑，主要通过 <code>nextHit</code> 函数实现。此外，我们还会探讨一个特殊的函数 <code>firstHitFromBasePlane</code>，它在特定模式下用于优化首次光线命中。</p>
<h2 id="nexthit驱动光线在场景中持续弹射">
<a class="header-anchor" href="#nexthit%e9%a9%b1%e5%8a%a8%e5%85%89%e7%ba%bf%e5%9c%a8%e5%9c%ba%e6%99%af%e4%b8%ad%e6%8c%81%e7%bb%ad%e5%bc%b9%e5%b0%84"></a>
<code>nextHit</code>：驱动光线在场景中持续弹射
</h2><p><code>nextHit</code> 函数是路径追踪循环的核心，在 <code>RayGen</code> 的 <code>while (path.isActive())</code> 循环中被反复调用。每调用一次，它就负责处理光线的下一次弹射（或称“路径顶点”）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hlsl" data-lang="hlsl"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">nextHit</span><span class="p">(</span><span class="k">inout</span> <span class="n">PathState</span> <span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="n">PathTracer</span><span class="o">::</span><span class="n">WorkingContext</span> <span class="n">workingContext</span><span class="p">,</span> <span class="k">uniform</span> <span class="kt">bool</span> <span class="n">skipStablePlaneExploration</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Conditionally use Hit Object Extension (RayQuery) or standard TraceRay</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if USE_HIT_OBJECT_EXTENSION</span>
</span></span><span class="line"><span class="cl">    <span class="n">RayDesc</span> <span class="n">ray</span><span class="p">;</span> <span class="n">RayQuery</span><span class="o">&lt;</span><span class="n">RAY_FLAG_NONE</span><span class="o">&gt;</span> <span class="n">rayQuery</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">PackedHitInfo</span> <span class="n">packedHitInfo</span><span class="p">;</span> <span class="kt">uint</span> <span class="n">SERSortKey</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 准备并追踪散射光线</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Bridge::traceScatterRay 会从 PathState 中获取上一 bounces 的散射光线信息，</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化 ray 和 rayQuery，并执行 TraceRayInline。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果有命中，ray.TMax 会被更新为实际的命中距离。</span>
</span></span><span class="line"><span class="cl">    <span class="n">Bridge</span><span class="o">::</span><span class="n">traceScatterRay</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ray</span><span class="p">,</span> <span class="n">rayQuery</span><span class="p">,</span> <span class="n">packedHitInfo</span><span class="p">,</span> <span class="n">SERSortKey</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">debug</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">NvHitObject</span> <span class="n">hit</span><span class="p">;</span> <span class="c1">// NVAPI Hit Object</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">rayQuery</span><span class="p">.</span><span class="n">CommittedStatus</span><span class="p">()</span> <span class="o">!=</span> <span class="n">COMMITTED_TRIANGLE_HIT</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 2a. 未命中 (Miss)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果 RayQuery 没有命中三角形，则内联调用 HandleMiss 处理。</span>
</span></span><span class="line"><span class="cl">        <span class="n">PathTracer</span><span class="o">::</span><span class="n">HandleMiss</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="n">Origin</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="n">Direction</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="n">TMax</span><span class="p">,</span> <span class="n">workingContext</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 2b. 命中 (Hit)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 构建内置的三角形交叉属性</span>
</span></span><span class="line"><span class="cl">        <span class="n">BuiltInTriangleIntersectionAttributes</span> <span class="n">attrib</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">attrib</span><span class="p">.</span><span class="n">barycentrics</span> <span class="o">=</span> <span class="n">rayQuery</span><span class="p">.</span><span class="n">CommittedTriangleBarycentrics</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 使用 NvMakeHitWithRecordIndex 创建一个 HitObject。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 这个 HitObject 封装了命中信息，并将用于调用正确的 ClosestHit 着色器。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// RecordIndex 用于 Shader Binding Table (SBT) 索引。</span>
</span></span><span class="line"><span class="cl">        <span class="n">NvMakeHitWithRecordIndex</span><span class="p">(</span> <span class="n">rayQuery</span><span class="p">.</span><span class="n">CommittedInstanceContributionToHitGroupIndex</span><span class="p">()</span><span class="o">+</span><span class="n">rayQuery</span><span class="p">.</span><span class="n">CommittedGeometryIndex</span><span class="p">(),</span> <span class="n">SceneBVH</span><span class="p">,</span> <span class="n">rayQuery</span><span class="p">.</span><span class="n">CommittedInstanceIndex</span><span class="p">(),</span> <span class="n">rayQuery</span><span class="p">.</span><span class="n">CommittedGeometryIndex</span><span class="p">(),</span> <span class="n">rayQuery</span><span class="p">.</span><span class="n">CommittedPrimitiveIndex</span><span class="p">(),</span> <span class="mo">0</span><span class="p">,</span> <span class="n">ray</span><span class="p">,</span> <span class="n">attrib</span><span class="p">,</span> <span class="n">hit</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="kt">uint</span> <span class="n">vertexIndex</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">getVertexIndex</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">PathPayload</span> <span class="n">payload</span> <span class="o">=</span> <span class="n">PathPayload</span><span class="o">::</span><span class="n">pack</span><span class="p">(</span><span class="n">path</span><span class="p">);</span> <span class="c1">// 将 PathState 打包到 payload</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Shader Execution Reordering (SER) - 可选的着色器执行重排序优化</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if SER_USE_SORTING</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">workingContext</span><span class="p">.</span><span class="n">ptConsts</span><span class="p">.</span><span class="n">enableShaderExecutionReordering</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if SER_USE_MANUAL_SORT_KEY</span>
</span></span><span class="line"><span class="cl">            <span class="n">NvReorderThread</span><span class="p">(</span><span class="n">SERSortKey</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span> <span class="c1">// 使用手动生成的排序键</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else</span>
</span></span><span class="line"><span class="cl">            <span class="n">NvReorderThread</span><span class="p">(</span><span class="n">hit</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>      <span class="c1">// 使用基于命中属性的启发式排序键</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif // SER_USE_SORTING</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 调用 HitObject 对应的 ClosestHit 着色器</span>
</span></span><span class="line"><span class="cl">        <span class="n">NvInvokeHitObject</span><span class="p">(</span><span class="n">SceneBVH</span><span class="p">,</span> <span class="n">hit</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span> <span class="o">=</span> <span class="n">PathPayload</span><span class="o">::</span><span class="n">unpack</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="n">PACKED_HIT_INFO_ZERO</span><span class="p">);</span> <span class="c1">// 从 payload 解包更新后的 PathState</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else // Fallback to standard TraceRay if Hit Object Extension is not used</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 获取散射光线</span>
</span></span><span class="line"><span class="cl">    <span class="n">RayDesc</span> <span class="n">ray</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">getScatterRay</span><span class="p">().</span><span class="n">toRayDesc</span><span class="p">();</span> <span class="c1">// 从 PathState 获取要追踪的光线</span>
</span></span><span class="line"><span class="cl">    <span class="n">PathPayload</span> <span class="n">payload</span> <span class="o">=</span> <span class="n">PathPayload</span><span class="o">::</span><span class="n">pack</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>   <span class="c1">// 打包 PathState</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 执行标准 TraceRay</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这会调用 DXR 管线中的 ClosestHit 或 Miss 着色器</span>
</span></span><span class="line"><span class="cl">    <span class="n">TraceRay</span><span class="p">(</span> <span class="n">SceneBVH</span><span class="p">,</span> <span class="n">RAY_FLAG_NONE</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="n">ray</span><span class="p">,</span> <span class="n">payload</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 解包 PathState</span>
</span></span><span class="line"><span class="cl">    <span class="n">path</span> <span class="o">=</span> <span class="n">PathPayload</span><span class="o">::</span><span class="n">unpack</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="n">PACKED_HIT_INFO_ZERO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// --- 稳定平面探索 (Stable Plane Exploration) ---</span>
</span></span><span class="line"><span class="cl"><span class="c1">// (仅在 PATH_TRACER_MODE_BUILD_STABLE_PLANES 模式下)</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE==PATH_TRACER_MODE_BUILD_STABLE_PLANES </span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">nextPlaneToExplore</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果当前路径已经终止 (isActive() == false) 并且还有稳定平面需要探索</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">.</span><span class="n">isActive</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nextPlaneToExplore</span><span class="o">=</span><span class="n">workingContext</span><span class="p">.</span><span class="n">stablePlanes</span><span class="p">.</span><span class="n">FindNextToExplore</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">getStablePlaneIndex</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">!=-</span><span class="mi">1</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 保存当前累积的非噪声光照</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float3</span> <span class="n">prevL</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">L</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">        <span class="n">PathPayload</span> <span class="n">payloadForNewExploration</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 开始探索新的稳定平面，这会重置或初始化一个新的 PathState 到 payloadForNewExploration</span>
</span></span><span class="line"><span class="cl">        <span class="n">workingContext</span><span class="p">.</span><span class="n">stablePlanes</span><span class="p">.</span><span class="n">ExplorationStart</span><span class="p">(</span><span class="n">nextPlaneToExplore</span><span class="p">,</span> <span class="n">payloadForNewExploration</span><span class="p">.</span><span class="n">packed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span> <span class="o">=</span> <span class="n">PathPayload</span><span class="o">::</span><span class="n">unpack</span><span class="p">(</span><span class="n">payloadForNewExploration</span><span class="p">,</span> <span class="n">PACKED_HIT_INFO_ZERO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">prevL</span><span class="p">;</span> <span class="c1">// 恢复之前累积的非噪声光照，继续在其上累加</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 调试代码示例，用于可视化特定稳定平面的内容</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// #if 0 </span>
</span></span><span class="line"><span class="cl">        <span class="c1">// if (path.getStablePlaneIndex()==1)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//     workingContext.debug.DrawDebugViz( float4( DbgShowNormalSRGB(path.dir), 1 ) );</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// #endif</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong><code>nextHit</code> 的主要逻辑：</strong></p>
<ol>
<li>
<p><strong>获取并追踪光线</strong>：</p>
<ul>
<li>光线的起点和方向通常由上一次命中表面后的材质散射决定，存储在 <code>PathState</code> 中。</li>
<li><strong><code>USE_HIT_OBJECT_EXTENSION</code> 分支</strong>:
<ul>
<li><code>Bridge::traceScatterRay</code> 内部会使用 <code>RayQuery::TraceRayInline</code>。这是一种更现代、更灵活的光线追踪方式，允许在同一个着色器内完成光线投射和命中处理的逻辑。</li>
<li><code>SERSortKey</code> (Shader Execution Reordering Sort Key) 是为光线排序准备的，旨在通过将具有相似计算负载或数据访问模式的光线分组执行来提高 GPU 效率。在我的 RTX 4060 Laptop GPU 上，开启SER会大幅提高实时路径追踪的性能（从<code>~10FPS</code>提升到<code>~20FPS</code>）。</li>
</ul>
</li>
<li><strong><code>else</code> 分支 (标准 <code>TraceRay</code>)</strong>:
<ul>
<li>直接从 <code>path.getScatterRay()</code> 获取光线描述，并调用传统的 <code>TraceRay</code> DXR 指令。这将暂停当前 <code>RayGen</code> (或 <code>ClosestHit</code>) 着色器，并根据命中结果调用相应的 <code>ClosestHit</code> 或 <code>Miss</code> 着色器。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>处理命中 (Hit) 或未命中 (Miss)</strong>：</p>
<ul>
<li><strong><code>USE_HIT_OBJECT_EXTENSION</code> 分支</strong>:
<ul>
<li><strong>Miss</strong>: 如果 <code>rayQuery.CommittedStatus()</code> 不是 <code>COMMITTED_TRIANGLE_HIT</code>，则认为光线未命中任何物体（或命中了程序化几何体，但这里主要关注三角形）。<code>PathTracer::HandleMiss</code> 会被调用，它通常会处理环境光照、终止路径等。</li>
<li><strong>Hit</strong>:
<ul>
<li><code>NvMakeHitWithRecordIndex</code> 和 <code>NvHitObject</code>: 如果命中，会创建一个 <code>NvHitObject</code>。这个对象可以理解为一个包含了所有命中信息的“句柄”，可以直接用于调用正确的 <code>ClosestHit</code> 着色器（通过 <code>NvInvokeHitObject</code>），而无需通过传统的SBT查找。这提供了更大的灵活性。</li>
<li><code>NvReorderThread</code>: 在调用 <code>ClosestHit</code> 之前，可以选择性地进行线程重排序 (<code>NvReorderThread</code>) 以优化执行效率。</li>
<li><code>NvInvokeHitObject</code>: 执行与该 <code>HitObject</code> 关联的 <code>ClosestHit</code> 着色器。<code>PathState</code> 被打包到 <code>payload</code> 中传递给 <code>ClosestHit</code>，并在其执行完毕后解包回来。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>else</code> 分支 (标准 <code>TraceRay</code>)</strong>:
<ul>
<li><code>TraceRay</code> 本身会负责调用管线中绑定的 <code>ClosestHit</code> 或 <code>Miss</code> 着色器。这些着色器会直接修改传入的 <code>payload</code> (即打包后的 <code>PathState</code>)。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Payload 管理</strong>:</p>
<ul>
<li><code>PathState</code> (包含光线的所有状态) 在调用 <code>TraceRay</code> 或 <code>NvInvokeHitObject</code> 之前通过 <code>PathPayload::pack</code> 打包成 <code>PathPayload</code>。在这些调用返回后，再通过 <code>PathPayload::unpack</code> 解包回 <code>PathState</code>。这样做是为了符合 DXR 的 payload 机制。</li>
</ul>
</li>
<li>
<p><strong>稳定平面探索 (Stable Plane Exploration)</strong>:</p>
<ul>
<li>这个 <code>#if</code> 块只在 <code>PATH_TRACER_MODE_BUILD_STABLE_PLANES</code> 模式下有效。</li>
<li>当一条路径追踪完成 (<code>!path.isActive()</code>) 后，如果还有“稳定平面”需要被探索（通过 <code>workingContext.stablePlanes.FindNextToExplore</code> 检查），系统会“重新利用”当前线程。</li>
<li><code>ExplorationStart</code> 会为选定的下一个稳定平面准备一个新的初始路径状态，并加载到 <code>path</code> 变量中。这意味着当前像素的计算线程会接着去处理另一个（可能是场景中其它位置的）稳定平面的光照计算任务。这是一种任务分发和复用的机制，用于高效地构建稳定平面数据。</li>
</ul>
</li>
</ol>
<p><code>nextHit</code> 是路径追踪的心跳，每一次调用都代表光线与场景的一次交互。</p>
<h2 id="firsthitfrombaseplane从稳定平面开始的特殊首次命中">
<a class="header-anchor" href="#firsthitfrombaseplane%e4%bb%8e%e7%a8%b3%e5%ae%9a%e5%b9%b3%e9%9d%a2%e5%bc%80%e5%a7%8b%e7%9a%84%e7%89%b9%e6%ae%8a%e9%a6%96%e6%ac%a1%e5%91%bd%e4%b8%ad"></a>
<code>firstHitFromBasePlane</code>：从“稳定平面”开始的特殊首次命中
</h2><p><code>firstHitFromBasePlane</code> 函数是一个非常有趣的优化，它仅在 <code>PATH_TRACER_MODE_FILL_STABLE_PLANES</code> 模式下的 <code>RayGen</code> 函数中被调用。其核心思想是：<strong>对于主光线（相机光线）的第一次场景交叉，不进行实际的光线投射，而是直接从一个预先计算好的“基础稳定平面” (base stable plane) 加载命中信息。</strong></p>
<p>这通常用于以下场景：</p>
<ul>
<li>当渲染前一帧或附近像素时，可能已经计算并存储了某些表面的光照信息（这些表面被识别为“稳定平面”）。</li>
<li>当前帧可以直接复用这些信息，从而跳过昂贵的首次光线追踪和部分光照计算。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hlsl" data-lang="hlsl"><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE!=PATH_TRACER_MODE_REFERENCE // 这个函数在非参考模式下才可能被定义和使用</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">firstHitFromBasePlane</span><span class="p">(</span><span class="k">inout</span> <span class="n">PathState</span> <span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint</span> <span class="n">basePlaneIndex</span><span class="p">,</span> <span class="k">const</span> <span class="n">PathTracer</span><span class="o">::</span><span class="n">WorkingContext</span> <span class="n">workingContext</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 从稳定平面加载数据</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    这些数据包括：打包的命中信息(packedHitInfo)、光线方向(rayDir)、场景长度(sceneLength)即命中距离、</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    吞吐量(thp)等。这些都是之前在构建稳定平面阶段计算并存储的。</span>
</span></span><span class="line"><span class="cl">    <span class="n">PackedHitInfo</span> <span class="n">packedHitInfo</span><span class="p">;</span> <span class="kt">float3</span> <span class="n">rayDir</span><span class="p">;</span> <span class="kt">uint</span> <span class="n">vertexIndex</span><span class="p">;</span> <span class="kt">uint</span> <span class="n">SERSortKey</span><span class="p">;</span> <span class="kt">uint</span> <span class="n">stableBranchID</span><span class="p">;</span> <span class="kt">float</span> <span class="n">sceneLength</span><span class="p">;</span> <span class="kt">float3</span> <span class="n">thp</span><span class="p">;</span> <span class="kt">float3</span> <span class="n">motionVectors</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">workingContext</span><span class="p">.</span><span class="n">stablePlanes</span><span class="p">.</span><span class="n">LoadStablePlane</span><span class="p">(</span><span class="n">workingContext</span><span class="p">.</span><span class="n">pixelPos</span><span class="p">,</span> <span class="n">basePlaneIndex</span><span class="p">,</span> <span class="n">vertexIndex</span><span class="p">,</span> <span class="n">packedHitInfo</span><span class="p">,</span> <span class="n">SERSortKey</span><span class="p">,</span> <span class="n">stableBranchID</span><span class="p">,</span> <span class="n">rayDir</span><span class="p">,</span> <span class="n">sceneLength</span><span class="p">,</span> <span class="n">thp</span><span class="p">,</span> <span class="n">motionVectors</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 重建光线描述 (RayDesc)</span>
</span></span><span class="line"><span class="cl">    <span class="n">RayDesc</span> <span class="n">ray</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ray</span><span class="p">.</span><span class="n">Direction</span> <span class="o">=</span> <span class="n">rayDir</span><span class="p">;</span> <span class="c1">// 使用加载的方向</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Origin 仍然使用 path 中由 SetupPathPrimaryRay 初始化的相机位置。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 注释警告：对于非主光线的弹射，这个 origin 是不正确的，但这里是处理主光线替换。</span>
</span></span><span class="line"><span class="cl">    <span class="n">ray</span><span class="p">.</span><span class="n">Origin</span>    <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">origin</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">ray</span><span class="p">.</span><span class="n">TMin</span>      <span class="o">=</span> <span class="mo">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ray</span><span class="p">.</span><span class="n">TMax</span>      <span class="o">=</span> <span class="n">sceneLength</span><span class="p">;</span> <span class="c1">// 使用加载的命中距离作为 TMax</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 路径顶点索引调整，因为我们将直接处理这次命中</span>
</span></span><span class="line"><span class="cl">    <span class="n">path</span><span class="p">.</span><span class="n">setVertexIndex</span><span class="p">(</span><span class="n">vertexIndex</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 更新 PathState 以反映这是基于稳定平面的命中</span>
</span></span><span class="line"><span class="cl">    <span class="n">path</span><span class="p">.</span><span class="n">setFlag</span><span class="p">(</span><span class="n">PathFlags</span><span class="o">::</span><span class="n">stablePlaneOnPlane</span> <span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">path</span><span class="p">.</span><span class="n">setFlag</span><span class="p">(</span><span class="n">PathFlags</span><span class="o">::</span><span class="n">stablePlaneOnBranch</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">path</span><span class="p">.</span><span class="n">setStablePlaneIndex</span><span class="p">(</span><span class="n">basePlaneIndex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">path</span><span class="p">.</span><span class="n">stableBranchID</span> <span class="o">=</span> <span class="n">stableBranchID</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">path</span><span class="p">.</span><span class="n">thp</span> <span class="o">=</span> <span class="n">thp</span><span class="p">;</span> <span class="c1">// 设置加载的吞吐量</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE==PATH_TRACER_MODE_FILL_STABLE_PLANES</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 加载主导稳定平面索引，并设置相应标志位</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">uint</span> <span class="n">dominantSPIndex</span> <span class="o">=</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">stablePlanes</span><span class="p">.</span><span class="n">LoadDominantIndexCenter</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">path</span><span class="p">.</span><span class="n">setFlag</span><span class="p">(</span><span class="n">PathFlags</span><span class="o">::</span><span class="n">stablePlaneOnDominantBranch</span><span class="p">,</span> <span class="n">dominantSPIndex</span> <span class="o">==</span> <span class="n">basePlaneIndex</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 重置从稳定平面开始的弹射计数器和降噪器相关数据</span>
</span></span><span class="line"><span class="cl">    <span class="n">path</span><span class="p">.</span><span class="n">setCounter</span><span class="p">(</span><span class="n">PackedCounters</span><span class="o">::</span><span class="n">BouncesFromStablePlane</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">path</span><span class="p">.</span><span class="n">denoiserSampleHitTFromPlane</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">path</span><span class="p">.</span><span class="n">denoiserDiffRadianceHitDist</span> <span class="o">=</span> <span class="n">lpfloat4</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span><span class="mo">0</span><span class="p">,</span><span class="mo">0</span><span class="p">,</span><span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">path</span><span class="p">.</span><span class="n">denoiserSpecRadianceHitDist</span> <span class="o">=</span> <span class="n">lpfloat4</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span><span class="mo">0</span><span class="p">,</span><span class="mo">0</span><span class="p">,</span><span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4. 处理加载的命中信息</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IsValid</span><span class="p">(</span><span class="n">packedHitInfo</span><span class="p">))</span> <span class="c1">// IsValid 是一个辅助宏或函数，检查 packedHitInfo 是否有效</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 4a. 无效命中 (视为 Miss)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 直接内联调用 HandleMiss，使用重建的光线信息。</span>
</span></span><span class="line"><span class="cl">        <span class="n">PathTracer</span><span class="o">::</span><span class="n">HandleMiss</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="n">Origin</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="n">Direction</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="n">TMax</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 4b. 有效命中 (Hit)</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if USE_HIT_OBJECT_EXTENSION</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 使用 Hit Object 扩展</span>
</span></span><span class="line"><span class="cl">        <span class="n">NvHitObject</span> <span class="n">hit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// (IsValid(packedHitInfo) 已在上层 if 确认)</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">TriangleHit</span> <span class="n">triangleHit</span> <span class="o">=</span> <span class="n">TriangleHit</span><span class="o">::</span><span class="n">make</span><span class="p">(</span><span class="n">packedHitInfo</span><span class="p">);</span> <span class="c1">// 解包为 TriangleHit</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">uint</span> <span class="n">instanceIndex</span>    <span class="o">=</span> <span class="n">triangleHit</span><span class="p">.</span><span class="n">instanceID</span><span class="p">.</span><span class="n">getInstanceIndex</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">uint</span> <span class="n">geometryIndex</span>    <span class="o">=</span> <span class="n">triangleHit</span><span class="p">.</span><span class="n">instanceID</span><span class="p">.</span><span class="n">getGeometryIndex</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">uint</span> <span class="n">primitiveIndex</span>   <span class="o">=</span> <span class="n">triangleHit</span><span class="p">.</span><span class="n">primitiveIndex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="n">BuiltInTriangleIntersectionAttributes</span> <span class="n">attrib</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">attrib</span><span class="p">.</span><span class="n">barycentrics</span> <span class="o">=</span> <span class="n">triangleHit</span><span class="p">.</span><span class="n">barycentrics</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 创建 HitObject</span>
</span></span><span class="line"><span class="cl">        <span class="n">NvMakeHit</span><span class="p">(</span> <span class="n">SceneBVH</span><span class="p">,</span> <span class="n">instanceIndex</span><span class="p">,</span> <span class="n">geometryIndex</span><span class="p">,</span> <span class="n">primitiveIndex</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ray</span><span class="p">,</span> <span class="n">attrib</span><span class="p">,</span> <span class="n">hit</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 可选的 Shader Execution Reordering (SER)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 注释提到：首次弹射的排序通常对性能帮助不大，因为光线此时还比较相干。</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if 0 &amp;&amp; SER_USE_SORTING </span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">workingContext</span><span class="p">.</span><span class="n">ptConsts</span><span class="p">.</span><span class="n">enableShaderExecutionReordering</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="cp">#if SER_USE_MANUAL_SORT_KEY</span>
</span></span><span class="line"><span class="cl">            <span class="n">NvReorderThread</span><span class="p">(</span><span class="n">SERSortKey</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>    
</span></span><span class="line"><span class="cl"><span class="cp">#else</span>
</span></span><span class="line"><span class="cl">            <span class="n">NvReorderThread</span><span class="p">(</span><span class="n">hit</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif // SER_USE_SORTING</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">PathPayload</span> <span class="n">payload</span> <span class="o">=</span> <span class="n">PathPayload</span><span class="o">::</span><span class="n">pack</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 调用 HitObject 对应的 ClosestHit 着色器</span>
</span></span><span class="line"><span class="cl">        <span class="n">NvInvokeHitObject</span><span class="p">(</span><span class="n">SceneBVH</span><span class="p">,</span> <span class="n">hit</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span> <span class="o">=</span> <span class="n">PathPayload</span><span class="o">::</span><span class="n">unpack</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="n">PACKED_HIT_INFO_ZERO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 不使用 Hit Object 扩展时的兼容性“hack”</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 目的是重新投射一条极短的光线，以确保能正确触发 DXR 管线中的 ClosestHit 着色器。</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float3</span> <span class="n">surfaceHitPosW</span><span class="p">;</span> <span class="kt">float3</span> <span class="n">surfaceHitFaceNormW</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">        <span class="c1">// 加载表面位置和法线</span>
</span></span><span class="line"><span class="cl">        <span class="n">Bridge</span><span class="o">::</span><span class="n">loadSurfacePosNormOnly</span><span class="p">(</span><span class="n">surfaceHitPosW</span><span class="p">,</span> <span class="n">surfaceHitFaceNormW</span><span class="p">,</span> <span class="n">TriangleHit</span><span class="o">::</span><span class="n">make</span><span class="p">(</span><span class="n">packedHitInfo</span><span class="p">),</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">debug</span><span class="p">);</span>    
</span></span><span class="line"><span class="cl">        <span class="kt">bool</span> <span class="n">frontFacing</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span> <span class="o">-</span><span class="n">ray</span><span class="p">.</span><span class="n">Direction</span><span class="p">,</span> <span class="n">surfaceHitFaceNormW</span> <span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 计算一个新的光线起点，稍微偏离表面，确保能再次命中同一三角形</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float3</span> <span class="n">newOrigin</span> <span class="o">=</span> <span class="n">ComputeRayOrigin</span><span class="p">(</span><span class="n">surfaceHitPosW</span><span class="p">,</span> <span class="p">(</span><span class="n">frontFacing</span><span class="p">)</span><span class="o">?</span><span class="p">(</span><span class="n">surfaceHitFaceNormW</span><span class="p">)</span><span class="o">:</span><span class="p">(</span><span class="o">-</span><span class="n">surfaceHitFaceNormW</span><span class="p">))</span> <span class="o">-</span> <span class="n">ray</span><span class="p">.</span><span class="n">Direction</span> <span class="o">*</span> <span class="mi">8</span><span class="n">e</span><span class="o">-</span><span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 更新路径已行进的距离，因为我们“跳过”了从相机到 newOrigin 的这段距离</span>
</span></span><span class="line"><span class="cl">        <span class="n">PathTracer</span><span class="o">::</span><span class="n">UpdatePathTravelled</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="n">Origin</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="n">Direction</span><span class="p">,</span> <span class="nb">length</span><span class="p">(</span><span class="n">newOrigin</span><span class="o">-</span><span class="n">ray</span><span class="p">.</span><span class="n">Origin</span><span class="p">),</span> <span class="n">workingContext</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">ray</span><span class="p">.</span><span class="n">Origin</span> <span class="o">=</span> <span class="n">newOrigin</span><span class="p">;</span> <span class="c1">// 更新光线起点为这个微调后的位置</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ray.TMax 保持不变 (sceneLength)，因为我们知道命中点在此距离内。</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="n">PathPayload</span> <span class="n">payload</span> <span class="o">=</span> <span class="n">PathPayload</span><span class="o">::</span><span class="n">pack</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 用这条极短的光线调用 TraceRay</span>
</span></span><span class="line"><span class="cl">        <span class="n">TraceRay</span><span class="p">(</span> <span class="n">SceneBVH</span><span class="p">,</span> <span class="n">RAY_FLAG_NONE</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="n">ray</span><span class="p">,</span> <span class="n">payload</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span> <span class="o">=</span> <span class="n">PathPayload</span><span class="o">::</span><span class="n">unpack</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="n">PACKED_HIT_INFO_ZERO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif // USE_HIT_OBJECT_EXTENSION</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span></code></pre></div><p><strong><code>firstHitFromBasePlane</code> 的关键点：</strong></p>
<ol>
<li><strong>数据加载</strong>: 核心是 <code>workingContext.stablePlanes.LoadStablePlane(...)</code>。它从预计算的稳定平面数据中获取完整的首次命中信息，包括命中点、法线（间接通过<code>packedHitInfo</code>）、材质信息（通过SBT索引间接确定）、以及可能的初始吞吐量 <code>thp</code>。</li>
<li><strong>路径状态更新</strong>: 加载数据后，<code>PathState</code> 会被相应更新，设置各种与稳定平面相关的标志位和计数器。这使得后续的路径追踪逻辑能够感知到它是从一个稳定平面开始或经过一个稳定平面的。</li>
<li><strong>处理加载的命中</strong>:
<ul>
<li>如果加载的 <code>packedHitInfo</code> 无效（可能表示之前认为的稳定平面在该像素视角下实际未命中），则直接调用 <code>PathTracer::HandleMiss</code>。</li>
<li>如果有效，则根据是否使用 <code>USE_HIT_OBJECT_EXTENSION</code> 来触发相应的 <code>ClosestHit</code> 着色器：
<ul>
<li><strong>使用 Hit Object</strong>: 直接构造 <code>NvHitObject</code> 并调用 <code>NvInvokeHitObject</code>。</li>
<li><strong>不使用 Hit Object</strong>: 这里有一个精巧的“hack”。由于不能直接“注入”一个命中结果到标准的 DXR <code>TraceRay</code> 管线中，代码通过 <code>ComputeRayOrigin</code> 在已知的命中点附近（沿着法线方向稍微偏移一点）计算出一个新的光线起点 <code>newOrigin</code>。然后，从这个 <code>newOrigin</code> 发出一条非常短的、方向指向原始命中点的光线，并调用 <code>TraceRay</code>。这条光线几乎肯定会立刻命中同一个三角形，从而触发正确的 <code>ClosestHit</code> 着色器。<code>PathTracer::UpdatePathTravelled</code> 用于补偿因为修改了光线起点而“跳过”的原始光路长度。注释表明这个hack在SER API更普及时会被移除。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li><code>nextHit</code> 是通用的光线弹射驱动函数，负责获取当前路径的散射光线，执行光线追踪（通过 <code>RayQuery</code> 或 <code>TraceRay</code>），并根据结果调用相应的 <code>HandleMiss</code> 或触发 <code>ClosestHit</code> 着色器 (通过 <code>NvInvokeHitObject</code> 或 DXR 管线)。它还包含了在特定模式下探索更多稳定平面的逻辑。</li>
<li><code>firstHitFromBasePlane</code> 是一个针对 <code>PATH_TRACER_MODE_FILL_STABLE_PLANES</code> 模式的特定优化。它通过加载预计算的稳定平面数据来“伪造”主光线的首次命中，避免了实际的光线投射，从而复用历史信息并加速渲染。</li>
</ul>
<p>这两个函数共同构成了 RTXPT 中光线如何在场景中游走并与物体交互的核心机制。理解它们的运作方式，特别是它们如何根据不同的配置（如 <code>USE_HIT_OBJECT_EXTENSION</code> 和 <code>PATH_TRACER_MODE</code>）改变行为，对于深入掌握 RTXPT 的渲染流程至关重要。</p>
<h1 id="深入-closesthit-与核心光线命中处理-pathtracerhandlehit">
<a class="header-anchor" href="#%e6%b7%b1%e5%85%a5-closesthit-%e4%b8%8e%e6%a0%b8%e5%bf%83%e5%85%89%e7%ba%bf%e5%91%bd%e4%b8%ad%e5%a4%84%e7%90%86-pathtracerhandlehit"></a>
深入 ClosestHit 与核心光线命中处理 PathTracer::HandleHit
</h1><p>在前两部分，我们了解了 <code>RayGen</code> 如何启动路径追踪，以及 <code>nextHit</code> 和 <code>firstHitFromBasePlane</code> 如何管理光线的投射与初步命中。现在，当一条光线确实命中了场景中的某个物体时，DXR管线会调用相应的 <code>ClosestHit</code> (最近命中) 着色器。</p>
<h2 id="samplehlsl-中的-closesthit-着色器">
<a class="header-anchor" href="#samplehlsl-%e4%b8%ad%e7%9a%84-closesthit-%e7%9d%80%e8%89%b2%e5%99%a8"></a>
<code>Sample.hlsl</code> 中的 <code>ClosestHit</code> 着色器
</h2><p>在 <code>Sample.hlsl</code> 文件中，你会看到 <code>ClosestHit</code> 着色器是通过一个宏 <code>CLOSEST_HIT_VARIANT</code> 来定义的。这种设计非常巧妙，它允许为不同类型的表面或交互定义多个 <code>ClosestHit</code> 着色器变体，每个变体可以携带一些优化提示。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hlsl" data-lang="hlsl"><span class="line"><span class="cl"><span class="c1">// 定义 ClosestHit 着色器变体的宏</span>
</span></span><span class="line"><span class="cl"><span class="c1">// name: 着色器名称后缀</span>
</span></span><span class="line"><span class="cl"><span class="c1">// NoTextures: 是否忽略纹理采样的提示</span>
</span></span><span class="line"><span class="cl"><span class="c1">// NoTransmission: 是否忽略透射计算的提示</span>
</span></span><span class="line"><span class="cl"><span class="c1">// OnlyDeltaLobes: 是否只处理理想镜面/透射（Delta lobes）的提示</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define CLOSEST_HIT_VARIANT( name, NoTextures, NoTransmission, OnlyDeltaLobes )      \</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="n">shader</span><span class="p">(</span><span class="s">&#34;closesthit&#34;</span><span class="p">)]</span> <span class="kt">void</span> <span class="n">ClosestHit</span><span class="err">##</span><span class="n">name</span><span class="p">(</span><span class="k">inout</span> <span class="n">PathPayload</span> <span class="n">payload</span> <span class="o">:</span> <span class="n">SV_RayPayload</span><span class="p">,</span> <span class="k">in</span> <span class="n">BuiltInTriangleIntersectionAttributes</span> <span class="n">attrib</span><span class="p">)</span> <span class="cp">\</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="cp">\</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 从每个实例的附加数据中提取预计算的 SERSortKey (Shader Execution Reordering Sort Key) */</span> <span class="cp">\</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint</span> <span class="n">SERSortKey</span> <span class="o">=</span> <span class="n">t_SubInstanceData</span><span class="p">[</span><span class="n">InstanceID</span><span class="p">()</span><span class="o">+</span><span class="n">GeometryIndex</span><span class="p">()].</span><span class="n">FlagsAndSERSortKey</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">;</span> <span class="cp">\</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 调用核心的 HandleHit 函数，并传入优化提示和打包的命中信息 */</span> <span class="cp">\</span>
</span></span><span class="line"><span class="cl">    <span class="n">HandleHit</span><span class="p">(</span> <span class="n">PathTracer</span><span class="o">::</span><span class="n">OptimizationHints</span><span class="o">::</span><span class="n">make</span><span class="p">(</span> <span class="n">NoTextures</span><span class="p">,</span> <span class="n">NoTransmission</span><span class="p">,</span> <span class="n">OnlyDeltaLobes</span><span class="p">,</span> <span class="n">SERSortKey</span> <span class="p">),</span> <span class="n">TriangleHit</span><span class="o">::</span><span class="n">make</span><span class="p">(</span> <span class="n">InstanceIndex</span><span class="p">(),</span> <span class="n">GeometryIndex</span><span class="p">(),</span> <span class="n">PrimitiveIndex</span><span class="p">(),</span> <span class="n">attrib</span><span class="p">.</span><span class="n">barycentrics</span> <span class="p">).</span><span class="n">pack</span><span class="p">(),</span> <span class="n">payload</span><span class="p">);</span> <span class="cp">\</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 根据不同的优化组合生成8个 ClosestHit 着色器变体</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 例如，ClosestHit000, ClosestHit001, ..., ClosestHit111</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if 1 // 3bit 8-variant version</span>
</span></span><span class="line"><span class="cl"><span class="n">CLOSEST_HIT_VARIANT</span><span class="p">(</span> <span class="mo">000</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span> <span class="p">);</span> <span class="c1">// 无优化提示</span>
</span></span><span class="line"><span class="cl"><span class="n">CLOSEST_HIT_VARIANT</span><span class="p">(</span> <span class="mo">001</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span>  <span class="p">);</span> <span class="c1">// 只处理Delta Lobes</span>
</span></span><span class="line"><span class="cl"><span class="n">CLOSEST_HIT_VARIANT</span><span class="p">(</span> <span class="mo">010</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span>  <span class="kc">false</span> <span class="p">);</span> <span class="c1">// 忽略透射</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ... 等等</span>
</span></span><span class="line"><span class="cl"><span class="n">CLOSEST_HIT_VARIANT</span><span class="p">(</span> <span class="mi">111</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span>  <span class="kc">true</span><span class="p">,</span>  <span class="kc">true</span>  <span class="p">);</span> <span class="c1">// 忽略纹理、忽略透射、只处理Delta Lobes</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span></code></pre></div><p><strong><code>ClosestHit</code> 着色器的主要作用：</strong></p>
<ol>
<li><strong>入口点</strong>：当 <code>TraceRay</code> (或 <code>NvInvokeHitObject</code>) 确定了一个最近命中点时，DXR会根据Shader Binding Table (SBT) 中的设置，调用与该几何体关联的 <code>ClosestHit</code> 着色器。</li>
<li><strong>收集命中信息</strong>：它接收系统提供的 <code>BuiltInTriangleIntersectionAttributes</code> (内置三角形交叉属性，主要是重心坐标 <code>barycentrics</code>) 和 <code>SV_RayPayload</code> (光线载荷，即我们打包的 <code>PathState</code>)。</li>
<li><strong>准备参数</strong>:
<ul>
<li>它从 <code>t_SubInstanceData</code> 这个StructuredBuffer中获取预计算的 <code>SERSortKey</code>。这个排序键用于后续可能的着色器执行重排序（SER）优化。</li>
<li>它将 DXR 提供的命中信息（<code>InstanceIndex()</code>, <code>GeometryIndex()</code>, <code>PrimitiveIndex()</code>, <code>attrib.barycentrics</code>）打包成一个 <code>TriangleHit</code> 对象，然后再 <code>pack()</code> 成 <code>PackedHitInfo</code>。</li>
<li>它根据宏参数创建 <code>PathTracer::OptimizationHints</code> 结构体。这些提示（如 <code>NoTextures</code>, <code>NoTransmission</code>, <code>OnlyDeltaLobes</code>）可以被 <code>HandleHit</code> 函数用来跳过某些计算，从而在特定情况下提高性能（例如，一个完全不透明且没有复杂纹理的材质）。</li>
</ul>
</li>
<li><strong>调用核心逻辑</strong>: 最重要的是，所有的 <code>ClosestHit</code> 变体都会调用 <code>Sample.hlsl</code> 中的一个中介函数 <code>HandleHit(OptimizationHints, PackedHitInfo, PathPayload)</code>。</li>
</ol>
<p><code>Sample.hlsl</code> 中还有两个 <code>HandleHit</code> 的包装函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hlsl" data-lang="hlsl"><span class="line"><span class="cl"><span class="c1">// 被 ClosestHit 着色器直接调用的版本</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">HandleHit</span><span class="p">(</span><span class="k">const</span> <span class="k">uniform</span> <span class="n">PathTracer</span><span class="o">::</span><span class="n">OptimizationHints</span> <span class="n">optimizationHints</span><span class="p">,</span> <span class="k">const</span> <span class="n">PackedHitInfo</span> <span class="n">packedHitInfo</span><span class="p">,</span> <span class="k">inout</span> <span class="n">PathPayload</span> <span class="n">payload</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">PathState</span> <span class="n">path</span> <span class="o">=</span> <span class="n">PathPayload</span><span class="o">::</span><span class="n">unpack</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="n">packedHitInfo</span><span class="p">);</span> <span class="c1">// 解包 PathState，并将当前命中信息设置进去</span>
</span></span><span class="line"><span class="cl">    <span class="n">PathTracer</span><span class="o">::</span><span class="n">WorkingContext</span> <span class="n">workingContext</span> <span class="o">=</span> <span class="n">getWorkingContext</span><span class="p">(</span><span class="n">PathIDToPixel</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">id</span><span class="p">));</span> <span class="c1">// 获取工作上下文</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用另一个 HandleHitUnpacked，传入解包后的参数和 DXR 系统变量</span>
</span></span><span class="line"><span class="cl">    <span class="n">HandleHitUnpacked</span><span class="p">(</span><span class="n">optimizationHints</span><span class="p">,</span> <span class="n">packedHitInfo</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">WorldRayOrigin</span><span class="p">(),</span> <span class="n">WorldRayDirection</span><span class="p">(),</span> <span class="n">RayTCurrent</span><span class="p">(),</span> <span class="n">workingContext</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">payload</span> <span class="o">=</span> <span class="n">PathPayload</span><span class="o">::</span><span class="n">pack</span><span class="p">(</span> <span class="n">path</span> <span class="p">);</span> <span class="c1">// 将可能已更新的 PathState 重新打包回 payload</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 进一步解包，并最终调用 PathTracer 命名空间内的核心 HandleHit</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">HandleHitUnpacked</span><span class="p">(</span><span class="k">const</span> <span class="k">uniform</span> <span class="n">PathTracer</span><span class="o">::</span><span class="n">OptimizationHints</span> <span class="n">optimizationHints</span><span class="p">,</span> <span class="k">const</span> <span class="n">PackedHitInfo</span> <span class="n">packedHitInfo</span><span class="p">,</span> <span class="k">inout</span> <span class="n">PathState</span> <span class="n">path</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">worldRayOrigin</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">worldRayDirection</span><span class="p">,</span> <span class="kt">float</span> <span class="n">rayT</span><span class="p">,</span> <span class="k">const</span> <span class="n">PathTracer</span><span class="o">::</span><span class="n">WorkingContext</span> <span class="n">workingContext</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 重新设置 path 中的 origin 和 dir，因为 PathPayload 为了减少寄存器压力可能没有携带它们。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这些值从 DXR 的 WorldRayOrigin() 和 WorldRayDirection() 获取，代表了当前 TraceRay 指令的光线。</span>
</span></span><span class="line"><span class="cl">    <span class="n">path</span><span class="p">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">worldRayOrigin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">path</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="n">worldRayDirection</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">path</span><span class="p">.</span><span class="n">setHitPacked</span><span class="p">(</span> <span class="n">packedHitInfo</span> <span class="p">);</span> <span class="c1">// 再次确认命中信息</span>
</span></span><span class="line"><span class="cl">    <span class="n">PathTracer</span><span class="o">::</span><span class="n">HandleHit</span><span class="p">(</span><span class="n">optimizationHints</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">worldRayOrigin</span><span class="p">,</span> <span class="n">worldRayDirection</span><span class="p">,</span> <span class="n">rayT</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">);</span> <span class="c1">// 调用 PathTracer.hlsli 中的核心 HandleHit</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这些包装函数的主要职责是：</p>
<ul>
<li>从 <code>PathPayload</code> 中解包出 <code>PathState</code>。</li>
<li>将当前光线的 <code>PackedHitInfo</code> 设置到 <code>PathState</code> 中。</li>
<li>获取当前像素的 <code>WorkingContext</code>。</li>
<li>从DXR内置函数（如 <code>WorldRayOrigin()</code>, <code>WorldRayDirection()</code>, <code>RayTCurrent()</code>）获取当前光线的准确起点、方向和命中距离 <code>T</code>。</li>
<li>最终调用定义在 <code>PathTracer/PathTracer.hlsli</code> 中的核心函数 <code>PathTracer::HandleHit</code>。</li>
<li>在核心逻辑执行完毕后，将更新后的 <code>PathState</code> 重新打包回 <code>PathPayload</code>。</li>
</ul>
<p>现在，让我们把目光转向 <code>PathTracer/PathTracer.hlsli</code> 中那个至关重要的 <code>PathTracer::HandleHit</code> 函数。</p>
<h3 id="pathtracerhandlehit核心命中处理逻辑">
<a class="header-anchor" href="#pathtracerhandlehit%e6%a0%b8%e5%bf%83%e5%91%bd%e4%b8%ad%e5%a4%84%e7%90%86%e9%80%bb%e8%be%91"></a>
<code>PathTracer::HandleHit</code>：核心命中处理逻辑
</h3><p>这个函数是路径追踪中当光线与表面发生交互时的“大脑”。它负责加载材质、处理自发光、计算直接光照（Next Event Estimation）、进行BSDF采样以产生下一条光线，并处理路径终止等。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hlsl" data-lang="hlsl"><span class="line"><span class="cl"><span class="c1">// PathTracer/PathTracer.hlsli</span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">PathTracer</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... (其他函数) ...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 目前只支持 TriangleHit；未来需要时会添加更多类型</span>
</span></span><span class="line"><span class="cl">    <span class="k">inline</span> <span class="kt">void</span> <span class="n">HandleHit</span><span class="p">(</span><span class="k">const</span> <span class="k">uniform</span> <span class="n">OptimizationHints</span> <span class="n">optimizationHints</span><span class="p">,</span> <span class="k">inout</span> <span class="n">PathState</span> <span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float3</span> <span class="n">rayOrigin</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float3</span> <span class="n">rayDir</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">rayTCurrent</span><span class="p">,</span> <span class="k">const</span> <span class="n">WorkingContext</span> <span class="n">workingContext</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 更新路径已行进的距离和相关状态 (如光线锥)</span>
</span></span><span class="line"><span class="cl">        <span class="n">UpdatePathTravelled</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">rayOrigin</span><span class="p">,</span> <span class="n">rayDir</span><span class="p">,</span> <span class="n">rayTCurrent</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">uint2</span> <span class="n">pixelPos</span> <span class="o">=</span> <span class="n">PathIDToPixel</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 初始化当前路径顶点的随机数生成器种子</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">SampleGeneratorVertexBase</span> <span class="n">sampleGeneratorVertexBase</span> <span class="o">=</span> <span class="n">SampleGeneratorVertexBase</span><span class="o">::</span><span class="n">make</span><span class="p">(</span><span class="n">pixelPos</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">getVertexIndex</span><span class="p">(),</span> <span class="n">Bridge</span><span class="o">::</span><span class="n">getSampleIndex</span><span class="p">()</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl"><span class="cp">#if ENABLE_DEBUG_VIZUALISATION</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">bool</span> <span class="n">debugPath</span> <span class="o">=</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">debug</span><span class="p">.</span><span class="n">IsDebugPixel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">bool</span> <span class="n">debugPath</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// ----- 命中时的主要步骤概述 -----</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// - 加载顶点/材质数据</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// - 如果 path.getVertexIndex() &gt; 1 (非首次命中) 且命中自发光表面，计算 MIS 权重</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// - 累加自发光辐射亮度</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// - 使用阴影光线采样光源 (直接光照)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// - 采样散射光线或终止路径</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// (关于如何判断“首次命中”在有 Primary Surface Replacement 时的讨论注释)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 加载表面和材质数据</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">TriangleHit</span> <span class="n">triangleHit</span> <span class="o">=</span> <span class="n">TriangleHit</span><span class="o">::</span><span class="n">make</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">hitPacked</span><span class="p">);</span> <span class="c1">// 从 path 中解包命中信息</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Bridge::loadSurface 是一个非常关键的调用：</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 它会根据 triangleHit 加载所有必要的表面属性，如位置、法线、切线、UV坐标。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 同时，它会加载材质属性（反照率、粗糙度、金属度、自发光、折射率等），</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 并根据材质类型（如漫反射、镜面、玻璃等）构建一个 ActiveBSDF 对象。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// optimizationHints (来自 ClosestHit 变体) 和 path.rayCone (光线锥信息，可用于纹理LOD) 会被传入。</span>
</span></span><span class="line"><span class="cl">        <span class="n">SurfaceData</span> <span class="n">bridgedData</span> <span class="o">=</span> <span class="n">Bridge</span><span class="o">::</span><span class="n">loadSurface</span><span class="p">(</span><span class="n">optimizationHints</span><span class="p">,</span> <span class="n">triangleHit</span><span class="p">,</span> <span class="n">rayDir</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">rayCone</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">getVertexIndex</span><span class="p">(),</span> <span class="n">pixelPos</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">debug</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// (调试 RayCone 数据的示例代码)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 处理体积吸收 (Volume Absorption)</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">volumeAbsorption</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="c1">// 用于统计</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">.</span><span class="n">interiorList</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span> <span class="c1">// 如果光线当前在某个体积内部</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">const</span> <span class="kt">uint</span> <span class="n">materialID</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">interiorList</span><span class="p">.</span><span class="n">getTopMaterialID</span><span class="p">();</span> <span class="c1">// 获取最内层体积的材质ID</span>
</span></span><span class="line"><span class="cl">            <span class="k">const</span> <span class="n">HomogeneousVolumeData</span> <span class="n">hvd</span> <span class="o">=</span> <span class="n">Bridge</span><span class="o">::</span><span class="n">loadHomogeneousVolumeData</span><span class="p">(</span><span class="n">materialID</span><span class="p">);</span> <span class="c1">// 加载均匀体积数据</span>
</span></span><span class="line"><span class="cl">            <span class="k">const</span> <span class="kt">float3</span> <span class="n">transmittance</span> <span class="o">=</span> <span class="n">HomogeneousVolumeSampler</span><span class="o">::</span><span class="n">evalTransmittance</span><span class="p">(</span><span class="n">hvd</span><span class="p">,</span> <span class="n">rayTCurrent</span><span class="p">);</span> <span class="c1">// 计算这段距离的透射率</span>
</span></span><span class="line"><span class="cl">            <span class="n">volumeAbsorption</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">luminance</span><span class="p">(</span><span class="n">transmittance</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">UpdatePathThroughput</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">transmittance</span><span class="p">);</span> <span class="c1">// 根据透射率衰减路径的吞吐量 (throughput)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 4. 处理嵌套电介质 (Nested Dielectrics)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// HandleNestedDielectrics 对于正确渲染具有多个界面的透明对象（如玻璃杯中的水）至关重要。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 它会更新 path.interiorList (当光线进入/离开体积时推入/弹出材质ID)。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 它可以拒绝“假命中”：例如，由于薄壁近似或接口逻辑，某些命中应被忽略，光线应视为穿过。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 还会根据当前介质更新 bridgedData.shadingData.IoR (外部折射率)。</span>
</span></span><span class="line"><span class="cl">        <span class="kt">bool</span> <span class="n">rejectedFalseHit</span> <span class="o">=</span> <span class="o">!</span><span class="n">HandleNestedDielectrics</span><span class="p">(</span><span class="n">bridgedData</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// (Delta Tree 可视化调试相关的代码块，如果命中被拒绝则返回)</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE==PATH_TRACER_MODE_BUILD_STABLE_PLANES &amp;&amp; ENABLE_DEBUG_DELTA_TREE_VIZUALISATION</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">hasFlag</span><span class="p">(</span><span class="n">PathFlags</span><span class="o">::</span><span class="n">deltaTreeExplorer</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">DeltaTreeVizHandleHit</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">rayOrigin</span><span class="p">,</span> <span class="n">rayDir</span><span class="p">,</span> <span class="n">rayTCurrent</span><span class="p">,</span> <span class="n">bridgedData</span><span class="p">,</span> <span class="n">rejectedFalseHit</span><span class="p">,</span> <span class="n">HasFinishedSurfaceBounces</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="n">volumeAbsorption</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">rejectedFalseHit</span><span class="p">)</span> <span class="c1">// 如果是假命中，则忽略此次交互，光线实质上继续传播</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取着色数据和BSDF的快捷方式</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">ShadingData</span> <span class="n">shadingData</span> <span class="o">=</span> <span class="n">bridgedData</span><span class="p">.</span><span class="n">shadingData</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">ActiveBSDF</span> <span class="n">bsdf</span> <span class="o">=</span> <span class="n">bridgedData</span><span class="p">.</span><span class="n">bsdf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// (更多调试可视化代码：切线空间、光线锥足迹等)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取BSDF属性，如漫反射/镜面反射率、自发光等</span>
</span></span><span class="line"><span class="cl">        <span class="n">BSDFProperties</span> <span class="n">bsdfProperties</span> <span class="o">=</span> <span class="n">bsdf</span><span class="p">.</span><span class="n">getProperties</span><span class="p">(</span><span class="n">shadingData</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 5. 累加自发光表面辐射 (Emissive Surface Handling)</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float3</span> <span class="n">surfaceEmission</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 解包之前NEE步骤中存储的MIS信息 (如果上一 bounces 做了NEE且恰好采样到了当前这个自发光面)</span>
</span></span><span class="line"><span class="cl">        <span class="n">NEEBSDFMISInfo</span> <span class="n">misInfo</span> <span class="o">=</span> <span class="n">NEEBSDFMISInfo</span><span class="o">::</span><span class="n">Unpack16bit</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">packedMISInfo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 检查是否应该忽略此三角形的自发光，以及它是否有自发光</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">misInfo</span><span class="p">.</span><span class="n">SkipEmissiveBRDF</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">path</span><span class="p">.</span><span class="n">wasScatterTransmission</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">bsdfProperties</span><span class="p">.</span><span class="n">emission</span><span class="o">&gt;</span><span class="mo">0</span><span class="p">))</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">float</span> <span class="n">misWeight</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span> <span class="c1">// 多重重要性采样 (MIS) 权重</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果启用了光源采样 (NEE) 并且当前是通过BSDF采样命中的 (path.bsdfScatterPdf != 0)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span> <span class="n">misInfo</span><span class="p">.</span><span class="n">LightSamplingEnabled</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="p">.</span><span class="n">bsdfScatterPdf</span> <span class="o">!=</span> <span class="mo">0</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 创建光源采样器</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// this is the NEE light sampler configured same as it was at previous vertex (previous vertex&#39;s &#34;next event estimation&#34; matches this light &#34;event&#34;)</span>
</span></span><span class="line"><span class="cl">                <span class="n">LightSampler</span> <span class="n">lightSampler</span> <span class="o">=</span> <span class="n">Bridge</span><span class="o">::</span><span class="n">CreateLightSampler</span><span class="p">(</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">pixelPos</span><span class="p">,</span> <span class="n">misInfo</span><span class="p">.</span><span class="n">LightSamplingIsIndirect</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">debug</span><span class="p">.</span><span class="n">IsDebugPixel</span><span class="p">()</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 计算 BSDF 路径命中自发光体的 MIS 权重</span>
</span></span><span class="line"><span class="cl">                <span class="n">misWeight</span> <span class="o">=</span> <span class="n">lightSampler</span><span class="p">.</span><span class="n">ComputeBSDFMISForEmissiveTriangle</span><span class="p">(</span><span class="n">bridgedData</span><span class="p">.</span><span class="n">neeLightIndex</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">bsdfScatterPdf</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">origin</span><span class="p">,</span> <span class="n">shadingData</span><span class="p">.</span><span class="n">posW</span><span class="p">,</span> <span class="n">misInfo</span><span class="p">.</span><span class="n">NarrowNEESamples</span><span class="p">,</span> <span class="n">misInfo</span><span class="p">.</span><span class="n">TotalSamples</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                
</span></span><span class="line"><span class="cl">                <span class="c1">// (向光源采样器提供反馈，用于自适应光源采样)</span>
</span></span><span class="line"><span class="cl">                <span class="kt">float</span> <span class="n">simpleRandom</span> <span class="o">=</span> <span class="n">Hash32ToFloat</span><span class="p">(</span> <span class="n">Hash32Combine</span><span class="p">(</span> <span class="n">Hash32Combine</span><span class="p">(</span><span class="n">Hash32</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">getVertexIndex</span><span class="p">()</span> <span class="o">+</span> <span class="mh">0x0367C2C7</span><span class="p">),</span> <span class="n">path</span><span class="p">.</span><span class="n">id</span><span class="p">),</span> <span class="n">Bridge</span><span class="o">::</span><span class="n">getSampleIndex</span><span class="p">()</span> <span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">lightSampler</span><span class="p">.</span><span class="n">InsertFeedbackFromBSDF</span><span class="p">(</span><span class="n">bridgedData</span><span class="p">.</span><span class="n">neeLightIndex</span><span class="p">,</span> <span class="n">average</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">thp</span><span class="o">*</span><span class="n">bsdfProperties</span><span class="p">.</span><span class="n">emission</span><span class="p">),</span> <span class="n">misWeight</span><span class="p">,</span> <span class="n">simpleRandom</span> <span class="p">);</span> <span class="c1">// 注意这里用 bsdfProperties.emission 更合理</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">surfaceEmission</span> <span class="o">=</span> <span class="n">bsdfProperties</span><span class="p">.</span><span class="n">emission</span> <span class="o">*</span> <span class="n">misWeight</span><span class="p">;</span> <span class="c1">// 应用MIS权重</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">ptConsts</span><span class="p">.</span><span class="n">fireflyFilterThreshold</span> <span class="o">!=</span> <span class="mo">0</span> <span class="p">)</span> <span class="c1">// 飞火过滤</span>
</span></span><span class="line"><span class="cl">                <span class="n">surfaceEmission</span> <span class="o">=</span> <span class="n">FireflyFilter</span><span class="p">(</span><span class="n">surfaceEmission</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">ptConsts</span><span class="p">.</span><span class="n">fireflyFilterThreshold</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">fireflyFilterK</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">surfaceEmission</span> <span class="o">*=</span> <span class="n">Bridge</span><span class="o">::</span><span class="n">getNoisyRadianceAttenuation</span><span class="p">();</span> <span class="c1">// 应用噪声衰减 (可能用于多重采样抗锯齿)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果不是填充稳定平面模式，将自发光贡献累加到路径光照 L</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE != PATH_TRACER_MODE_FILL_STABLE_PLANES </span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">surfaceEmission</span><span class="o">&gt;</span><span class="mo">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="n">path</span><span class="p">.</span><span class="n">L</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span> <span class="mf">0.</span><span class="n">xxx</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">thp</span><span class="o">*</span><span class="n">surfaceEmission</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 6. 路径终止判断 (第一部分：最大深度和稳定平面逻辑)</span>
</span></span><span class="line"><span class="cl">        <span class="kt">bool</span> <span class="n">pathStopping</span> <span class="o">=</span> <span class="n">HasFinishedSurfaceBounces</span><span class="p">(</span><span class="n">path</span><span class="p">);</span> <span class="c1">// 检查是否达到最大表面弹射次数</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果不是参考模式，调用稳定平面命中处理逻辑</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE!=PATH_TRACER_MODE_REFERENCE</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// StablePlanesHandleHit 是稳定平面优化方案的关键部分。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 它可以更新稳定平面数据，将当前光照贡献给稳定平面，</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 甚至根据稳定平面的状态终止或重定向当前路径。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// pathStopping 可能会被此函数更新。</span>
</span></span><span class="line"><span class="cl">        <span class="n">StablePlanesHandleHit</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">rayOrigin</span><span class="p">,</span> <span class="n">rayDir</span><span class="p">,</span> <span class="n">rayTCurrent</span><span class="p">,</span> <span class="n">optimizationHints</span><span class="p">.</span><span class="n">SERSortKey</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">,</span> <span class="n">bridgedData</span><span class="p">,</span> <span class="n">volumeAbsorption</span><span class="p">,</span> <span class="n">surfaceEmission</span><span class="p">,</span> <span class="n">pathStopping</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 7. 路径终止判断 (第二部分：俄罗斯轮盘赌 Russian Roulette)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果不是构建稳定平面模式（该模式下路径终止可能已由 StablePlanesHandleHit 处理）</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE!=PATH_TRACER_MODE_BUILD_STABLE_PLANES </span>
</span></span><span class="line"><span class="cl">        <span class="c1">// HandleRussianRoulette 根据路径吞吐量进行俄罗斯轮盘赌。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果随机数超过吞吐量，路径终止；否则，吞吐量被放大以补偿。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 注意：此函数会更新 path.thp!</span>
</span></span><span class="line"><span class="cl">        <span class="n">pathStopping</span> <span class="o">|=</span> <span class="n">HandleRussianRoulette</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">sampleGeneratorVertexBase</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">pathStopping</span><span class="p">)</span> <span class="c1">// 如果决定终止路径</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span><span class="p">.</span><span class="n">terminate</span><span class="p">();</span> <span class="c1">// 设置路径为非激活状态</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>           <span class="c1">// 结束 HandleHit</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果是构建稳定平面模式，在此处提前返回。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 注释说明：在该模式下，自发光已被处理，路径也由 StablePlanesHandleHit 更新或终止，</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 因此跳过后续的BSDF采样和NEE。</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE==PATH_TRACER_MODE_BUILD_STABLE_PLANES    </span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif    </span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 保存散射前的路径状态，主要用于NEE计算时的吞吐量</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">PathState</span> <span class="n">preScatterPath</span> <span class="o">=</span> <span class="n">path</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 8. 生成散射光线 (BSDF Sampling)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// GenerateScatterRay 是材质交互的核心：</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// - 根据表面材质的 BSDF (双向散射分布函数) 采样一个新的散射方向。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// - 计算该采样方向的概率密度函数 (PDF)。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// - 更新路径的起点 (path.origin = shadingData.posW) 和方向 (path.dir = newDir)。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// - 更新路径吞吐量 (path.thp *= bsdf_color * cos_theta / pdf)。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// - 返回 ScatterResult，包含是否有效及PDF。</span>
</span></span><span class="line"><span class="cl">        <span class="n">ScatterResult</span> <span class="n">scatterResult</span> <span class="o">=</span> <span class="n">GenerateScatterRay</span><span class="p">(</span><span class="n">shadingData</span><span class="p">,</span> <span class="n">bsdf</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">sampleGeneratorVertexBase</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 9. 执行下一事件估计 (Next Event Estimation - NEE) / 直接光照采样</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if defined(RTXPT_COMPILE_WITH_NEE) &amp;&amp; RTXPT_COMPILE_WITH_NEE!=0</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// HandleNEE 执行直接光照采样：</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// - 选择一个或多个光源。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// - 从当前命中点向选定的光源投射阴影光线 (shadow ray)。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// - 如果阴影光线未被遮挡，计算直接光照贡献。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// - 计算并返回 MIS 相关信息 (neeResult.BSDFMISInfo)，这个信息会被打包到 path.packedMISInfo，</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//   用于下一 bounces 如果恰好通过BSDF采样命中了这个被NEE采样到的光源时，进行MIS加权。</span>
</span></span><span class="line"><span class="cl">        <span class="n">NEEResult</span> <span class="n">neeResult</span> <span class="o">=</span> <span class="n">HandleNEE</span><span class="p">(</span><span class="n">optimizationHints</span><span class="p">,</span> <span class="n">preScatterPath</span><span class="p">,</span> <span class="n">shadingData</span><span class="p">,</span> <span class="n">bsdf</span><span class="p">,</span> <span class="n">sampleGeneratorVertexBase</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">);</span>    
</span></span><span class="line"><span class="cl"><span class="cp">#else</span>
</span></span><span class="line"><span class="cl">        <span class="n">NEEResult</span> <span class="n">neeResult</span> <span class="o">=</span> <span class="n">NEEResult</span><span class="o">::</span><span class="n">empty</span><span class="p">();</span> <span class="c1">// 如果未编译NEE，则结果为空</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 存储NEE的MIS信息和BSDF散射的PDF，供下一次弹射使用</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">packedMISInfo</span>  <span class="o">=</span> <span class="p">(</span><span class="n">lpuint</span><span class="p">)</span><span class="n">neeResult</span><span class="p">.</span><span class="n">BSDFMISInfo</span><span class="p">.</span><span class="n">Pack16bit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">bsdfScatterPdf</span> <span class="o">=</span> <span class="p">(</span><span class="n">lpfloat</span><span class="p">)</span><span class="n">scatterResult</span><span class="p">.</span><span class="n">Pdf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">lpfloat3</span> <span class="n">neeDiffuseRadiance</span><span class="p">,</span> <span class="n">neeSpecularRadiance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">neeResult</span><span class="p">.</span><span class="n">GetRadiances</span><span class="p">(</span><span class="n">neeDiffuseRadiance</span><span class="p">,</span> <span class="n">neeSpecularRadiance</span><span class="p">);</span> <span class="c1">// 获取NEE计算出的漫反射和镜面反射光照</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span> <span class="nb">any</span><span class="p">(</span> <span class="p">(</span><span class="n">neeDiffuseRadiance</span><span class="o">+</span><span class="n">neeSpecularRadiance</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mo">0</span> <span class="p">)</span> <span class="p">)</span> <span class="c1">// 如果NEE有贡献</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">neeDiffuseRadiance</span> <span class="o">*=</span> <span class="p">(</span><span class="n">lpfloat3</span><span class="p">)</span><span class="n">Bridge</span><span class="o">::</span><span class="n">getNoisyRadianceAttenuation</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">neeSpecularRadiance</span> <span class="o">*=</span> <span class="p">(</span><span class="n">lpfloat3</span><span class="p">)</span><span class="n">Bridge</span><span class="o">::</span><span class="n">getNoisyRadianceAttenuation</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE==PATH_TRACER_MODE_FILL_STABLE_PLANES // 填充稳定平面模式</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// StablePlanesHandleNEE 可能会将NEE的结果与稳定平面数据结合或存储。</span>
</span></span><span class="line"><span class="cl">            <span class="n">StablePlanesHandleNEE</span><span class="p">(</span><span class="n">preScatterPath</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">neeDiffuseRadiance</span><span class="p">,</span> <span class="n">neeSpecularRadiance</span><span class="p">,</span> <span class="n">neeResult</span><span class="p">.</span><span class="n">RadianceSourceDistance</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 其他模式下，直接将NEE贡献累加到路径光照 L</span>
</span></span><span class="line"><span class="cl">            <span class="kt">float3</span> <span class="n">neeContribution</span> <span class="o">=</span> <span class="n">neeDiffuseRadiance</span> <span class="o">+</span> <span class="n">neeSpecularRadiance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span><span class="p">.</span><span class="n">L</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.</span><span class="n">xxx</span><span class="p">,</span> <span class="n">preScatterPath</span><span class="p">.</span><span class="n">thp</span> <span class="o">*</span> <span class="n">neeContribution</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 10. 最终路径终止判断 (基于BSDF散射结果)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scatterResult</span><span class="p">.</span><span class="n">Valid</span><span class="p">)</span> <span class="c1">// 如果BSDF散射无效 (例如，被纯黑材质吸收)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span><span class="p">.</span><span class="n">terminate</span><span class="p">();</span> <span class="c1">// 终止路径</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="c1">// end of PathTracer::HandleHit</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// end of namespace PathTracer</span>
</span></span></code></pre></div><p><strong><code>PathTracer::HandleHit</code> 逻辑步骤详解：</strong></p>
<ol>
<li><strong>路径更新 (<code>UpdatePathTravelled</code>)</strong>: 根据当前射线段的长度 <code>rayTCurrent</code> 更新路径总长度、光线锥（Ray Cone）等状态。光线锥用于纹理LOD等。</li>
<li><strong>加载表面数据 (<code>Bridge::loadSurface</code>)</strong>: 这是至关重要的一步。它负责从内存中提取与命中三角形相关的几何信息（位置、法线、UV等）和完整的材质信息（颜色、粗糙度、金属度、折射率、自发光强度等）。并根据这些信息构建一个 <code>ActiveBSDF</code> 对象，该对象封装了当前表面的光散射行为。<code>OptimizationHints</code> 在这里可能被用来决定加载哪些数据或材质的复杂度。</li>
<li><strong>体积吸收</strong>: 如果光线在介质中传播（<code>path.interiorList</code> 非空），则根据介质的吸收系数和传播距离 <code>rayTCurrent</code> 来衰减路径的吞吐量 <code>path.thp</code>。</li>
<li><strong>嵌套电介质处理 (<code>HandleNestedDielectrics</code>)</strong>: 处理光线进出透明材质（如玻璃）的复杂情况，正确管理光线在不同介质间的内外状态，并可能因“假命中”而使光线继续传播。</li>
<li><strong>自发光处理</strong>:
<ul>
<li>如果命中的表面是自发光的 (<code>bsdfProperties.emission &gt; 0</code>)，则计算其对路径总光照 <code>path.L</code> 的贡献。</li>
<li><strong>MIS (Multiple Importance Sampling)</strong>: 如果启用了NEE（下一事件估计），并且这条BSDF采样路径恰好命中了光源，那么就需要进行MIS加权，以平衡BSDF采样和NEE采样光源的贡献，避免重复计算或权重不当。<code>misInfo</code> (从 <code>path.packedMISInfo</code> 解包) 包含了<strong>上一个路径顶点</strong>进行NEE采样时的信息，用于此处的MIS计算。</li>
</ul>
</li>
<li><strong>路径终止 - 最大深度/稳定平面 (<code>HasFinishedSurfaceBounces</code>, <code>StablePlanesHandleHit</code>)</strong>:
<ul>
<li>检查是否达到预设的最大弹射次数。</li>
<li><code>StablePlanesHandleHit</code>: 在非参考模式下，此函数会介入，根据稳定平面的逻辑来处理当前命中。它可能会更新稳定平面数据，将当前的光照贡献（自发光、NEE等）存储到稳定平面，或者根据稳定平面的状态决定是否终止当前路径。</li>
</ul>
</li>
<li><strong>路径终止 - 俄罗斯轮盘赌 (<code>HandleRussianRoulette</code>)</strong>: 当路径的吞吐量 <code>path.thp</code> 降低到一定程度时，为了避免浪费计算资源在贡献很小的路径上，会使用俄罗斯轮盘赌。以 <code>path.thp</code> 为概率继续追踪，如果继续，则将 <code>path.thp</code> 除以该概率（放大贡献）；否则终止路径。</li>
<li><strong>BSDF 采样 (<code>GenerateScatterRay</code>)</strong>: 如果路径未终止，则根据当前命中表面的材质BSDF（双向散射分布函数）来采样一个新的散射方向，并计算相应的颜色衰减和概率密度函数(PDF)。结果（新方向、新吞吐量、PDF）会更新到 <code>path</code> 中，为下一次 <code>nextHit</code> 做准备。</li>
<li><strong>下一事件估计 (NEE - <code>HandleNEE</code>)</strong>: 为了更有效地采样直接光照，NEE会尝试从当前命中点向场景中的光源直接投射“阴影光线”。
<ul>
<li>如果阴影光线未被遮挡，则将光源的直接贡献（考虑距离衰减、BSDF在该方向的值、MIS权重等）累加到 <code>path.L</code>。</li>
<li>NEE的结果，特别是其用于MIS的PDF信息，会打包到 <code>path.packedMISInfo</code> 中，供下一 bounces 使用（如第5步所述）。</li>
</ul>
</li>
<li><strong>最终终止</strong>: 如果BSDF采样失败或表明光线被吸收 (<code>!scatterResult.Valid</code>)，则终止路径。</li>
</ol>
<p><code>PathTracer::HandleHit</code> 是整个路径追踪算法的心脏。它精确地模拟了光线与物体表面交互的复杂物理过程，包括材质加载、自发光、体积效应、直接光照采样、间接光照的BSDF散射以及各种终止条件和优化策略（如MIS、俄罗斯轮盘赌、稳定平面）。</p>
<p>至此，我们已经覆盖了从光线生成到命中处理的核心流程。</p>
<h1 id="下一事件估计-nee-详解--handlenee-与光源采样">
<a class="header-anchor" href="#%e4%b8%8b%e4%b8%80%e4%ba%8b%e4%bb%b6%e4%bc%b0%e8%ae%a1-nee-%e8%af%a6%e8%a7%a3--handlenee-%e4%b8%8e%e5%85%89%e6%ba%90%e9%87%87%e6%a0%b7"></a>
下一事件估计 (NEE) 详解 —— HandleNEE 与光源采样
</h1><p>在上一部分，我们了解了 <code>PathTracer::HandleHit</code> 如何处理光线与表面的交互，包括加载材质、自发光、BSDF采样等。其中一个关键步骤就是通过 <code>HandleNEE</code> 进行下一事件估计，即直接对光源进行采样。</p>
<h2 id="handleneenee-的主入口与决策点">
<a class="header-anchor" href="#handleneenee-%e7%9a%84%e4%b8%bb%e5%85%a5%e5%8f%a3%e4%b8%8e%e5%86%b3%e7%ad%96%e7%82%b9"></a>
<code>HandleNEE</code>：NEE 的主入口与决策点
</h2><p><code>HandleNEE</code> 函数是执行直接光照采样的入口。它首先判断是否应该执行NEE，然后可能会调用更核心的采样逻辑。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hlsl" data-lang="hlsl"><span class="line"><span class="cl"><span class="c1">// PathTracer/PathTracerNEE.hlsli</span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">PathTracer</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... (其他函数) ...</span>
</span></span><span class="line"><span class="cl">    <span class="k">inline</span> <span class="n">NEEResult</span> <span class="n">HandleNEE</span><span class="p">(</span><span class="k">const</span> <span class="k">uniform</span> <span class="n">OptimizationHints</span> <span class="n">optimizationHints</span><span class="p">,</span> <span class="k">const</span> <span class="n">PathState</span> <span class="n">preScatterPath</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="k">const</span> <span class="n">ShadingData</span> <span class="n">shadingData</span><span class="p">,</span> <span class="k">const</span> <span class="n">ActiveBSDF</span> <span class="n">bsdf</span><span class="p">,</span> <span class="k">const</span> <span class="n">SampleGeneratorVertexBase</span> <span class="n">sgBase</span><span class="p">,</span> <span class="k">const</span> <span class="n">WorkingContext</span> <span class="n">workingContext</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 判断 BSDF 是否有非 Delta 分布 (例如，漫反射或光泽反射/折射)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Delta 分布 (理想镜面/折射) 通常由 BSDF 采样完美处理，不需要 NEE。</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">uint</span> <span class="n">lobes</span> <span class="o">=</span> <span class="n">bsdf</span><span class="p">.</span><span class="n">getLobes</span><span class="p">(</span><span class="n">shadingData</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">bool</span> <span class="n">hasNonDeltaLobes</span> <span class="o">=</span> <span class="p">((</span><span class="n">lobes</span> <span class="o">&amp;</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="n">LobeType</span><span class="o">::</span><span class="n">NonDelta</span><span class="p">)</span> <span class="o">!=</span> <span class="mo">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">optimizationHints</span><span class="p">.</span><span class="n">OnlyDeltaLobes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// (一些性能相关的注释和标志位)</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">bool</span> <span class="n">onDominantBranch</span> <span class="o">=</span> <span class="n">preScatterPath</span><span class="p">.</span><span class="n">hasFlag</span><span class="p">(</span><span class="n">PathFlags</span><span class="o">::</span><span class="n">stablePlaneOnDominantBranch</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">bool</span> <span class="n">onStablePlane</span> <span class="o">=</span> <span class="n">preScatterPath</span><span class="p">.</span><span class="n">hasFlag</span><span class="p">(</span><span class="n">PathFlags</span><span class="o">::</span><span class="n">stablePlaneOnPlane</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 决定是否应用 NEE</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 条件：全局启用 NEE、优化提示未要求只处理 Delta Lobes、且 BSDF 确实有非 Delta 分布</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">bool</span> <span class="n">applyNEE</span> <span class="o">=</span> <span class="p">(</span><span class="n">workingContext</span><span class="p">.</span><span class="n">ptConsts</span><span class="p">.</span><span class="n">NEEEnabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">optimizationHints</span><span class="p">.</span><span class="n">OnlyDeltaLobes</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">hasNonDeltaLobes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">NEEResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">NEEResult</span><span class="o">::</span><span class="n">empty</span><span class="p">();</span> <span class="c1">// 初始化 NEE 结果为空</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">applyNEE</span><span class="p">)</span> <span class="c1">// 如果不满足 NEE 条件，直接返回空结果</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 检查是否应由 ReSTIR DI (Reservoir-based Spatiotemporal Importance Resampling for Direct Illumination) 处理直接光照</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ReSTIR DI 是一种更高级的直接光照采样技术，如果启用并适用，可能会取代传统的 NEE。</span>
</span></span><span class="line"><span class="cl">    <span class="err">#</span><span class="k">if</span> <span class="n">PATH_TRACER_MODE</span><span class="o">==</span><span class="n">PATH_TRACER_MODE_FILL_STABLE_PLANES</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 在填充稳定平面模式下，如果启用了 ReSTIR DI，并且当前BSDF有非Delta分量，</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 且位于主导稳定平面上，则应用ReSTIR DI。</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">bool</span> <span class="n">applyReSTIRDI</span> <span class="o">=</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">ptConsts</span><span class="p">.</span><span class="n">useReSTIRDI</span> <span class="o">&amp;&amp;</span> <span class="n">hasNonDeltaLobes</span> <span class="o">&amp;&amp;</span> <span class="n">onDominantBranch</span> <span class="o">&amp;&amp;</span> <span class="n">onStablePlane</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="err">#</span><span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">bool</span> <span class="n">applyReSTIRDI</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="err">#</span><span class="n">endif</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果 ReSTIR DI 负责光照，则跳过此处的 NEE。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 当前 RTXDI 主要处理反射；对于首次弹射的透射，由于复杂性，仍不尝试使用NEE，</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 也考虑到未来 ReSTIR DI 可能支持透射。</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">applyReSTIRDI</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 设置标志位，告知自发光处理部分不要重复计算（因为ReSTIR DI已处理）</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span><span class="p">.</span><span class="n">BSDFMISInfo</span><span class="p">.</span><span class="n">SkipEmissiveBRDF</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">result</span><span class="p">;</span> <span class="c1">// 返回，不执行后续的NEE</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 4. 调用核心的多重采样NEE处理函数</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// (onDominantBranch &amp;&amp; onStablePlane) ? workingContext.ptConsts.NEEBoostSamplingOnDominantPlane : 0</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 这个三元操作符为在“主导稳定平面”上的点增加了NEE的采样数量 (sampleCountBoost)</span>
</span></span><span class="line"><span class="cl">        <span class="n">HandleNEE_MultipleSamples</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">preScatterPath</span><span class="p">,</span> <span class="n">shadingData</span><span class="p">,</span> <span class="n">bsdf</span><span class="p">,</span> <span class="n">sgBase</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">,</span> <span class="p">(</span><span class="n">onDominantBranch</span><span class="o">&amp;&amp;</span><span class="n">onStablePlane</span><span class="p">)</span><span class="o">?</span><span class="p">(</span><span class="n">workingContext</span><span class="p">.</span><span class="n">ptConsts</span><span class="p">.</span><span class="n">NEEBoostSamplingOnDominantPlane</span><span class="p">)</span><span class="o">:</span><span class="p">(</span><span class="mo">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 5. 调试选项：抑制在主表面上的 NEE</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果路径在主导稳定平面上，并且ptConsts中设置了suppressPrimaryNEE，则清零NEE贡献。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 这主要用于调试或效果对比，保持MIS信息有效但光照贡献为0。</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">bool</span> <span class="n">suppressNEE</span> <span class="o">=</span> <span class="n">preScatterPath</span><span class="p">.</span><span class="n">hasFlag</span><span class="p">(</span><span class="n">PathFlags</span><span class="o">::</span><span class="n">stablePlaneOnDominantBranch</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">preScatterPath</span><span class="p">.</span><span class="n">hasFlag</span><span class="p">(</span><span class="n">PathFlags</span><span class="o">::</span><span class="n">stablePlaneOnPlane</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">ptConsts</span><span class="p">.</span><span class="n">suppressPrimaryNEE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">suppressNEE</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">            <span class="n">result</span><span class="p">.</span><span class="n">SetRadiances</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span><span class="mo">0</span><span class="p">);</span> <span class="c1">// 清零漫反射和镜面反射光照贡献</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">result</span><span class="p">;</span> <span class="c1">// 返回包含直接光照贡献和MIS信息的 NEEResult</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong><code>HandleNEE</code> 的逻辑流程：</strong></p>
<ol>
<li><strong>适用性判断</strong>：首先检查当前BSDF是否适合进行NEE。理想的delta分布（如完美镜面）由BSDF采样就能高效处理，NEE通常用于漫反射和光泽反射/折射表面。</li>
<li><strong>全局开关与优化提示</strong>：<code>workingContext.ptConsts.NEEEnabled</code> 控制全局是否启用NEE，<code>optimizationHints.OnlyDeltaLobes</code> 允许特定材质跳过NEE。</li>
<li><strong>ReSTIR DI 优先</strong>：如果启用了更高级的直接光照技术ReSTIR DI，并且当前情况适用（例如，在 <code>PATH_TRACER_MODE_FILL_STABLE_PLANES</code> 模式下处理稳定平面上的非Delta表面），则优先使用ReSTIR DI，并跳过此处的传统NEE。<code>result.BSDFMISInfo.SkipEmissiveBRDF = true;</code> 是一个重要的标志，它告诉后续的自发光处理逻辑，如果BSDF路径命中了自发光体，不需要进行MIS加权，因为ReSTIR DI已经处理了这部分贡献。</li>
<li><strong>调用多重采样</strong>：如果需要执行NEE，则调用 <code>HandleNEE_MultipleSamples</code>。这里可以传入一个 <code>sampleCountBoost</code> 参数，用于在特定条件下（如在“主导稳定平面”上）增加NEE的采样数量，以期获得更好的直接光照效果。</li>
<li><strong>调试抑制</strong>：提供了一个选项 <code>suppressPrimaryNEE</code>，可以在调试时关闭在某些主表面上的NEE贡献，方便分析和比较。</li>
</ol>
<h2 id="handlenee_multiplesamples管理多个光源样本">
<a class="header-anchor" href="#handlenee_multiplesamples%e7%ae%a1%e7%90%86%e5%a4%9a%e4%b8%aa%e5%85%89%e6%ba%90%e6%a0%b7%e6%9c%ac"></a>
<code>HandleNEE_MultipleSamples</code>：管理多个光源样本
</h2><p>该函数负责循环采样多个光源（或同一光源上的多个点），并将它们的贡献累加起来。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hlsl" data-lang="hlsl"><span class="line"><span class="cl"><span class="c1">// PathTracer/PathTracerNEE.hlsli</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;inoutResult&#39; 参数期望已被初始化为 &#39;NEEResult::empty()&#39;</span>
</span></span><span class="line"><span class="cl"><span class="k">inline</span> <span class="kt">void</span> <span class="n">HandleNEE_MultipleSamples</span><span class="p">(</span><span class="k">inout</span> <span class="n">NEEResult</span> <span class="n">inoutResult</span><span class="p">,</span> <span class="k">const</span> <span class="n">PathState</span> <span class="n">preScatterPath</span><span class="p">,</span> <span class="k">const</span> <span class="n">ShadingData</span> <span class="n">shadingData</span><span class="p">,</span> <span class="k">const</span> <span class="n">ActiveBSDF</span> <span class="n">bsdf</span><span class="p">,</span>    
</span></span><span class="line"><span class="cl">                                      <span class="k">const</span> <span class="n">SampleGeneratorVertexBase</span> <span class="n">sgBase</span><span class="p">,</span> <span class="k">const</span> <span class="n">WorkingContext</span> <span class="n">workingContext</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sampleCountBoost</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 创建光源采样器 (LightSampler)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Bridge::CreateLightSampler 根据当前像素位置、光线锥展角与场景长度之比（可能影响采样策略）等创建光源采样器。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 光源采样器负责选择光源并生成光源上的采样点。</span>
</span></span><span class="line"><span class="cl">    <span class="n">LightSampler</span> <span class="n">lightSampler</span> <span class="o">=</span> <span class="n">Bridge</span><span class="o">::</span><span class="n">CreateLightSampler</span><span class="p">(</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">pixelPos</span><span class="p">,</span> <span class="n">preScatterPath</span><span class="p">.</span><span class="n">rayCone</span><span class="p">.</span><span class="n">getWidth</span><span class="p">()</span> <span class="o">/</span> <span class="n">preScatterPath</span><span class="p">.</span><span class="n">sceneLength</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">debug</span><span class="p">.</span><span class="n">IsDebugPixel</span><span class="p">()</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 确定总采样数</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// sampleCountBoost 来自 HandleNEE，可能在主导稳定平面上增加采样。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// workingContext.ptConsts.NEEFullSamples 是基础采样数。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果光源采样器为空 (场景中无光源)，则总采样数为0。</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">uint</span> <span class="n">totalSamples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">RTXPT_LIGHTING_NEEAT_MAX_TOTAL_SAMPLE_COUNT</span><span class="p">,</span> <span class="p">(</span><span class="o">!</span><span class="n">lightSampler</span><span class="p">.</span><span class="n">IsEmpty</span><span class="p">())</span> <span class="o">?</span> <span class="p">(</span><span class="n">sampleCountBoost</span> <span class="o">+</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">ptConsts</span><span class="p">.</span><span class="n">NEEFullSamples</span><span class="p">)</span>     <span class="o">:</span> <span class="p">(</span><span class="mo">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">totalSamples</span> <span class="o">==</span> <span class="mo">0</span><span class="p">)</span> <span class="c1">// 如果没有样本可采，直接返回</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">useLowDiscrepancyGen</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// 是否使用低差异序列生成器 (如 Halton, Sobol)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 初始化多个随机数生成器，用于NEE的不同阶段</span>
</span></span><span class="line"><span class="cl">    <span class="n">SampleGenerator</span> <span class="n">sampleGenerator</span>           <span class="o">=</span> <span class="n">SampleGenerator</span><span class="o">::</span><span class="n">make</span><span class="p">(</span> <span class="n">sgBase</span><span class="p">,</span> <span class="n">SampleGeneratorEffectSeed</span><span class="o">::</span><span class="n">NextEventEstimation</span> <span class="p">);</span> <span class="c1">// 通用随机数</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// NEECandidateSamples 可能用于从多个候选光源中选择一个</span>
</span></span><span class="line"><span class="cl">    <span class="n">SampleGenerator</span> <span class="n">sampleGeneratorLightSampler</span> <span class="o">=</span> <span class="n">SampleGenerator</span><span class="o">::</span><span class="n">make</span><span class="p">(</span> <span class="n">sgBase</span><span class="p">,</span> <span class="n">SampleGeneratorEffectSeed</span><span class="o">::</span><span class="n">NextEventEstimationLightSampler</span><span class="p">,</span> <span class="n">useLowDiscrepancyGen</span><span class="p">,</span> <span class="n">totalSamples</span> <span class="o">*</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">ptConsts</span><span class="p">.</span><span class="n">NEECandidateSamples</span> <span class="p">);</span> <span class="c1">// 光源采样专用</span>
</span></span><span class="line"><span class="cl">    <span class="n">SampleGenerator</span> <span class="n">sampleGeneratorFeedback</span> <span class="o">=</span> <span class="n">SampleGenerator</span><span class="o">::</span><span class="n">make</span><span class="p">(</span> <span class="n">sgBase</span><span class="p">,</span> <span class="n">SampleGeneratorEffectSeed</span><span class="o">::</span><span class="n">NextEventEstimationFeedback</span> <span class="p">);</span> <span class="c1">// 反馈机制专用</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 初始化光源反馈机制 (用于 NEE-AT: Next Event Estimation with Adaptive Training)</span>
</span></span><span class="line"><span class="cl">    <span class="n">LightFeedbackReservoir</span> <span class="n">feedbackReservoir</span><span class="p">;</span> <span class="c1">// 存储光源反馈信息的Reservoir</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">useFeedback</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// 是否启用反馈</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE!=PATH_TRACER_MODE_BUILD_STABLE_PLANES // 构建稳定平面模式下通常不使用时序反馈</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">lightSampler</span><span class="p">.</span><span class="n">IsTemporalFeedbackRequired</span><span class="p">()</span> <span class="p">)</span> <span class="c1">// 如果光源采样器需要时序反馈</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">feedbackReservoir</span> <span class="o">=</span> <span class="n">lightSampler</span><span class="p">.</span><span class="n">LoadFeedback</span><span class="p">();</span> <span class="c1">// 加载上一帧或之前存储的反馈信息</span>
</span></span><span class="line"><span class="cl">        <span class="n">useFeedback</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算“窄域”NEE样本数，可能指针对特定区域或更重要光源的采样</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">uint</span> <span class="n">narrowNEESamples</span>      <span class="o">=</span> <span class="n">lightSampler</span><span class="p">.</span><span class="n">ComputeNarrowSampleCount</span><span class="p">(</span><span class="n">totalSamples</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4. 设置传递给下一 bounces 的 BSDFMISInfo</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这些信息用于在BSDF路径恰好命中光源时进行正确的MIS加权。</span>
</span></span><span class="line"><span class="cl">    <span class="n">inoutResult</span><span class="p">.</span><span class="n">BSDFMISInfo</span><span class="p">.</span><span class="n">LightSamplingEnabled</span>    <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>       <span class="c1">// 标记已执行光源采样</span>
</span></span><span class="line"><span class="cl">    <span class="n">inoutResult</span><span class="p">.</span><span class="n">BSDFMISInfo</span><span class="p">.</span><span class="n">LightSamplingIsIndirect</span> <span class="o">=</span> <span class="n">lightSampler</span><span class="p">.</span><span class="n">IsIndirect</span><span class="p">;</span> <span class="c1">// 标记是否为间接光路径上的NEE</span>
</span></span><span class="line"><span class="cl">    <span class="n">inoutResult</span><span class="p">.</span><span class="n">BSDFMISInfo</span><span class="p">.</span><span class="n">NarrowNEESamples</span>        <span class="o">=</span> <span class="n">narrowNEESamples</span><span class="p">;</span> <span class="c1">// “窄域”样本数</span>
</span></span><span class="line"><span class="cl">    <span class="n">inoutResult</span><span class="p">.</span><span class="n">BSDFMISInfo</span><span class="p">.</span><span class="n">TotalSamples</span>            <span class="o">=</span> <span class="n">totalSamples</span><span class="p">;</span>     <span class="c1">// 总样本数</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化累加器</span>
</span></span><span class="line"><span class="cl">    <span class="n">inoutResult</span><span class="p">.</span><span class="n">RadianceSourceDistance</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="c1">// 用于降噪器的加权平均光源距离</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">luminanceSum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>               <span class="c1">// 用于加权平均的亮度总和</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">narrowNEESamplesRemaining</span> <span class="o">=</span> <span class="n">narrowNEESamples</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 5. 主采样循环：采集 totalSamples 个光源样本</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">sampleIndex</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="n">sampleIndex</span> <span class="o">&lt;</span> <span class="n">totalSamples</span><span class="p">;</span> <span class="n">sampleIndex</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">bool</span> <span class="n">sampleIsNarrow</span> <span class="o">=</span> <span class="n">narrowNEESamplesRemaining</span> <span class="o">&gt;</span> <span class="mo">0</span><span class="p">;</span> <span class="c1">// 判断当前是否为“窄域”样本</span>
</span></span><span class="line"><span class="cl">        <span class="n">narrowNEESamplesRemaining</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 5a. 生成一个光源样本 (PathLightSample)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// GenerateLightSample (具体实现未在此代码段中) 会调用 lightSampler 来：</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//  - 选择一个光源。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//  - 在该光源上选择一个点。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//  - 返回包含光源辐射亮度(Li)、到光源方向、距离、采样PDF等信息的 PathLightSample 结构。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// workingContext.ptConsts.NEECandidateSamples 可能用于从多个候选光源中进行选择。</span>
</span></span><span class="line"><span class="cl">        <span class="n">PathLightSample</span> <span class="n">lightSample</span> <span class="o">=</span> <span class="n">GenerateLightSample</span><span class="p">(</span><span class="n">workingContext</span><span class="p">,</span> <span class="n">shadingData</span><span class="p">,</span> <span class="n">bsdf</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">ptConsts</span><span class="p">.</span><span class="n">NEECandidateSamples</span><span class="p">,</span> <span class="n">sampleGeneratorLightSampler</span><span class="p">,</span> <span class="n">sampleGenerator</span><span class="p">,</span> <span class="n">lightSampler</span><span class="p">,</span> <span class="n">sampleIsNarrow</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 5b. 处理这个光源样本</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ProcessLightSample 会投射阴影光线，如果可见，则计算BSDF、MIS权重并累加贡献。</span>
</span></span><span class="line"><span class="cl">        <span class="n">ProcessLightSample</span><span class="p">(</span><span class="n">inoutResult</span><span class="p">,</span> <span class="n">luminanceSum</span><span class="p">,</span> <span class="n">lightSample</span><span class="p">,</span> <span class="n">sampleIsNarrow</span><span class="p">,</span> <span class="n">narrowNEESamples</span><span class="p">,</span> <span class="n">totalSamples</span><span class="p">,</span> <span class="n">shadingData</span><span class="p">,</span> <span class="n">bsdf</span><span class="p">,</span> <span class="n">preScatterPath</span><span class="p">,</span> <span class="n">lightSampler</span><span class="p">,</span> <span class="n">useFeedback</span><span class="p">,</span> <span class="n">feedbackReservoir</span><span class="p">,</span> <span class="n">sampleGeneratorFeedback</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 6. 存储反馈信息 (如果启用)</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE!=PATH_TRACER_MODE_BUILD_STABLE_PLANES</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">useFeedback</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">lightSampler</span><span class="p">.</span><span class="n">StoreFeedback</span><span class="p">(</span> <span class="n">feedbackReservoir</span><span class="p">,</span> <span class="kc">true</span> <span class="p">);</span> <span class="c1">// 将更新后的反馈水塘存储起来</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 7. 计算最终的加权平均光源距离</span>
</span></span><span class="line"><span class="cl">    <span class="n">FinalizeLightSample</span><span class="p">(</span><span class="n">inoutResult</span><span class="p">,</span> <span class="n">luminanceSum</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong><code>HandleNEE_MultipleSamples</code> 的核心步骤：</strong></p>
<ol>
<li><strong>光源采样器 (<code>LightSampler</code>)</strong>: 初始化一个光源采样器，它封装了选择光源和采样点于其上的逻辑。这可能是简单的均匀采样，也可能是基于重要性或自适应反馈的复杂采样。</li>
<li><strong>随机数生成器</strong>: 为不同的采样需求（光源选择、反馈等）准备独立的随机数流，有助于结果的稳定性和可复现性。</li>
<li><strong>反馈机制 (NEE-AT)</strong>: <code>LightFeedbackReservoir</code> 和相关逻辑用于实现自适应光源采样。通过收集哪些光源对成像贡献更大，并在后续采样中倾向于这些光源，从而提高采样效率。反馈数据通常具有时序性，即利用前一帧的信息。</li>
<li><strong>MIS信息设置</strong>: 在 <code>NEEResult</code> 中预先设置好用于BSDF路径的MIS信息，如总样本数、是否为间接光等。</li>
<li><strong>采样循环</strong>:
<ul>
<li><strong><code>GenerateLightSample</code></strong>: 这是未在代码片段中显示的辅助函数，但其作用是调用<code>lightSampler</code>来产生一个<code>PathLightSample</code>。这个样本包含了光源的辐射亮度 <code>Li</code>、从着色点到光源上采样点的方向和距离，以及选择该光源和该点的组合PDF。<code>sampleIsNarrow</code>标志可能指示采样器使用不同的策略（例如，更集中地采样已知的重要光源）。</li>
<li><strong><code>ProcessLightSample</code></strong>: 对每个生成的光源样本进行处理，这是下一步要详细分析的函数。</li>
</ul>
</li>
<li><strong>存储反馈</strong>: 如果启用了自适应反馈，将更新后的<code>feedbackReservoir</code>存储起来，供后续帧或像素使用。</li>
<li><strong>最终化</strong>: <code>FinalizeLightSample</code> 对累积的一些量（如加权光源距离）进行归一化。</li>
</ol>
<h2 id="processlightsample处理单个光源样本">
<a class="header-anchor" href="#processlightsample%e5%a4%84%e7%90%86%e5%8d%95%e4%b8%aa%e5%85%89%e6%ba%90%e6%a0%b7%e6%9c%ac"></a>
<code>ProcessLightSample</code>：处理单个光源样本
</h2><p>此函数负责获取一个光源样本，投射阴影光线，如果光源可见，则计算其对当前着色点的贡献，并应用BSDF和MIS权重。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hlsl" data-lang="hlsl"><span class="line"><span class="cl"><span class="c1">// PathTracer/PathTracerNEE.hlsli</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 该函数投射光线，如果光源可见，则正确累积辐射亮度，包括进行加权和。</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">ProcessLightSample</span><span class="p">(</span><span class="k">inout</span> <span class="n">NEEResult</span> <span class="n">accum</span><span class="p">,</span> <span class="k">inout</span> <span class="kt">float</span> <span class="n">luminanceSum</span><span class="p">,</span> <span class="n">PathLightSample</span> <span class="n">lightSample</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sampleIsNarrow</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">narrowNEESamples</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">totalSamples</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="k">const</span> <span class="n">ShadingData</span> <span class="n">shadingData</span><span class="p">,</span> <span class="k">const</span> <span class="n">ActiveBSDF</span> <span class="n">bsdf</span><span class="p">,</span> <span class="k">const</span> <span class="n">PathState</span> <span class="n">preScatterPath</span><span class="p">,</span> <span class="n">LightSampler</span> <span class="n">lightSampler</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="k">const</span> <span class="kt">bool</span> <span class="n">useFeedback</span><span class="p">,</span> <span class="k">inout</span> <span class="n">LightFeedbackReservoir</span> <span class="n">feedbackReservoir</span><span class="p">,</span> <span class="k">inout</span> <span class="n">SampleGenerator</span> <span class="n">sampleGeneratorFeedback</span><span class="p">,</span> <span class="k">const</span> <span class="n">WorkingContext</span> <span class="n">workingContext</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lightSample</span><span class="p">.</span><span class="n">Valid</span><span class="p">())</span> <span class="c1">// 如果光源样本无效，则跳过</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 计算阴影光线 (Visibility Ray)</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">RayDesc</span> <span class="n">ray</span> <span class="o">=</span> <span class="n">lightSample</span><span class="p">.</span><span class="n">ComputeVisibilityRay</span><span class="p">(</span><span class="n">shadingData</span><span class="p">).</span><span class="n">toRayDesc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 追踪阴影光线以判断可见性</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Bridge::traceVisibilityRay 会投射这条光线，并返回光源是否可见。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// preScatterPath.rayCone 和 preScatterPath.getVertexIndex() 可能用于优化。</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">visible</span> <span class="o">=</span> <span class="n">Bridge</span><span class="o">::</span><span class="n">traceVisibilityRay</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="n">preScatterPath</span><span class="p">.</span><span class="n">rayCone</span><span class="p">,</span> <span class="n">preScatterPath</span><span class="p">.</span><span class="n">getVertexIndex</span><span class="p">(),</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">debug</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// (调试代码：画出阴影光线，颜色表示是否可见)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">visible</span><span class="p">)</span> <span class="c1">// 只有当光源可见时，才计算其贡献</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 计算掠射角衰减 (Grazing Angle Fadeout)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ComputeLowGrazingAngleFalloff 用于在光线与表面法线夹角过大（掠射角）时减少贡献，</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 以避免法线贴图等造成的边缘高光或锯齿。</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">fadeOut</span> <span class="o">=</span> <span class="p">(</span><span class="n">shadingData</span><span class="p">.</span><span class="n">shadowNoLFadeout</span><span class="o">&gt;</span><span class="mo">0</span><span class="p">)</span><span class="o">?</span><span class="p">(</span><span class="n">ComputeLowGrazingAngleFalloff</span><span class="p">(</span> <span class="n">ray</span><span class="p">.</span><span class="n">Direction</span><span class="p">,</span> <span class="n">shadingData</span><span class="p">.</span><span class="n">vertexN</span><span class="p">,</span> <span class="n">shadingData</span><span class="p">.</span><span class="n">shadowNoLFadeout</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">shadingData</span><span class="p">.</span><span class="n">shadowNoLFadeout</span> <span class="p">))</span><span class="o">:</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 4. 计算多重重要性采样 (MIS) 权重</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// scatterPdfForDir: 计算使用BSDF采样得到当前光线方向(lightSample.Direction)的PDF。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 这是与NEE进行MIS加权的“另一个采样策略”的PDF。</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">scatterPdfForDir</span> <span class="o">=</span> <span class="n">bsdf</span><span class="p">.</span><span class="n">evalPdf</span><span class="p">(</span><span class="n">shadingData</span><span class="p">,</span> <span class="n">lightSample</span><span class="p">.</span><span class="n">Direction</span><span class="p">,</span> <span class="n">kUseBSDFSampling</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// lightSampler.ComputeInternalMIS 使用NEE采样PDF和BSDF采样PDF来计算MIS权重 (通常是1 / (pdf_nee + pdf_bsdf) * pdf_nee 或 Balance Heuristic)。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// sampleIsNarrow, narrowNEESamples, totalSamples 可能影响MIS权重的计算方式，</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 例如，针对不同采样策略（窄域/全局）使用不同的PDF组合。</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">misWeight</span> <span class="o">=</span> <span class="n">lightSampler</span><span class="p">.</span><span class="n">ComputeInternalMIS</span><span class="p">(</span><span class="n">shadingData</span><span class="p">.</span><span class="n">posW</span><span class="p">,</span> <span class="n">lightSample</span><span class="p">,</span> <span class="n">sampleIsNarrow</span><span class="p">,</span> <span class="n">narrowNEESamples</span><span class="p">,</span> <span class="n">totalSamples</span><span class="p">,</span> <span class="n">scatterPdfForDir</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">fadeOut</span> <span class="o">*=</span> <span class="n">misWeight</span><span class="p">;</span> <span class="c1">// 将MIS权重乘入衰减因子</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 5. 计算BSDF在该方向的吞吐量 (BRDF * cos_theta)</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float3</span> <span class="n">bsdfThpDiff</span><span class="p">,</span> <span class="n">bsdfThpSpec</span><span class="p">;</span> <span class="c1">// 漫反射和镜面反射的BSDF吞吐量</span>
</span></span><span class="line"><span class="cl">        <span class="n">bsdf</span><span class="p">.</span><span class="n">eval</span><span class="p">(</span><span class="n">shadingData</span><span class="p">,</span> <span class="n">lightSample</span><span class="p">.</span><span class="n">Direction</span><span class="p">,</span> <span class="n">bsdfThpDiff</span><span class="p">,</span> <span class="n">bsdfThpSpec</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 6. Firefly Filter - 可选</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 对于贡献过大且概率较低的样本（可能导致噪点/飞火），进行过滤。</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if 1 </span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">ptConsts</span><span class="p">.</span><span class="n">fireflyFilterThreshold</span> <span class="o">!=</span> <span class="mo">0</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">const</span> <span class="kt">float</span> <span class="n">pdf</span> <span class="o">=</span> <span class="n">lightSample</span><span class="p">.</span><span class="n">SelectionPdf</span> <span class="o">*</span> <span class="n">lightSample</span><span class="p">.</span><span class="n">SolidAnglePdf</span><span class="p">;</span> <span class="c1">// NEE采样总PDF</span>
</span></span><span class="line"><span class="cl">            <span class="kt">float</span> <span class="n">neeFireflyFilterK</span> <span class="o">=</span> <span class="n">ComputeNewScatterFireflyFilterK</span><span class="p">(</span><span class="n">preScatterPath</span><span class="p">.</span><span class="n">fireflyFilterK</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span> <span class="c1">// 计算过滤参数K</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// FireflyFilterShort 根据阈值和K值对潜在的飞火进行衰减</span>
</span></span><span class="line"><span class="cl">            <span class="n">fadeOut</span> <span class="o">*=</span> <span class="n">FireflyFilterShort</span><span class="p">(</span><span class="n">average</span><span class="p">(</span><span class="n">lightSample</span><span class="p">.</span><span class="n">Li</span><span class="o">*</span><span class="p">(</span><span class="n">bsdfThpDiff</span><span class="o">+</span><span class="n">bsdfThpSpec</span><span class="p">))</span><span class="o">*</span><span class="n">misWeight</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">ptConsts</span><span class="p">.</span><span class="n">fireflyFilterThreshold</span><span class="p">,</span> <span class="n">neeFireflyFilterK</span><span class="p">);</span> <span class="c1">// 注意这里 misWeight 已乘入 fadeOut，避免重复</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 7. 将衰减因子应用到光源的辐射亮度 Li 上</span>
</span></span><span class="line"><span class="cl">        <span class="n">lightSample</span><span class="p">.</span><span class="n">Li</span> <span class="o">*=</span> <span class="n">fadeOut</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 8. 计算最终的漫反射和镜面反射贡献</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float3</span> <span class="n">diffRadiance</span> <span class="o">=</span> <span class="n">bsdfThpDiff</span> <span class="o">*</span> <span class="n">lightSample</span><span class="p">.</span><span class="n">Li</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float3</span> <span class="n">specRadiance</span> <span class="o">=</span> <span class="n">bsdfThpSpec</span> <span class="o">*</span> <span class="n">lightSample</span><span class="p">.</span><span class="n">Li</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">float3</span> <span class="n">combinedContribution</span> <span class="o">=</span> <span class="n">diffRadiance</span> <span class="o">+</span> <span class="n">specRadiance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">combinedContributionAvg</span> <span class="o">=</span> <span class="n">average</span><span class="p">(</span><span class="n">combinedContribution</span><span class="p">);</span> <span class="c1">// 平均贡献亮度</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 9. 累加光照贡献到 NEEResult</span>
</span></span><span class="line"><span class="cl">        <span class="n">lpfloat3</span> <span class="n">neeDiffuseRadiance</span><span class="p">,</span> <span class="n">neeSpecularRadiance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">accum</span><span class="p">.</span><span class="n">GetRadiances</span><span class="p">(</span><span class="n">neeDiffuseRadiance</span><span class="p">,</span> <span class="n">neeSpecularRadiance</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">neeDiffuseRadiance</span> <span class="o">=</span> <span class="n">lpfloat3</span><span class="p">(</span> <span class="nb">min</span><span class="p">(</span><span class="n">neeDiffuseRadiance</span> <span class="o">+</span> <span class="n">diffRadiance</span><span class="p">,</span> <span class="n">HLF_MAX</span><span class="p">.</span><span class="n">xxx</span> <span class="p">)</span> <span class="p">);</span> <span class="c1">// 使用低精度浮点累加</span>
</span></span><span class="line"><span class="cl">        <span class="n">neeSpecularRadiance</span> <span class="o">=</span> <span class="n">lpfloat3</span><span class="p">(</span> <span class="nb">min</span><span class="p">(</span><span class="n">neeSpecularRadiance</span> <span class="o">+</span> <span class="n">specRadiance</span><span class="p">,</span> <span class="n">HLF_MAX</span><span class="p">.</span><span class="n">xxx</span> <span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">accum</span><span class="p">.</span><span class="n">SetRadiances</span><span class="p">(</span><span class="n">neeDiffuseRadiance</span><span class="p">,</span> <span class="n">neeSpecularRadiance</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 10. 累加加权光源距离 (用于降噪器)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// RadianceSourceDistance 是一个按光照贡献加权的平均距离</span>
</span></span><span class="line"><span class="cl">        <span class="n">accum</span><span class="p">.</span><span class="n">RadianceSourceDistance</span> <span class="o">=</span> <span class="n">lpfloat</span><span class="p">(</span> <span class="nb">min</span><span class="p">(</span> <span class="n">accum</span><span class="p">.</span><span class="n">RadianceSourceDistance</span> <span class="o">+</span> <span class="n">lightSample</span><span class="p">.</span><span class="n">Distance</span> <span class="o">*</span> <span class="n">combinedContributionAvg</span><span class="p">,</span> <span class="n">HLF_MAX</span> <span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">luminanceSum</span> <span class="o">+=</span> <span class="n">combinedContributionAvg</span><span class="p">;</span> <span class="c1">// 累加总贡献亮度，用于后续归一化</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 11. 光源采样反馈 (NEE-AT)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span> <span class="n">useFeedback</span> <span class="o">&amp;&amp;</span> <span class="n">lightSample</span><span class="p">.</span><span class="n">LightIndex</span> <span class="o">!=</span> <span class="mh">0xFFFFFFFF</span> <span class="p">)</span> <span class="c1">// 如果启用反馈且光源索引有效</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 计算反馈权重：考虑路径吞吐量和当前样本的贡献</span>
</span></span><span class="line"><span class="cl">            <span class="kt">float</span> <span class="n">feedbackWeight</span> <span class="o">=</span> <span class="n">average</span><span class="p">(</span><span class="n">preScatterPath</span><span class="p">.</span><span class="n">thp</span><span class="p">)</span> <span class="o">*</span> <span class="n">combinedContributionAvg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// (注释掉的代码：根据光源被全局采样器采样的PDF来调整反馈权重，但效果不确定，默认禁用)</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// feedbackWeight /= sqrt(lightSampler.SampleGlobalPDF(lightSample.LightIndex));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 将反馈信息（光源索引、权重、随机数）插入到反馈水塘中</span>
</span></span><span class="line"><span class="cl">            <span class="n">lightSampler</span><span class="p">.</span><span class="n">InsertFeedbackFromNEE</span><span class="p">(</span><span class="n">feedbackReservoir</span><span class="p">,</span> <span class="n">lightSample</span><span class="p">.</span><span class="n">LightIndex</span><span class="p">,</span> <span class="n">feedbackWeight</span><span class="p">,</span> <span class="n">sampleNext1D</span><span class="p">(</span><span class="n">sampleGeneratorFeedback</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong><code>ProcessLightSample</code> 的核心功能：</strong></p>
<ol>
<li><strong>可见性测试</strong>: 构造并追踪一条从当前着色点到光源采样点的阴影光线 (<code>Bridge::traceVisibilityRay</code>)。</li>
<li><strong>掠射角衰减</strong>: 对接近掠射角度的光线进行衰减，以减少视觉瑕疵。</li>
<li><strong>MIS权重计算</strong>: 这是NEE的核心之一。为了正确地结合NEE和BSDF采样，需要计算MIS权重。<code>bsdf.evalPdf</code> 计算了如果通过BSDF采样得到当前光线方向的PDF，然后 <code>lightSampler.ComputeInternalMIS</code> 结合NEE本身的采样PDF（封装在 <code>lightSample</code> 中）和这个BSDF PDF来计算MIS权重（通常使用Balance Heuristic或Power Heuristic）。</li>
<li><strong>BSDF求值</strong>: <code>bsdf.eval</code> 计算当前表面材质在光源方向上的BSDF值（区分漫反射和镜面反射部分），并乘以cosine项。</li>
<li><strong>飞火过滤</strong>: 对可能产生高亮噪点（飞火）的样本进行额外的衰减。</li>
<li><strong>贡献累加</strong>: 将经过MIS加权、BSDF调制和各种衰减后的光源辐射亮度 <code>lightSample.Li</code> 分别乘以漫反射和镜面反射BSDF吞吐量，得到最终的光照贡献，并累加到 <code>NEEResult accum</code> 中。</li>
<li><strong>加权距离</strong>: 计算一个按光照贡献加权的平均光源距离，这个信息可能被后续的降噪器使用。</li>
<li><strong>反馈 (NEE-AT)</strong>: 如果启用了自适应反馈，将当前光源样本的贡献信息（光源索引、贡献大小等）通过 <code>lightSampler.InsertFeedbackFromNEE</code> 记录到 <code>feedbackReservoir</code> 中。这使得 <code>LightSampler</code> 能够“学习”哪些光源在特定情况下更重要。</li>
</ol>
<h2 id="finalizelightsample最终处理">
<a class="header-anchor" href="#finalizelightsample%e6%9c%80%e7%bb%88%e5%a4%84%e7%90%86"></a>
<code>FinalizeLightSample</code>：最终处理
</h2><p>这是一个非常简短的函数，用于在所有光源样本处理完毕后进行归一化。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hlsl" data-lang="hlsl"><span class="line"><span class="cl"><span class="c1">// PathTracer/PathTracerNEE.hlsli</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">FinalizeLightSample</span><span class="p">(</span> <span class="k">inout</span> <span class="n">NEEResult</span> <span class="n">accum</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">luminanceSum</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将累积的加权光源距离除以总贡献亮度，得到最终的平均光源距离。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// luminanceSum + 1e-30 是为了防止除以零。</span>
</span></span><span class="line"><span class="cl">    <span class="n">accum</span><span class="p">.</span><span class="n">RadianceSourceDistance</span> <span class="o">=</span> <span class="n">lpfloat</span><span class="p">(</span> <span class="nb">min</span><span class="p">(</span> <span class="n">accum</span><span class="p">.</span><span class="n">RadianceSourceDistance</span> <span class="o">/</span> <span class="p">(</span><span class="n">luminanceSum</span> <span class="o">+</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">30</span><span class="p">),</span> <span class="n">HLF_MAX</span> <span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>它将累积的（贡献亮度 * 距离）之和除以总贡献亮度，得到一个加权平均的光源距离。</p>
<p><strong>总结</strong></p>
<p>RTXPT中的NEE实现是一个相当完善的系统：</p>
<ul>
<li>它支持对多个光源样本进行采样 (<code>HandleNEE_MultipleSamples</code>)。</li>
<li>通过 <code>LightSampler</code> 抽象了光源选择和采样点生成的逻辑，允许实现不同的采样策略。</li>
<li>正确地实现了多重重要性采样 (MIS)，以结合NEE和BSDF采样。</li>
<li>包含了如掠射角衰减和飞火过滤等用于提高渲染质量的技巧。</li>
<li>集成了一套自适应光源采样反馈机制 (NEE-AT)，通过 <code>LightFeedbackReservoir</code> 在时序上学习光源的重要性，以优化采样效率。</li>
<li>为降噪器准备了加权平均光源距离等辅助信息。</li>
</ul>
<p>理解这套NEE的实现，对于掌握现代路径追踪器如何高效处理直接光照至关重要。</p>
<h1 id="多重重要性采样-mis-权重详解">
<a class="header-anchor" href="#%e5%a4%9a%e9%87%8d%e9%87%8d%e8%a6%81%e6%80%a7%e9%87%87%e6%a0%b7-mis-%e6%9d%83%e9%87%8d%e8%af%a6%e8%a7%a3"></a>
多重重要性采样 (MIS) 权重详解
</h1><p>在之前的讨论中，我们看到 Next Event Estimation (NEE) 和 BSDF 采样是路径追踪中产生光线路径的两种主要方式。当一个NEE样本（直接采样光源）或者一个BSDF样本（材质表面散射）最终“殊途同归”（例如，NEE采样了某个光源，而BSDF采样也恰好散射到了同一个光源），MIS就变得至关重要，以避免重复计算光照贡献或产生过高方差。</p>
<p>这些函数的核心是使用 <code>EvalMIS</code> 函数（它会实现某种MIS启发式，如平衡启发式Balance Heuristic）来计算权重。平衡启发式的基本形式对于技术 $i$ 的权重是 $w_i = \frac{n_i p_i}{\sum_j n_j p_j}$，其中 $n_j$ 是技术 $j$ 的样本数，$p_j$ 是技术 $j$ 产生该特定样本的概率密度函数 (PDF)。</p>
<h2 id="1-computeinternalmis为nee样本计算mis权重">
<a class="header-anchor" href="#1-computeinternalmis%e4%b8%banee%e6%a0%b7%e6%9c%ac%e8%ae%a1%e7%ae%97mis%e6%9d%83%e9%87%8d"></a>
1. <code>ComputeInternalMIS</code>：为NEE样本计算MIS权重
</h2><p>此函数计算当通过NEE（光源显式采样）得到一个光源样本 <code>lightSample</code> 时，这个样本应有的MIS权重。它考虑了以下采样策略：</p>
<ol>
<li><strong>当前NEE策略</strong>（可能是“窄域(Narrow)”或“全局(Global)”采样）。</li>
<li><strong>另一种NEE策略</strong>（如果当前是窄域，则另一种是全局；反之亦然）。</li>
<li><strong>BSDF采样策略</strong>（即通过材质表面散射恰好采样到这个光源方向的策略）。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hlsl" data-lang="hlsl"><span class="line"><span class="cl"><span class="c1">// PathTracer/Lighting/LightSampler.hlsli</span>
</span></span><span class="line"><span class="cl"><span class="kt">float</span> <span class="n">ComputeInternalMIS</span><span class="p">(</span><span class="k">const</span> <span class="kt">float3</span> <span class="n">surfacePosW</span><span class="p">,</span> <span class="k">const</span> <span class="n">PathTracer</span><span class="o">::</span><span class="n">PathLightSample</span> <span class="n">lightSample</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isNarrow</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint</span> <span class="n">narrowSamples</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint</span> <span class="n">totalSamples</span><span class="p">,</span> <span class="kt">float</span> <span class="n">bsdfPdf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">thisCount</span><span class="p">;</span>  <span class="c1">// 当前NEE策略的样本数</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">otherCount</span><span class="p">;</span> <span class="c1">// 另一种NEE策略的样本数</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">thisPdf</span> <span class="o">=</span> <span class="n">lightSample</span><span class="p">.</span><span class="n">SelectionPdf</span><span class="p">;</span> <span class="c1">// 当前NEE策略选择此光源的PDF</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">otherPdf</span><span class="p">;</span>   <span class="c1">// 另一种NEE策略选择此光源的PDF</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 根据当前NEE样本是“窄域”还是“全局”来设置样本数和对应PDF</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="nd">branch</span><span class="p">]</span><span class="k">if</span> <span class="p">(</span> <span class="n">isNarrow</span> <span class="p">)</span> <span class="c1">// 如果当前是窄域NEE样本</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">thisCount</span>  <span class="o">=</span> <span class="n">narrowSamples</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">otherCount</span> <span class="o">=</span> <span class="n">totalSamples</span> <span class="o">-</span> <span class="n">narrowSamples</span><span class="p">;</span> <span class="c1">// 全局样本数</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取用“全局”策略采样到这个特定光源的PDF</span>
</span></span><span class="line"><span class="cl">        <span class="n">otherPdf</span>   <span class="o">=</span> <span class="n">SampleGlobalPDF</span><span class="p">(</span><span class="n">lightSample</span><span class="p">.</span><span class="n">LightIndex</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="c1">// 如果当前是全局NEE样本</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">thisCount</span>  <span class="o">=</span> <span class="n">totalSamples</span> <span class="o">-</span> <span class="n">narrowSamples</span><span class="p">;</span> <span class="c1">// 全局样本数</span>
</span></span><span class="line"><span class="cl">        <span class="n">otherCount</span> <span class="o">=</span> <span class="n">narrowSamples</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">[</span><span class="nd">branch</span><span class="p">]</span><span class="k">if</span><span class="p">(</span> <span class="n">narrowSamples</span> <span class="o">!=</span> <span class="mo">0</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 获取用“窄域”策略采样到这个特定光源的PDF</span>
</span></span><span class="line"><span class="cl">            <span class="n">otherPdf</span>   <span class="o">=</span> <span class="n">SampleNarrowPDF</span><span class="p">(</span><span class="n">lightSample</span><span class="p">.</span><span class="n">LightIndex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="n">otherPdf</span>   <span class="o">=</span> <span class="mo">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 光源表面点采样PDF（已转换为立体角PDF）。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 对于同一个光源上的同一点，无论是窄域还是全局策略选中它，这个立体角PDF都一样。</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">solidAnglePdf</span> <span class="o">=</span> <span class="n">lightSample</span><span class="p">.</span><span class="n">SolidAnglePdf</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 裁剪bsdfPdf，主要为了数值稳定性，特别是与其他地方可能用fp16打包的情况匹配。</span>
</span></span><span class="line"><span class="cl">    <span class="n">bsdfPdf</span> <span class="o">=</span> <span class="nb">clamp</span><span class="p">(</span><span class="n">bsdfPdf</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="n">HLF_MAX</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 调试宏，可以强制覆盖PDF值</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if defined(RTXPT_NEEAT_MIS_OVERRIDE_BSDF_PDF)</span>
</span></span><span class="line"><span class="cl">    <span class="n">bsdfPdf</span> <span class="o">=</span> <span class="n">RTXPT_NEEAT_MIS_OVERRIDE_BSDF_PDF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if defined(RTXPT_NEEAT_MIS_OVERRIDE_SOLID_ANGLE_PDF)</span>
</span></span><span class="line"><span class="cl">    <span class="n">solidAnglePdf</span> <span class="o">=</span> <span class="n">RTXPT_NEEAT_MIS_OVERRIDE_SOLID_ANGLE_PDF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// LightSamplingMISBoost() 是一个调整因子，可以用来提升或降低光源采样在MIS中的相对权重。</span>
</span></span><span class="line"><span class="cl">    <span class="n">solidAnglePdf</span> <span class="o">*=</span> <span class="n">LightSamplingMISBoost</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用EvalMIS计算MIS权重。RTXPT_NEE_MIS_HEURISTIC 很可能指向平衡启发式。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// EvalMIS的参数大致对应 (启发式, n1, p1, n2, p2, n3, p3, ...)，其中pi是完整PDF。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 技巧1: 当前NEE策略 (thisCount, thisPdf * solidAnglePdf)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 技巧2: 另一种NEE策略 (otherCount, otherPdf * solidAnglePdf)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 技巧3: BSDF采样 (1个样本, bsdfPdf)。仅当 lightSample.LightSampleableByBSDF 为真时才考虑BSDF PDF。</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">thisMIS</span> <span class="o">=</span> <span class="n">EvalMIS</span><span class="p">(</span><span class="n">RTXPT_NEE_MIS_HEURISTIC</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                            <span class="n">thisCount</span><span class="p">,</span> <span class="n">thisPdf</span><span class="o">*</span><span class="n">solidAnglePdf</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                            <span class="n">otherCount</span><span class="p">,</span> <span class="n">otherPdf</span><span class="o">*</span><span class="n">solidAnglePdf</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                            <span class="mi">1</span><span class="p">,</span> <span class="n">lightSample</span><span class="p">.</span><span class="n">LightSampleableByBSDF</span> <span class="o">?</span> <span class="n">bsdfPdf</span> <span class="o">:</span> <span class="mo">0</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// (solidAnglePdf 验证的调试代码块)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// TODO: 注释指出 &#34;/ thisCount&#34; 严格来说不是MIS的一部分。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这表明返回的是一个平均化的MIS权重，或者说，是已将1/N项部分折叠进去的权重。</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">thisMIS</span> <span class="o">/</span> <span class="n">thisCount</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>解析 <code>ComputeInternalMIS</code>:</strong></p>
<ul>
<li><strong>区分窄域/全局NEE</strong>：NEE本身可能包含两种策略：
<ul>
<li><code>isNarrow = true</code>：表示当前样本来自“窄域”采样（例如，针对场景中一小部分更重要的光源，或者使用更集中的PDF）。<code>thisCount</code> 为 <code>narrowSamples</code>，<code>thisPdf</code> 为窄域选择此光源的PDF。相对的“另一种”策略是全局采样，其PDF为 <code>SampleGlobalPDF(lightSample.LightIndex)</code>。</li>
<li><code>isNarrow = false</code>：表示当前样本来自“全局”采样。<code>thisCount</code> 为全局样本数，<code>thisPdf</code> 为全局选择此光源的PDF。相对的“另一种”策略是窄域采样，其PDF为 <code>SampleNarrowPDF(lightSample.LightIndex)</code>。</li>
</ul>
</li>
<li><strong>组合PDF</strong>：
<ul>
<li>对于NEE策略，完整的采样PDF是 <code>SelectionPdf * SolidAnglePdf</code>。<code>SelectionPdf</code> 是选择特定光源的概率，<code>SolidAnglePdf</code> 是在选定光源上采样到特定点（从而产生特定出射方向）的概率密度（以立体角衡量）。</li>
<li>对于BSDF策略，<code>bsdfPdf</code> 是材质表面散射到该方向的概率密度。</li>
</ul>
</li>
<li><strong><code>LightSamplingMISBoost()</code></strong>：这是一个调整因子，可以用来在MIS计算中增加或减少光源采样策略的整体权重，用于微调不同策略间的平衡。</li>
<li><strong><code>EvalMIS</code> 调用</strong>：
<ul>
<li>它比较了三种策略的加权PDF：
<ol>
<li><strong>当前NEE策略</strong>：样本数为 <code>thisCount</code>，PDF为 <code>thisPdf * solidAnglePdf</code>。</li>
<li><strong>另一种NEE策略</strong>：样本数为 <code>otherCount</code>，PDF为 <code>otherPdf * solidAnglePdf</code>。</li>
<li><strong>BSDF采样策略</strong>：样本数视为1（因为我们是在评估单个BSDF方向），PDF为 <code>bsdfPdf</code>。<code>lightSample.LightSampleableByBSDF</code> 标志控制是否将BSDF采样纳入此特定光源的MIS计算（例如，某些类型的光源可能无法通过BSDF采样击中）。</li>
</ol>
</li>
</ul>
</li>
<li><strong>返回值 <code>thisMIS / thisCount</code></strong>：这里的 <code>thisMIS</code> 是由 <code>EvalMIS</code> 计算得到的分子项（即 <code>thisCount * thisPdf_full</code>）。这是一种将蒙特卡洛估计器的 $1/N$ 项部分融入权重计算的方式。</li>
</ul>
<h2 id="2-computebsdfmis为bsdf命中光源的样本计算mis权重">
<a class="header-anchor" href="#2-computebsdfmis%e4%b8%babsdf%e5%91%bd%e4%b8%ad%e5%85%89%e6%ba%90%e7%9a%84%e6%a0%b7%e6%9c%ac%e8%ae%a1%e7%ae%97mis%e6%9d%83%e9%87%8d"></a>
2. <code>ComputeBSDFMIS</code>：为BSDF命中光源的样本计算MIS权重
</h2><p>此函数用于当BSDF采样（材质表面散射）恰好命中了某个光源时，计算该BSDF样本的MIS权重。它需要与两种NEE策略（窄域和全局）进行比较。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hlsl" data-lang="hlsl"><span class="line"><span class="cl"><span class="c1">// PathTracer/Lighting/LightSampler.hlsli</span>
</span></span><span class="line"><span class="cl"><span class="kt">float</span> <span class="n">ComputeBSDFMIS</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint</span> <span class="n">lightIndex</span><span class="p">,</span> <span class="n">lpfloat</span> <span class="n">bsdfPdf</span><span class="p">,</span> <span class="kt">float</span> <span class="n">solidAnglePdf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint</span> <span class="n">narrowSamples</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint</span> <span class="n">totalSamples</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">uint</span> <span class="n">globalSamples</span> <span class="o">=</span> <span class="n">totalSamples</span> <span class="o">-</span> <span class="n">narrowSamples</span><span class="p">;</span> <span class="c1">// 全局NEE样本数</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取窄域和全局NEE策略采样到这个特定光源(lightIndex)的“选择光源”PDF</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">globPdf</span> <span class="o">=</span> <span class="n">SampleGlobalPDF</span><span class="p">(</span><span class="n">lightIndex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">narrPdf</span> <span class="o">=</span> <span class="n">SampleNarrowPDF</span><span class="p">(</span><span class="n">lightIndex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 调试宏，可以强制覆盖PDF值</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if defined(RTXPT_NEEAT_MIS_OVERRIDE_BSDF_PDF)</span>
</span></span><span class="line"><span class="cl">    <span class="n">bsdfPdf</span> <span class="o">=</span> <span class="n">RTXPT_NEEAT_MIS_OVERRIDE_BSDF_PDF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if defined(RTXPT_NEEAT_MIS_OVERRIDE_SOLID_ANGLE_PDF)</span>
</span></span><span class="line"><span class="cl">    <span class="n">solidAnglePdf</span> <span class="o">=</span> <span class="n">RTXPT_NEEAT_MIS_OVERRIDE_SOLID_ANGLE_PDF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">solidAnglePdf</span> <span class="o">*=</span> <span class="n">LightSamplingMISBoost</span><span class="p">();</span> <span class="c1">// 应用同样的MIS调整因子</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用EvalMIS计算MIS权重</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 技巧1: BSDF采样 (1个样本, bsdfPdf)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 技巧2: 全局NEE策略 (globalSamples, globPdf * solidAnglePdf)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 技巧3: 窄域NEE策略 (narrowSamples, narrPdf * solidAnglePdf)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EvalMIS</span><span class="p">(</span><span class="n">RTXPT_NEE_MIS_HEURISTIC</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                   <span class="mi">1</span><span class="p">,</span> <span class="n">bsdfPdf</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                   <span class="n">globalSamples</span><span class="p">,</span> <span class="n">globPdf</span><span class="o">*</span><span class="n">solidAnglePdf</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                   <span class="n">narrowSamples</span><span class="p">,</span> <span class="n">narrPdf</span><span class="o">*</span><span class="n">solidAnglePdf</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>解析 <code>ComputeBSDFMIS</code>:</strong></p>
<ul>
<li><strong>输入参数</strong>：
<ul>
<li><code>lightIndex</code>：被BSDF命中的光源索引。</li>
<li><code>bsdfPdf</code>：产生这个命中方向的BSDF采样PDF。</li>
<li><code>solidAnglePdf</code>：光源在该方向发射光线的立体角PDF（即，如果NEE采样这个光源，得到这个方向的 <code>SolidAnglePdf</code> 部分）。</li>
<li><code>narrowSamples</code>, <code>totalSamples</code>：NEE策略的样本数。</li>
</ul>
</li>
<li><strong>NEE策略PDFs</strong>：获取通过全局NEE (<code>SampleGlobalPDF</code>) 和窄域NEE (<code>SampleNarrowPDF</code>) 采样到 <code>lightIndex</code> 这个特定光源的“选择光源”PDF。</li>
<li><strong><code>EvalMIS</code> 调用</strong>：
<ul>
<li>比较三种策略的加权PDF：
<ol>
<li><strong>BSDF采样</strong>：样本数1，PDF为 <code>bsdfPdf</code>。</li>
<li><strong>全局NEE策略</strong>：样本数为 <code>globalSamples</code>，PDF为 <code>globPdf * solidAnglePdf</code>。</li>
<li><strong>窄域NEE策略</strong>：样本数为 <code>narrowSamples</code>，PDF为 <code>narrPdf * solidAnglePdf</code>。</li>
</ol>
</li>
</ul>
</li>
<li><strong>返回值</strong>：返回的是标准的MIS权重，没有像 <code>ComputeInternalMIS</code> 那样除以样本数。</li>
</ul>
<h2 id="3-computebsdfmisforemissivetriangle针对命中三角形光源的bsdf样本">
<a class="header-anchor" href="#3-computebsdfmisforemissivetriangle%e9%92%88%e5%af%b9%e5%91%bd%e4%b8%ad%e4%b8%89%e8%a7%92%e5%bd%a2%e5%85%89%e6%ba%90%e7%9a%84bsdf%e6%a0%b7%e6%9c%ac"></a>
3. <code>ComputeBSDFMISForEmissiveTriangle</code>：针对命中三角形光源的BSDF样本
</h2><p>这是一个特化版本，用于BSDF样本命中了三角形光源的情况。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hlsl" data-lang="hlsl"><span class="line"><span class="cl"><span class="c1">// PathTracer/Lighting/LightSampler.hlsli</span>
</span></span><span class="line"><span class="cl"><span class="kt">float</span> <span class="n">ComputeBSDFMISForEmissiveTriangle</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint</span> <span class="n">emissiveTriangleLightIndex</span><span class="p">,</span> <span class="n">lpfloat</span> <span class="n">bsdfPdf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float3</span> <span class="n">viewerPosition</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float3</span> <span class="n">lightSamplePosition</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint</span> <span class="n">narrowSamples</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint</span> <span class="n">totalSamples</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果bsdfPdf为0，通常表示Delta分布（如完美镜面）。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这种情况下，NEE几乎不可能采样到这个精确路径，BSDF采样是唯一途径，所以MIS权重为1。</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">bsdfPdf</span> <span class="o">==</span> <span class="mo">0</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 加载三角形光源信息</span>
</span></span><span class="line"><span class="cl">    <span class="n">PolymorphicLightInfoFull</span> <span class="n">lightInfo</span> <span class="o">=</span> <span class="n">LoadLight</span><span class="p">(</span><span class="n">emissiveTriangleLightIndex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">TriangleLight</span> <span class="n">triangleLight</span> <span class="o">=</span> <span class="n">TriangleLight</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">lightInfo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算光源在该方向发射的立体角PDF</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// viewerPosition是当前着色点，lightSamplePosition是光源上被命中的点。</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">solidAnglePdf</span> <span class="o">=</span> <span class="n">triangleLight</span><span class="p">.</span><span class="n">CalcSolidAnglePdfForMIS</span><span class="p">(</span><span class="n">viewerPosition</span><span class="p">,</span> <span class="n">lightSamplePosition</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用通用的ComputeBSDFMIS函数</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ComputeBSDFMIS</span><span class="p">(</span><span class="n">emissiveTriangleLightIndex</span><span class="p">,</span> <span class="n">bsdfPdf</span><span class="p">,</span> <span class="n">solidAnglePdf</span><span class="p">,</span> <span class="n">narrowSamples</span><span class="p">,</span> <span class="n">totalSamples</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>解析 <code>ComputeBSDFMISForEmissiveTriangle</code>:</strong></p>
<ul>
<li><strong>Delta BSDF 特判</strong>：如果 <code>bsdfPdf</code> 为0（通常意味着纯粹的镜面反射/折射），则认为只有BSDF采样能产生这个路径，NEE贡献为0，所以BSDF的MIS权重为1。</li>
<li><strong>计算 <code>solidAnglePdf</code></strong>：关键在于调用 <code>triangleLight.CalcSolidAnglePdfForMIS(...)</code>。这个函数计算从 <code>viewerPosition</code> 看向三角形光源上的 <code>lightSamplePosition</code> 点时，该光源在该方向发射的概率密度（以立体角衡量）。这个PDF是光源本身的固有属性，对于MIS至关重要。</li>
<li><strong>调用通用函数</strong>：计算出特定于三角形光源的 <code>solidAnglePdf</code>后，将其连同其他参数传递给 <code>ComputeBSDFMIS</code> 进行最终的权重计算。</li>
</ul>
<h2 id="4-computebsdfmisforenvironmentquad针对命中环境四边形光源的bsdf样本">
<a class="header-anchor" href="#4-computebsdfmisforenvironmentquad%e9%92%88%e5%af%b9%e5%91%bd%e4%b8%ad%e7%8e%af%e5%a2%83%e5%9b%9b%e8%be%b9%e5%bd%a2%e5%85%89%e6%ba%90%e7%9a%84bsdf%e6%a0%b7%e6%9c%ac"></a>
4. <code>ComputeBSDFMISForEnvironmentQuad</code>：针对命中环境四边形光源的BSDF样本
</h2><p>与三角形光源类似，这是为命中环境四边形光源的BSDF样本设计的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hlsl" data-lang="hlsl"><span class="line"><span class="cl"><span class="c1">// PathTracer/Lighting/LightSampler.hlsli</span>
</span></span><span class="line"><span class="cl"><span class="kt">float</span> <span class="n">ComputeBSDFMISForEnvironmentQuad</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint</span> <span class="n">environmentQuadLightIndex</span><span class="p">,</span> <span class="n">lpfloat</span> <span class="n">bsdfPdf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint</span> <span class="n">narrowSamples</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint</span> <span class="n">totalSamples</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if POLYLIGHT_QT_ENV_ENABLE // 仅当启用环境四边形光源时编译</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">bsdfPdf</span> <span class="o">==</span> <span class="mo">0</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">PolymorphicLightInfoFull</span> <span class="n">lightInfo</span> <span class="o">=</span> <span class="n">LoadLight</span><span class="p">(</span><span class="n">environmentQuadLightIndex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">EnvironmentQuadLight</span> <span class="n">eqLight</span> <span class="o">=</span> <span class="n">EnvironmentQuadLight</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">lightInfo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算环境四边形光源的立体角PDF。参数(0,0)可能表示其PDF不依赖于具体观察点和光源点，</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 或者是这些信息已封装在eqLight对象中，或这是一个简化的计算。</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">solidAnglePdf</span> <span class="o">=</span> <span class="n">eqLight</span><span class="p">.</span><span class="n">CalcSolidAnglePdfForMIS</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ComputeBSDFMIS</span><span class="p">(</span><span class="n">environmentQuadLightIndex</span><span class="p">,</span> <span class="n">bsdfPdf</span><span class="p">,</span> <span class="n">solidAnglePdf</span><span class="p">,</span> <span class="n">narrowSamples</span><span class="p">,</span> <span class="n">totalSamples</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mf">1.0</span><span class="p">;</span> <span class="c1">// 如果未启用，则返回1</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>解析 <code>ComputeBSDFMISForEnvironmentQuad</code>:</strong></p>
<ul>
<li><strong>编译开关</strong>：整个函数的功能取决于 <code>POLYLIGHT_QT_ENV_ENABLE</code> 是否定义。</li>
<li><strong>Delta BSDF 特判</strong>：同上。</li>
<li><strong>计算 <code>solidAnglePdf</code></strong>：调用 <code>eqLight.CalcSolidAnglePdfForMIS(0,0)</code>。传递 <code>(0,0)</code> 作为参数可能意味着环境光（尤其是当它代表“远在天边”的光源时）的发射PDF在所有方向上是均匀的，或者其方向性变化已经通过纹理等方式编码，此处的 <code>solidAnglePdf</code> 是一个基础值或平均值。</li>
<li><strong>调用通用函数</strong>：同上。</li>
</ul>
<p><strong>总结</strong></p>
<p>这些MIS函数共同协作，确保了当不同的采样技术（BSDF与NEE，以及NEE内部的不同策略）可能采样到相同的光路时，它们的贡献能够被合理地加权。</p>
<ul>
<li><code>ComputeInternalMIS</code> 处理NEE样本，并引入了一个特殊的 <code>thisMIS / thisCount</code> 返回值，暗示其结果是用于一种特定累加方式的“平均化”权重。</li>
<li><code>ComputeBSDFMIS</code> 是一个更通用的函数，为BSDF命中的光源计算标准的MIS权重。</li>
<li>针对特定光源类型（三角形、环境四边形）的函数（<code>ComputeBSDFMISForEmissiveTriangle</code> 和 <code>ComputeBSDFMISForEnvironmentQuad</code>）主要负责计算该光源类型特有的 <code>solidAnglePdf</code>，然后复用 <code>ComputeBSDFMIS</code> 的逻辑。</li>
<li><code>LightSamplingMISBoost()</code> 的存在表明系统允许对NEE与BSDF在MIS中的相对重要性进行调整。</li>
<li>对“窄域(Narrow)”和“全局(Global)”NEE采样的区分处理，使得MIS计算能够适应更复杂的、分层的NEE策略。</li>
</ul>
<p>理解这些MIS权重的计算是深入分析路径追踪器方差控制和收敛行为的关键。</p>
<h1 id="从细节到整体">
<a class="header-anchor" href="#%e4%bb%8e%e7%bb%86%e8%8a%82%e5%88%b0%e6%95%b4%e4%bd%93"></a>
从细节到整体
</h1><h2 id="1-handlehit-函数的行为分析">
<a class="header-anchor" href="#1-handlehit-%e5%87%bd%e6%95%b0%e7%9a%84%e8%a1%8c%e4%b8%ba%e5%88%86%e6%9e%90"></a>
1. <code>HandleHit</code> 函数的行为分析
</h2><h3 id="a-当光线打到不发光的三角形时handlehit-会做什么">
<a class="header-anchor" href="#a-%e5%bd%93%e5%85%89%e7%ba%bf%e6%89%93%e5%88%b0%e4%b8%8d%e5%8f%91%e5%85%89%e7%9a%84%e4%b8%89%e8%a7%92%e5%bd%a2%e6%97%b6handlehit-%e4%bc%9a%e5%81%9a%e4%bb%80%e4%b9%88"></a>
a. 当光线打到不发光的三角形时，<code>HandleHit</code> 会做什么？
</h3><ol>
<li>
<p><strong>加载表面数据 (<code>Bridge::loadSurface</code>)</strong>:</p>
<ul>
<li>获取三角形的几何信息（位置、法线、UV等）。</li>
<li>获取材质属性。因为是不发光三角形，所以其自发光属性（<code>bsdfProperties.emission</code>）将为零或非常接近零。其他属性如反照率、粗糙度、折射率等会被加载。</li>
<li>构建 <code>ActiveBSDF</code> 对象，用于后续的BSDF计算。</li>
</ul>
</li>
<li>
<p><strong>体积和嵌套电介质处理</strong>:</p>
<ul>
<li>如果光线在体积内传播，会计算并应用体积吸收/散射 (<code>UpdatePathThroughput</code>)。</li>
<li>如果涉及透明材质和嵌套表面，<code>HandleNestedDielectrics</code> 会处理，可能导致“假命中”被拒绝。</li>
</ul>
</li>
<li>
<p><strong>自发光处理</strong>:</p>
<ul>
<li>由于 <code>bsdfProperties.emission</code> 为零，计算出的 <code>surfaceEmission</code> 也将为零。</li>
<li>因此，<strong>该表面本身不会对路径光照 <code>path.L</code> 产生直接的自发光贡献</strong>。</li>
</ul>
</li>
<li>
<p><strong>路径终止检查 (第一轮)</strong>:</p>
<ul>
<li>检查是否达到最大弹射深度 (<code>HasFinishedSurfaceBounces</code>)。</li>
<li><code>StablePlanesHandleHit</code> 会介入（如果不是参考模式），可能会根据稳定平面逻辑更新路径或标记路径终止。</li>
</ul>
</li>
<li>
<p><strong>俄罗斯轮盘赌</strong>:</p>
<ul>
<li>如果路径未终止，<code>HandleRussianRoulette</code> 会根据路径吞吐量 <code>path.thp</code> 决定是否继续。</li>
</ul>
</li>
<li>
<p><strong>下一事件估计 (NEE - 通过 <code>HandleNEE</code> 调用)</strong>:</p>
<ul>
<li><strong>这是关键一步</strong>。即使当前表面不发光，NEE依然会执行。</li>
<li>它会尝试从当前着色点向场景中的<strong>其他已知光源</strong>投射阴影光线。</li>
<li>如果阴影光线未被遮挡，会计算这些光源对当前点的直接光照贡献（经过BSDF调制和MIS加权）。</li>
<li>这部分直接光照贡献会累加到 <code>path.L</code>。</li>
</ul>
</li>
<li>
<p><strong>BSDF采样 (<code>GenerateScatterRay</code>)</strong>:</p>
<ul>
<li>如果路径仍然有效且未在之前的步骤（如稳定平面或构建模式特定逻辑）中提前返回，则会根据当前不发光材质的BSDF（例如漫反射、镜面反射、折射等）采样一个新的散射方向。</li>
<li><code>path.origin</code>, <code>path.dir</code>, <code>path.thp</code> 会被更新，为下一次弹射做准备。</li>
<li>如果BSDF采样失败（例如，被纯黑材质吸收），路径可能会终止。</li>
</ul>
</li>
</ol>
<p><strong>总结 (不发光三角形)</strong>: <code>HandleHit</code> 会加载其材质属性，<strong>不添加自发光贡献</strong>。但它会通过 <strong>NEE 计算来自场景中其他光源的直接光照</strong>，并累加到路径中。然后，它会根据该表面的BSDF<strong>产生一条散射光线</strong>，让路径继续传播（除非因达到最大深度、俄罗斯轮盘赌或无效散射而终止）。</p>
<h3 id="b-当光线打到发光的三角形时handlehit-会做什么">
<a class="header-anchor" href="#b-%e5%bd%93%e5%85%89%e7%ba%bf%e6%89%93%e5%88%b0%e5%8f%91%e5%85%89%e7%9a%84%e4%b8%89%e8%a7%92%e5%bd%a2%e6%97%b6handlehit-%e4%bc%9a%e5%81%9a%e4%bb%80%e4%b9%88"></a>
b. 当光线打到发光的三角形时，<code>HandleHit</code> 会做什么？
</h3><ol>
<li>
<p><strong>加载表面数据 (<code>Bridge::loadSurface</code>)</strong>:</p>
<ul>
<li>同上，但这次 <code>bsdfProperties.emission</code> 会是一个大于零的值。</li>
</ul>
</li>
<li>
<p><strong>体积和嵌套电介质处理</strong>: 同上。</p>
</li>
<li>
<p><strong>自发光处理</strong>:</p>
<ul>
<li><strong>这是关键区别</strong>。由于 <code>bsdfProperties.emission &gt; 0</code>：
<ul>
<li>会计算 <code>surfaceEmission = bsdfProperties.emission * misWeight</code>。</li>
<li>这里的 <code>misWeight</code> 是通过 <code>ComputeBSDFMISForEmissiveTriangle</code> 计算得到的。它用于平衡“BSDF采样恰好命中此发光面”与“在上一路径顶点通过NEE采样到此发光面”这两种策略。</li>
<li>这个经过MIS加权的 <code>surfaceEmission</code> 会乘以当前路径吞吐量 <code>path.thp</code> 并累加到 <code>path.L</code>。</li>
<li><strong>所以，该发光表面本身的辐射能量被计入路径。</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>路径终止检查 (第一轮)</strong>: 同上。如果设定了“命中光源即终止路径”的逻辑，这里可能会终止。</p>
</li>
<li>
<p><strong>俄罗斯轮盘赌</strong>: 同上。</p>
</li>
<li>
<p><strong>下一事件估计 (NEE - 通过 <code>HandleNEE</code> 调用)</strong>:</p>
<ul>
<li>NEE <strong>依然会执行</strong>。它会尝试从当前着色点（即这个发光三角形表面上的点）向场景中的<strong>其他光源</strong>（甚至可能包括这个发光三角形自身，MIS应能处理这种情况）投射阴影光线。</li>
<li>来自这些光源的直接光照贡献（MIS加权后）会累加到 <code>path.L</code>。</li>
</ul>
</li>
<li>
<p><strong>BSDF采样 (<code>GenerateScatterRay</code>)</strong>:</p>
<ul>
<li>发光表面也可能有其自身的BSDF（例如，一个磨砂灯泡表面既发光也漫反射）。</li>
<li><code>GenerateScatterRay</code> 仍然会尝试根据其BSDF（非自发光部分）采样一个新的散射方向。如果材质是纯粹的自发光体并且不散射任何入射光，则BSDF采样可能会导致路径终止或产生零吞吐量的散射。</li>
</ul>
</li>
</ol>
<p><strong>总结 (发光三角形)</strong>: <code>HandleHit</code> 会加载其材质和自发光属性。它会<strong>计算并累加该发光表面本身的辐射贡献</strong>（经过MIS加权，以正确处理与NEE的组合）。同时，它也<strong>会通过NEE计算来自场景中其他光源的直接光照</strong>。并且，它还会尝试根据该表面的（非自发光）BSDF<strong>产生散射光线</strong>。</p>
<h2 id="2-nee又做了什么呢">
<a class="header-anchor" href="#2-nee%e5%8f%88%e5%81%9a%e4%ba%86%e4%bb%80%e4%b9%88%e5%91%a2"></a>
2. NEE又做了什么呢？
</h2><p>在<code>HandleHit</code>的上下文中，NEE（通过<code>HandleNEE</code>及其辅助函数实现）的核心作用是<strong>在当前光线与表面交互点（无论是发光还是不发光表面），主动地、显式地向场景中的已知光源投射光线，以计算这些光源对该点的直接光照贡献。</strong></p>
<p>具体步骤如下（在<code>HandleNEE_MultipleSamples</code> 和 <code>ProcessLightSample</code>中）：</p>
<ol>
<li><strong>选择光源</strong>: <code>LightSampler</code>根据一定策略（可能包括窄域/全局、自适应反馈等）选择一个或多个光源进行采样。</li>
<li><strong>在光源上采样点</strong>: 在选定的光源表面（或体积内）选择一个具体的点。</li>
<li><strong>构造阴影光线</strong>: 从当前着色点向光源上的采样点构造一条“阴影光线”或“可见性光线”。</li>
<li><strong>可见性测试</strong>: 追踪这条阴影光线 (<code>Bridge::traceVisibilityRay</code>)，判断它是否被场景中的其他物体遮挡。</li>
<li><strong>如果可见</strong>:
<ul>
<li>获取光源在该方向的辐射亮度 <code>Li</code>。</li>
<li>评估当前着色点表面的BSDF在阴影光线方向上的值 ( $f_r \cdot \cos\theta_i$ )。</li>
<li>计算NEE采样本身的PDF ($p_{NEE}$)。</li>
<li>计算BSDF采样得到该方向的PDF ($p_{BSDF}$)。</li>
<li>使用这些PDF和相应的样本数，通过 <code>ComputeInternalMIS</code> 计算此NEE样本的MIS权重 ($w_{NEE}$)。</li>
<li>最终贡献大致为：$ L_D = \text{Li} \cdot \text{BSDF\_value} \cdot \text{Visibility} \cdot w_{NEE} / p_{NEE} $ (这里的 $1/p_{NEE}$ 通常已经包含在 <code>Li</code> 或 <code>lightSample</code> 的值中，而 $w_{NEE}$ 在RTXPT中可能如我们之前讨论的包含了 $1/N$ 因子)。</li>
<li>将此贡献累加到 <code>path.L</code>。</li>
</ul>
</li>
<li><strong>重复</strong>: 如果配置了多次NEE采样，则重复以上步骤。</li>
</ol>
<p>NEE通过这种方式，确保了即使BSDF采样很难“偶然”碰到光源（特别是小光源或远距离光源），直接光照也能被有效地采样，从而显著降低渲染图像中直接光照部分的噪声，并加速收敛。</p>
<h2 id="3-nee的bsdf和光源采样的mis-weight有什么特殊的处理吗">
<a class="header-anchor" href="#3-nee%e7%9a%84bsdf%e5%92%8c%e5%85%89%e6%ba%90%e9%87%87%e6%a0%b7%e7%9a%84mis-weight%e6%9c%89%e4%bb%80%e4%b9%88%e7%89%b9%e6%ae%8a%e7%9a%84%e5%a4%84%e7%90%86%e5%90%97"></a>
3. NEE的BSDF和光源采样的MIS weight有什么特殊的处理吗？
</h2><ol>
<li>
<p><strong><code>ComputeInternalMIS</code> 的返回值</strong>:</p>
<ul>
<li>如我们之前深入讨论的，<code>ComputeInternalMIS</code>（用于NEE样本的MIS权重计算）返回的是 <code>thisMIS / thisCount</code>。这里的 <code>thisMIS</code> 是 <code>EvalMIS</code> 计算得到的分子项或完整权重（取决于 <code>EvalMIS</code> 的具体实现），而 <code>thisCount</code> 是当前NEE策略（窄域或全局）的样本数。</li>
<li><strong>特殊之处</strong>: 标准的MIS权重本身不包含 $1/N$ 这个因子。这里的处理意味着，每个NEE样本的贡献在 <code>ProcessLightSample</code> 中计算时，其权重已经部分地为最终的蒙特卡洛估计器的 $1/N$ 求和形式做了适配。这意味着 <code>HandleNEE_MultipleSamples</code> 中对这些贡献的简单求和可能对应着一种特定形式的组合估计量。代码注释也指出了 <code>&quot;/ thisCount&quot; isn't technically part of MIS!!</code>。</li>
</ul>
</li>
<li>
<p><strong>区分NEE内部策略 (Narrow vs. Global)</strong>:</p>
<ul>
<li>MIS计算明确区分了NEE可能存在的“窄域(Narrow)”和“全局(Global)”两种采样策略。</li>
<li><code>ComputeInternalMIS</code> 在计算一个窄域样本的权重时，会将其与全局NEE策略以及BSDF策略进行平衡。计算一个全局样本的权重时，则与窄域NEE策略和BSDF策略平衡。</li>
<li><code>ComputeBSDFMIS</code> 在计算一个BSDF命中光源的权重时，会同时与窄域NEE和全局NEE策略进行平衡。</li>
<li>这要求 <code>SampleNarrowPDF()</code> 和 <code>SampleGlobalPDF()</code> 提供选择特定光源的正确PDF，并且样本数 <code>narrowSamples</code> 和 <code>globalSamples</code> (<code>totalSamples - narrowSamples</code>) 被正确使用。</li>
</ul>
</li>
<li>
<p><strong><code>LightSamplingMISBoost()</code></strong>:</p>
<ul>
<li>这是一个应用于光源立体角PDF (<code>solidAnglePdf</code>) 的调整因子。</li>
<li>它允许开发者对NEE策略的“有效PDF”进行微调，从而在MIS平衡中或多或少地偏向NEE策略或BSDF策略。这是一种经验性的调整，可能用于处理特定场景或光照条件下的疑难杂症，或者根据某些启发式来优化收敛。</li>
</ul>
</li>
<li>
<p><strong><code>lightSample.LightSampleableByBSDF</code> 标志</strong>:</p>
<ul>
<li>在 <code>ComputeInternalMIS</code> 中，BSDF的PDF仅在 <code>lightSample.LightSampleableByBSDF</code> 为真时才被包含在MIS分母中。</li>
<li>这允许某些类型的光源（例如，无真实表面的点光源，或用户定义的某些特殊光源）被排除在“可被BSDF采样命中”的范畴之外，从而在对这些光源进行NEE采样时，其MIS权重不会考虑BSDF采样的可能性。</li>
</ul>
</li>
<li>
<p><strong>BSDF PDF为零时的特殊处理</strong>:</p>
<ul>
<li>在 <code>ComputeBSDFMISForEmissiveTriangle</code> 和 <code>ComputeBSDFMISForEnvironmentQuad</code> 中，如果传入的 <code>bsdfPdf</code> 为0（通常意味着BSDF是Delta分布，如理想镜面或玻璃），则直接返回MIS权重1。</li>
<li>理由是：如果BSDF是Delta分布，它会以100%的概率将光线散射到一个确定的方向。如果这个方向恰好命中了光源，那么NEE策略（通常不针对精确的Delta方向进行采样）几乎不可能独立地产生完全相同的路径。因此，BSDF采样被认为是100%负责这条路径，其MIS权重为1。</li>
</ul>
</li>
</ol>
<p>这些特殊处理反映了在复杂渲染器中实现MIS时需要考虑的细微之处和优化技巧，旨在提高鲁棒性、性能和最终图像质量。</p>
<h2 id="4-为什么这样是正确的">
<a class="header-anchor" href="#4-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%99%e6%a0%b7%e6%98%af%e6%ad%a3%e7%a1%ae%e7%9a%84"></a>
4. 为什么这样是正确的？
</h2><p>“正确性”在路径追踪中通常指<strong>无偏性</strong>（随着样本数量增加，结果收敛到物理精确解）和<strong>有效性</strong>（在有限样本下能有效降低方差，更快收敛）。</p>
<ol>
<li>
<p><strong>无偏性的基础</strong>:</p>
<ul>
<li>路径追踪本身是求解渲染方程的一种无偏蒙特卡洛方法。</li>
<li>只要每个单独的采样技术（BSDF采样、NEE采样）都是无偏的（即其贡献的期望值等于要求解的真实值），并且它们的PDF被正确使用，那么基础是稳固的。
<ul>
<li>BSDF采样贡献形式为 $L_i \cdot \frac{f_r \cdot \cos\theta}{p_{BSDF}}$。</li>
<li>NEE采样贡献形式为 $L_e \cdot \frac{f_r \cdot \cos\theta \cdot G \cdot V}{p_{NEE}}$。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>MIS的正确性 (基于平衡启发式)</strong>:</p>
<ul>
<li>当你用多种技术采样同一个积分量时（例如直接光照可以由NEE采样，也可以由BSDF采样间接命中光源得到），直接将它们的贡献相加会导致重复计算和偏差。</li>
<li>多重重要性采样（MIS），特别是平衡启发式 ($w_k(X) = \frac{n_k p_k(X)}{\sum_j n_j p_j(X)}$)，提供了一种组合这些技术的方式，使得最终的组合估计量仍然是<strong>无偏的</strong>，并且其方差通常<strong>低于或等于</strong>所有单个技术中最优者的方差。</li>
<li><strong>关键在于</strong>：对于任何一个特定的采样结果（例如，一条从点x到达光源L的特定光路），所有可能产生该结果的采样技术的加权PDF之和（或者说，MIS权重之和，如果每个权重对应一个技术产生了该样本）必须为1。即，$\sum_k w_k(X) = 1$ (当我们将 $w_k(X)$ 定义为当技术k产生样本X时的权重时)。</li>
<li>RTXPT中的 <code>EvalMIS</code> 函数（假设它实现了平衡启发式）正是基于这个原理。只要提供给它的所有技术的样本数($n_k$)和PDF($p_k$)是准确的，它计算出的权重就能保证组合估计的无偏性。</li>
</ul>
</li>
<li>
<p><strong>对RTXPT中特定实现的考量</strong>:</p>
<ul>
<li><strong>PDF的准确性</strong>: 整个MIS系统的正确性高度依赖于 <code>lightSample.SelectionPdf</code>, <code>lightSample.SolidAnglePdf</code>, <code>bsdfPdf</code>, <code>SampleGlobalPDF()</code>, <code>SampleNarrowPDF()</code> 这些函数返回的PDF值的准确性。它们必须精确反映对应采样过程的真实概率密度。</li>
<li><strong>样本数的正确使用</strong>: <code>narrowSamples</code>, <code>totalSamples - narrowSamples</code>, 以及BSDF的隐式样本数1，必须正确地代表各个策略的相对采样投入。</li>
<li><strong><code>ComputeInternalMIS</code> 的 <code>thisMIS / thisCount</code></strong>:
<ul>
<li>这是最需要仔细推敲其“正确性”的地方。如果 <code>EvalMIS</code> 返回的是标准的MIS权重 $w_k = \frac{N_k p_k}{\sum_j N_j p_j}$，那么 <code>ComputeInternalMIS</code> 返回的是 $w_k / N_k$。</li>
<li>这意味着在 <code>ProcessLightSample</code> 中，每个NEE样本的贡献被计算为 $\text{Value} \cdot (w_k / N_k)$。</li>
<li>当 <code>HandleNEE_MultipleSamples</code> 将这些单个样本的贡献（它们已经携带了 $1/N_k$ 因子）直接相加时，它得到的总和是 $\sum_{k \in \text{NEE strategies}} \sum_{i=1}^{N_k} \frac{\text{Value}_{k,i}}{p_{k,i}} \frac{w_{k,i}}{N_k}$。</li>
<li>这可以被看作是<strong>多个独立估计量之和</strong>：$\sum_{k} (\frac{1}{N_k} \sum_{i=1}^{N_k} \frac{\text{Value}_{k,i}}{p_{k,i}} w_{k,i})$，其中 $w_{k,i}$ 是标准MIS权重。如果每个 $ (\frac{1}{N_k} \sum \dots ) $ 都是对同一积分量的无偏估计，那么将它们相加通常不是标准做法（除非它们估计的是积分的不同部分）。</li>
<li><strong>然而，这可能是为了与某种特定的NEE多策略组合或自适应方案的数学推导保持一致。</strong> 例如，如果“窄域”和“全局”NEE策略被视为对不同“重要性区域”的探测，并且最终的NEE贡献是这些探测结果的某种形式的合并，那么这种加权和累加方式可能是特定于该合并方案的。其“正确性”将取决于整个NEE估计量的完整数学形式。对于外部观察者，这确实是一个值得标记为“高级/特定实现细节”的点。</li>
</ul>
</li>
<li><strong>条件性包含PDF (<code>lightSample.LightSampleableByBSDF</code>, <code>bsdfPdf == 0</code>)</strong>: 这些判断是正确的，因为它们确保了MIS只在真正存在多种竞争采样策略的情况下应用。如果一种策略实际上不可能产生某个样本，那么它不应该参与该样本的MIS权重计算。</li>
</ul>
</li>
</ol>
<p><strong>结论性的思考</strong>:
这些MIS实现展现了现代路径追踪器所需考虑的复杂性和细致性。虽然某些部分（如 <code>ComputeInternalMIS</code> 的最终除法）可能看起来与教材中的标准MIS表述略有不同，但这通常是为了适应更高级的采样方案、性能优化或特定的估计量组合。其核心正确性依赖于：</p>
<ol>
<li>每个基础采样技术的无偏性。</li>
<li>所有相关PDF的准确计算。</li>
<li>MIS组合（如平衡启发式）的正确应用，以确保最终组合估计量的无偏性。</li>
</ol>
<p>只要这些要素得到保证，即使形式上有所调整，系统也能收敛到正确的结果，并且MIS的目标——降低方差——也能得以实现。对于非常规的部分，通常背后有特定的数学推导来支持其在该系统框架内的正确性。</p>
<h1 id="miss-shader揭秘--handlemiss-与环境光处理">
<a class="header-anchor" href="#miss-shader%e6%8f%ad%e7%a7%98--handlemiss-%e4%b8%8e%e7%8e%af%e5%a2%83%e5%85%89%e5%a4%84%e7%90%86"></a>
Miss Shader揭秘 —— HandleMiss 与环境光处理
</h1><p>到目前为止，我们已经探讨了光线的生成、在场景中的弹射、与不发光/发光表面的交互，以及NEE（下一事件估计）如何计算直接光照。但如果一条光线飞向无穷远，没有碰到任何物体，会发生什么呢？这时就轮到<code>Miss Shader</code>（在RTXPT中通过 <code>PathTracer.hlsli</code> 里的 <code>PathTracer::HandleMiss</code> 函数实现）登场了。它的主要职责是计算来自环境（例如天空盒、环境贴图）的光照贡献，并终止这条光线的路径。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hlsl" data-lang="hlsl"><span class="line"><span class="cl"><span class="c1">// PathTracer/PathTracer.hlsli</span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">PathTracer</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... (其他函数) ...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Miss shader</span>
</span></span><span class="line"><span class="cl">    <span class="k">inline</span> <span class="kt">void</span> <span class="n">HandleMiss</span><span class="p">(</span><span class="k">inout</span> <span class="n">PathState</span> <span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float3</span> <span class="n">rayOrigin</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float3</span> <span class="n">rayDir</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">rayTCurrent</span><span class="p">,</span> <span class="k">const</span> <span class="n">WorkingContext</span> <span class="n">workingContext</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 更新路径已行进的距离和相关状态</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// rayTCurrent 在这里通常是 TraceRay 时设置的 TMax，表示光线行进了这么远仍未命中。</span>
</span></span><span class="line"><span class="cl">        <span class="n">UpdatePathTravelled</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">rayOrigin</span><span class="p">,</span> <span class="n">rayDir</span><span class="p">,</span> <span class="n">rayTCurrent</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// (Delta Tree 可视化调试相关的代码块)</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE==PATH_TRACER_MODE_BUILD_STABLE_PLANES &amp;&amp; ENABLE_DEBUG_DELTA_TREE_VIZUALISATION</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">hasFlag</span><span class="p">(</span><span class="n">PathFlags</span><span class="o">::</span><span class="n">deltaTreeExplorer</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">DeltaTreeVizHandleMiss</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">rayOrigin</span><span class="p">,</span> <span class="n">rayDir</span><span class="p">,</span> <span class="n">rayTCurrent</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">float3</span> <span class="n">environmentEmission</span> <span class="o">=</span> <span class="mf">0.f</span><span class="p">;</span> <span class="c1">// 初始化环境光贡献</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 解包 MIS (多重重要性采样) 信息</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// misInfo 来自上一路径顶点的NEE计算，用于判断是否需要对环境光进行MIS。</span>
</span></span><span class="line"><span class="cl">        <span class="n">NEEBSDFMISInfo</span> <span class="n">misInfo</span> <span class="o">=</span> <span class="n">NEEBSDFMISInfo</span><span class="o">::</span><span class="n">Unpack16bit</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">packedMISInfo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 判断是否需要计算环境光贡献 (考虑与NEE/ReSTIR DI的配合)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// !(A &amp;&amp; B) 等价于 !A || !B</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// misInfo.SkipEmissiveBRDF: 如果为true (例如ReSTIR DI已处理直接光)，则可能跳过自发光/环境光。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// !path.wasScatterTransmission(): 如果上一次散射是透射，即使SkipEmissiveBRDF为true，可能仍需评估环境光。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 总体逻辑：除非(明确指示跳过自发光/环境光 并且 上一次不是透射)，否则就计算环境光。</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">misInfo</span><span class="p">.</span><span class="n">SkipEmissiveBRDF</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">path</span><span class="p">.</span><span class="n">wasScatterTransmission</span><span class="p">())</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 3a. 获取环境贴图对象</span>
</span></span><span class="line"><span class="cl">            <span class="n">EnvMap</span> <span class="n">envMap</span> <span class="o">=</span> <span class="n">Bridge</span><span class="o">::</span><span class="n">CreateEnvMap</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 3b. 根据漫反射弹射次数选择环境贴图的MIP级别</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 多次漫反射后，使用较低的MIP级别可以减少高频环境贴图带来的噪声和计算成本。</span>
</span></span><span class="line"><span class="cl">            <span class="kt">float</span> <span class="n">mipLevel</span> <span class="o">=</span> <span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">getCounter</span><span class="p">(</span><span class="n">PackedCounters</span><span class="o">::</span><span class="n">DiffuseBounces</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">(</span><span class="n">Bridge</span><span class="o">::</span><span class="n">DiffuseEnvironmentMapMIPOffset</span><span class="p">())</span><span class="o">:</span><span class="p">(</span><span class="mo">0</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 3c. 将光线方向转换为环境贴图的本地坐标系 (环境贴图可能自带旋转)</span>
</span></span><span class="line"><span class="cl">            <span class="kt">float3</span> <span class="n">localDir</span> <span class="o">=</span> <span class="n">envMap</span><span class="p">.</span><span class="n">ToLocal</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dir</span><span class="p">);</span>      
</span></span><span class="line"><span class="cl">            <span class="c1">// 3d. 从环境贴图采样，获取辐射亮度 Le</span>
</span></span><span class="line"><span class="cl">            <span class="kt">float3</span> <span class="n">Le</span> <span class="o">=</span> <span class="n">envMap</span><span class="p">.</span><span class="n">EvalLocal</span><span class="p">(</span><span class="n">localDir</span><span class="p">,</span> <span class="n">mipLevel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 3e. 计算 MIS 权重</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 目的是平衡“BSDF采样方向恰好指向环境的这个部分”与“NEE从前一顶点显式采样环境光的这个部分”</span>
</span></span><span class="line"><span class="cl">            <span class="kt">float</span> <span class="n">misWeight</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 条件：前一顶点启用了光源采样(NEE)，且当前未命中路径是由BSDF采样产生的(PDF非零)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span> <span class="n">misInfo</span><span class="p">.</span><span class="n">LightSamplingEnabled</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="p">.</span><span class="n">bsdfScatterPdf</span> <span class="o">!=</span> <span class="mo">0</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 创建与前一顶点配置相同的光源采样器</span>
</span></span><span class="line"><span class="cl">                <span class="n">LightSampler</span> <span class="n">lightSampler</span> <span class="o">=</span> <span class="n">Bridge</span><span class="o">::</span><span class="n">CreateLightSampler</span><span class="p">(</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">pixelPos</span><span class="p">,</span> <span class="n">misInfo</span><span class="p">.</span><span class="n">LightSamplingIsIndirect</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">debug</span><span class="p">.</span><span class="n">IsDebugPixel</span><span class="p">()</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 根据当前未命中的方向，查找对应的环境光源索引（环境贴图常被视为一个或多个光源）</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// LookupEnvLightByDirection 是关键，它将一个方向映射到一个“光源实体”以便获取NEE的PDF。</span>
</span></span><span class="line"><span class="cl">                <span class="kt">uint</span> <span class="n">environmentQuadLightIndex</span> <span class="o">=</span> <span class="n">lightSampler</span><span class="p">.</span><span class="n">LookupEnvLightByDirection</span><span class="p">(</span> <span class="n">localDir</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">                <span class="c1">// 计算BSDF路径命中此环境区域的MIS权重，与NEE采样此区域的可能性进行平衡。</span>
</span></span><span class="line"><span class="cl">                <span class="n">misWeight</span> <span class="o">=</span> <span class="n">lightSampler</span><span class="p">.</span><span class="n">ComputeBSDFMISForEnvironmentQuad</span><span class="p">(</span><span class="n">environmentQuadLightIndex</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">bsdfScatterPdf</span><span class="p">,</span> <span class="n">misInfo</span><span class="p">.</span><span class="n">NarrowNEESamples</span><span class="p">,</span> <span class="n">misInfo</span><span class="p">.</span><span class="n">TotalSamples</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// (向光源采样器提供反馈，用于自适应光源采样)</span>
</span></span><span class="line"><span class="cl">                <span class="kt">float</span> <span class="n">simpleRandom</span> <span class="o">=</span> <span class="n">Hash32ToFloat</span><span class="p">(</span> <span class="n">Hash32Combine</span><span class="p">(</span> <span class="n">Hash32Combine</span><span class="p">(</span><span class="n">Hash32</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">getVertexIndex</span><span class="p">()</span> <span class="o">+</span> <span class="mh">0x0366FE2F</span><span class="p">),</span> <span class="n">path</span><span class="p">.</span><span class="n">id</span><span class="p">),</span> <span class="n">Bridge</span><span class="o">::</span><span class="n">getSampleIndex</span><span class="p">()</span> <span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">lightSampler</span><span class="p">.</span><span class="n">InsertFeedbackFromBSDF</span><span class="p">(</span><span class="n">environmentQuadLightIndex</span><span class="p">,</span> <span class="n">average</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">thp</span><span class="o">*</span><span class="n">Le</span><span class="p">),</span> <span class="n">misWeight</span><span class="p">,</span> <span class="n">simpleRandom</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">environmentEmission</span> <span class="o">=</span> <span class="n">misWeight</span> <span class="o">*</span> <span class="n">Le</span><span class="p">;</span> <span class="c1">// 应用MIS权重到环境光亮度</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 4. 对计算出的环境光贡献进行后处理</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">ptConsts</span><span class="p">.</span><span class="n">fireflyFilterThreshold</span> <span class="o">!=</span> <span class="mo">0</span> <span class="p">)</span> <span class="c1">// 飞火过滤</span>
</span></span><span class="line"><span class="cl">            <span class="n">environmentEmission</span> <span class="o">=</span> <span class="n">FireflyFilter</span><span class="p">(</span> <span class="n">environmentEmission</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">.</span><span class="n">ptConsts</span><span class="p">.</span><span class="n">fireflyFilterThreshold</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">fireflyFilterK</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">environmentEmission</span> <span class="o">*=</span> <span class="n">Bridge</span><span class="o">::</span><span class="n">getNoisyRadianceAttenuation</span><span class="p">();</span> <span class="c1">// 应用噪声衰减（例如用于多重采样抗锯齿）</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 5. 更新路径状态：清除命中信息并终止路径</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">clearHit</span><span class="p">();</span>  <span class="c1">// 清除任何可能残留的命中信息</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">terminate</span><span class="p">();</span> <span class="c1">// 标记路径为非激活，因为它不会再继续传播</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 6. 【可选】稳定平面系统处理未命中情况</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE!=PATH_TRACER_MODE_REFERENCE</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// StablePlanesHandleMiss 允许稳定平面系统记录或使用这条未命中路径的环境光贡献。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果它返回false，可能表示路径已被稳定平面系统完全处理，可以提前返回。</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">StablePlanesHandleMiss</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">environmentEmission</span><span class="p">,</span> <span class="n">rayOrigin</span><span class="p">,</span> <span class="n">rayDir</span><span class="p">,</span> <span class="n">rayTCurrent</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="n">workingContext</span><span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 7. 将环境光贡献累加到路径总光照 L</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// (在特定模式下，例如填充稳定平面模式，可能不直接累加到 L，而是输出到特定缓冲区)</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if PATH_TRACER_MODE != PATH_TRACER_MODE_FILL_STABLE_PLANES </span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">environmentEmission</span><span class="o">&gt;</span><span class="mo">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span><span class="p">.</span><span class="n">L</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span> <span class="mf">0.</span><span class="n">xxx</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">thp</span><span class="o">*</span><span class="n">environmentEmission</span> <span class="p">);</span> <span class="c1">// 确保贡献非负</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="c1">// end of HandleMiss</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// end of namespace PathTracer</span>
</span></span></code></pre></div><p><strong><code>HandleMiss</code> 的核心逻辑剖析：</strong></p>
<ol>
<li>
<p><strong>路径状态更新 (<code>UpdatePathTravelled</code>)</strong>: 与 <code>HandleHit</code> 类似，首先更新光线行进的距离等信息。对于 <code>HandleMiss</code>，<code>rayTCurrent</code> 通常是光线追踪时设定的最大追踪距离 <code>TMax</code>。</p>
</li>
<li>
<p><strong>MIS 信息与条件判断 (<code>misInfo</code>, <code>if (!(misInfo.SkipEmissiveBRDF &amp;&amp; !path.wasScatterTransmission()))</code>)</strong>:</p>
<ul>
<li><code>misInfo</code> 是从 <code>path.packedMISInfo</code> 解包得到的，它包含了上一个路径顶点（如果执行了NEE）的MIS相关决策信息。</li>
<li><code>SkipEmissiveBRDF</code> 标志若为真，通常意味着像ReSTIR DI这样的技术已经负责了直接光照（包括来自环境的光源），因此BSDF路径不应再次重复计算这些贡献。</li>
<li><code>!path.wasScatterTransmission()</code> 表示上一次散射不是透射。如果上一次是透射（例如光线从物体内部射出到环境中），即使 <code>SkipEmissiveBRDF</code> 为真，也可能需要评估环境光。</li>
<li>这个 <code>if</code> 条件决定了是否真的需要对环境贴图进行采样。如果条件不满足（例如，ReSTIR DI已处理且非透射出界），<code>environmentEmission</code> 将保持为0。</li>
</ul>
</li>
<li>
<p><strong>环境光采样与MIS</strong>:</p>
<ul>
<li><strong>采样环境贴图</strong>: 如果需要计算环境光，代码会获取环境贴图 (<code>Bridge::CreateEnvMap()</code>)，根据光线方向 <code>path.dir</code>（可能需要转换到环境贴图的局部坐标系）和选定的MIP级别（多次漫反射后使用较低MIP以减少噪声）来评估环境贴图，得到基础的环境辐射亮度 <code>Le</code>。</li>
<li><strong>MIS权重计算</strong>: 这是非常关键的一步。
<ul>
<li>如果前一个顶点执行了NEE (<code>misInfo.LightSamplingEnabled == true</code>)，并且当前这条未命中场景的路径是由BSDF散射产生的 (<code>path.bsdfScatterPdf != 0</code>)，那么就需要计算MIS权重。</li>
<li>这是因为环境贴图本身也可以被视为一个巨大的光源，NEE有可能会从前一个顶点直接采样到当前这个方向的环境光。因此，当BSDF路径“自然地”射向这个方向的环境时，需要与NEE策略进行平衡。</li>
<li><code>lightSampler.LookupEnvLightByDirection(localDir)</code>: 这个函数很关键，它试图将当前光线的方向 <code>localDir</code> 映射到光源采样器 <code>LightSampler</code> 中的一个“环境光源实体”（例如一个代表天空的 <code>EnvironmentQuadLight</code>）。有了这个光源索引，才能获取NEE采样该环境光源的PDF。</li>
<li><code>lightSampler.ComputeBSDFMISForEnvironmentQuad(...)</code>: 使用我们之前讨论过的MIS计算函数，传入BSDF的PDF (<code>path.bsdfScatterPdf</code>) 和从 <code>environmentQuadLightIndex</code> 获取到的NEE采样该环境区域的PDF，来计算当前BSDF路径命中此环境的MIS权重。</li>
<li><code>lightSampler.InsertFeedbackFromBSDF(...)</code>: 如果BSDF路径命中了环境光，并且该环境光贡献显著，这个信息会反馈给光源采样器，用于未来的自适应采样。</li>
</ul>
</li>
<li>最终的环境光贡献是 <code>misWeight * Le</code>。</li>
</ul>
</li>
<li>
<p><strong>后处理与路径终止</strong>:</p>
<ul>
<li>计算得到的 <code>environmentEmission</code> 会经过飞火过滤和噪声衰减。</li>
<li><code>path.clearHit()</code> 清除路径上的命中信息（因为确实未命中）。</li>
<li><code>path.terminate()</code> 将路径标记为终止，因为它已经到达了“世界尽头”，不会再有后续的弹射。</li>
</ul>
</li>
<li>
<p><strong>稳定平面交互 (<code>StablePlanesHandleMiss</code>)</strong>: 如果启用了稳定平面技术（非参考模式），<code>StablePlanesHandleMiss</code> 会被调用。这个函数允许稳定平面系统利用这次未命中事件的信息，例如记录逃逸出稳定区域的光线的环境光贡献。</p>
</li>
<li>
<p><strong>累加贡献</strong>: 最后，在合适的路径追踪模式下，经过处理的 <code>environmentEmission</code> 会乘以当前路径的吞吐量 <code>path.thp</code>，并累加到总的路径光照 <code>path.L</code> 中。</p>
</li>
</ol>
<p><strong>总结 <code>HandleMiss</code> 的重要性：</strong></p>
<ul>
<li>它不仅仅是返回一个固定的背景色。对于基于图像的照明（Image-Based Lighting, IBL），<code>HandleMiss</code> 是实现真实感环境光照的核心。</li>
<li>它通过MIP级别选择来平衡环境贴图的细节和渲染性能/噪声。</li>
<li>最精妙之处在于它与NEE的MIS集成。通过将环境视为一个（或多个）可被NEE采样的光源，<code>HandleMiss</code> 能够正确地处理BSDF路径命中环境与NEE直接采样环境之间的权重分配，避免了重复计算或权重失衡，这对于IBL的无偏和高效渲染至关重要。</li>
<li>与稳定平面系统的交互进一步展示了RTXPT中不同渲染子系统间的协同工作。</li>
</ul>
<p><code>HandleMiss</code> 虽然代表光线的“终点”，但其内部逻辑（特别是MIS部分）同样体现了现代路径追踪算法的复杂与精巧。</p>
<h1 id="阶段性总结">
<a class="header-anchor" href="#%e9%98%b6%e6%ae%b5%e6%80%a7%e6%80%bb%e7%bb%93"></a>
阶段性总结
</h1><p>目前我们已经梳理了 <code>RayGen</code>、<code>ClosestHit</code> (<code>HandleHit</code>)、<code>NEE</code> (<code>HandleNEE</code>) 以及 <code>Miss Shader</code> (<code>HandleMiss</code>) 的主要逻辑，对 NEE 的采样流程和 MIS 的计算也有了初步理解。如果之后有时间，可以进一步研究一些辅助函数，例如 <code>Bridge::</code> 系列或者光源/BSDF 采样的具体实现。</p>
<p>这个仓库的功能还挺丰富，其中很多都是我感兴趣的，后续有空的话可以继续探索，比如：</p>
<ul>
<li>
<p><strong>简单可扩展的 BSDF 模型</strong></p>
</li>
<li>
<p><strong>基本体积和嵌套介质（支持优先级）</strong></p>
</li>
<li>
<p><strong>支持解析光源（平行光、聚光灯、点光源）、发光三角形和环境贴图</strong></p>
</li>
<li>
<p><strong>基于反馈的时间自适应重要性采样 (NEE)</strong></p>
</li>
<li>
<p><strong>基础路径追踪功能</strong></p>
<ul>
<li>Practical Hash-based Owen Scrambling 低差异样本生成</li>
<li>基于 RayCones 的 MIP 选择、早期光线终止等</li>
</ul>
</li>
<li>
<p><strong>基本光栅化功能</strong></p>
<ul>
<li>基本 TAA、色调映射等</li>
</ul>
</li>
<li>
<p><strong>高级优化</strong></p>
<ul>
<li>Shader Execution Reordering (SER) 提升执行效率</li>
<li>RTXDI 集成 (ReSTIR DI 和 ReSTIR GI)</li>
<li>OMM 集成 (快速 alpha 测试)</li>
<li>NRD ReLAX 和 ReBLUR 去噪（支持三层路径空间分解）</li>
<li>RTXTF 集成 (随机纹理过滤)</li>
<li>Streamline 集成 (DLSS 4.0，包括 SR, AA, FG 和 MFG)</li>
</ul>
</li>
</ul>
<p>这些功能基本覆盖了一个现代路径追踪引擎的各个方面，有机会的话可以逐步深入学习。</p>

      
    </div>
    <footer class="article-footer">
      

      

      

      

      

      

      
      <ul class="article-tag-list" itemprop="keywords">
  
</ul>

    </footer>
  </div>
  
    
  <nav
    id="article-nav"
    data-aos="fade-up"
  >
    
      <div class="article-nav-link-wrap article-nav-link-left">
        
          
          
            <img
              data-src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202412220910158.jpg"
              data-sizes="auto"
              alt="Ultimate Guide to Profiling Unity Games"
              class="lazyload"
            />
          
        
        <a href="https://nothingtosay0031.github.io/post/profilingunity/"></a>
        <div class="article-nav-caption">Newer</div>
        <h3 class="article-nav-title">
          
            Ultimate Guide to Profiling Unity Games
          
        </h3>
      </div>
    

    
      <div class="article-nav-link-wrap article-nav-link-right">
        
          
          
            <img
              data-src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202412220910158.jpg"
              data-sizes="auto"
              alt="Temporal Anti-Aliasing稳定性探究"
              class="lazyload"
            />
          
        
        <a href="https://nothingtosay0031.github.io/post/taa/"></a>
        <div class="article-nav-caption">Older</div>
        <h3 class="article-nav-title">
          
            Temporal Anti-Aliasing稳定性探究
          
        </h3>
      </div>
    
  </nav>


  
</article>










</section>
          
            <aside id="sidebar">
  <div class="sidebar-wrapper wrap-sticky">
    <div
      class="sidebar-wrap"
      data-aos="fade-up"
    >
      
        <div class="sidebar-toc-sidebar">
          <div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#raygen-shader"><code>RayGen</code> Shader</a></li>
    <li><a href="#深入-nexthit-与-firsthitfrombaseplane">深入 <code>nextHit</code> 与 <code>firstHitFromBasePlane</code></a>
      <ul>
        <li><a href="#nexthit驱动光线在场景中持续弹射"><code>nextHit</code>：驱动光线在场景中持续弹射</a></li>
        <li><a href="#firsthitfrombaseplane从稳定平面开始的特殊首次命中"><code>firstHitFromBasePlane</code>：从“稳定平面”开始的特殊首次命中</a></li>
      </ul>
    </li>
    <li><a href="#深入-closesthit-与核心光线命中处理-pathtracerhandlehit">深入 ClosestHit 与核心光线命中处理 PathTracer::HandleHit</a>
      <ul>
        <li><a href="#samplehlsl-中的-closesthit-着色器"><code>Sample.hlsl</code> 中的 <code>ClosestHit</code> 着色器</a>
          <ul>
            <li><a href="#pathtracerhandlehit核心命中处理逻辑"><code>PathTracer::HandleHit</code>：核心命中处理逻辑</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#下一事件估计-nee-详解--handlenee-与光源采样">下一事件估计 (NEE) 详解 —— HandleNEE 与光源采样</a>
      <ul>
        <li><a href="#handleneenee-的主入口与决策点"><code>HandleNEE</code>：NEE 的主入口与决策点</a></li>
        <li><a href="#handlenee_multiplesamples管理多个光源样本"><code>HandleNEE_MultipleSamples</code>：管理多个光源样本</a></li>
        <li><a href="#processlightsample处理单个光源样本"><code>ProcessLightSample</code>：处理单个光源样本</a></li>
        <li><a href="#finalizelightsample最终处理"><code>FinalizeLightSample</code>：最终处理</a></li>
      </ul>
    </li>
    <li><a href="#多重重要性采样-mis-权重详解">多重重要性采样 (MIS) 权重详解</a>
      <ul>
        <li><a href="#1-computeinternalmis为nee样本计算mis权重">1. <code>ComputeInternalMIS</code>：为NEE样本计算MIS权重</a></li>
        <li><a href="#2-computebsdfmis为bsdf命中光源的样本计算mis权重">2. <code>ComputeBSDFMIS</code>：为BSDF命中光源的样本计算MIS权重</a></li>
        <li><a href="#3-computebsdfmisforemissivetriangle针对命中三角形光源的bsdf样本">3. <code>ComputeBSDFMISForEmissiveTriangle</code>：针对命中三角形光源的BSDF样本</a></li>
        <li><a href="#4-computebsdfmisforenvironmentquad针对命中环境四边形光源的bsdf样本">4. <code>ComputeBSDFMISForEnvironmentQuad</code>：针对命中环境四边形光源的BSDF样本</a></li>
      </ul>
    </li>
    <li><a href="#从细节到整体">从细节到整体</a>
      <ul>
        <li><a href="#1-handlehit-函数的行为分析">1. <code>HandleHit</code> 函数的行为分析</a>
          <ul>
            <li><a href="#a-当光线打到不发光的三角形时handlehit-会做什么">a. 当光线打到不发光的三角形时，<code>HandleHit</code> 会做什么？</a></li>
            <li><a href="#b-当光线打到发光的三角形时handlehit-会做什么">b. 当光线打到发光的三角形时，<code>HandleHit</code> 会做什么？</a></li>
          </ul>
        </li>
        <li><a href="#2-nee又做了什么呢">2. NEE又做了什么呢？</a></li>
        <li><a href="#3-nee的bsdf和光源采样的mis-weight有什么特殊的处理吗">3. NEE的BSDF和光源采样的MIS weight有什么特殊的处理吗？</a></li>
        <li><a href="#4-为什么这样是正确的">4. 为什么这样是正确的？</a></li>
      </ul>
    </li>
    <li><a href="#miss-shader揭秘--handlemiss-与环境光处理">Miss Shader揭秘 —— HandleMiss 与环境光处理</a></li>
    <li><a href="#阶段性总结">阶段性总结</a></li>
  </ul>
</nav>
  </div>
</div>
        </div>
        <div class="sidebar-common-sidebar hidden">
          
<div class="sidebar-author">
  <img
    data-src="https://nothingtosay0031.github.io/avatar/../avatar.webp"
    data-sizes="auto"
    alt="NothingToSay0031"
    class="lazyload"
  />
  <div class="sidebar-author-name">NothingToSay0031</div>
  <div class="sidebar-description">又是一个做水果蛋糕的好天气啊！</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div>
    
    <div class="sidebar-state-number">22</div>
  </div>
  <div class="sidebar-state-category">
    <div>Categories</div>
    <div class="sidebar-state-number">
      0
    </div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tags</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-email sidebar-social-icon">
      <a
        href="mailto:jhwzju@gmail.com"
        itemprop="url"
        target="_blank"
        aria-label="email"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-github sidebar-social-icon">
      <a
        href="https://github.com/NothingToSay0031"
        itemprop="url"
        target="_blank"
        aria-label="github"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-linkedin sidebar-social-icon">
      <a
        href="https://www.linkedin.com/in/hongweiji"
        itemprop="url"
        target="_blank"
        aria-label="linkedin"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/"
        aria-label="Home"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Home</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/archives"
        aria-label="Archives"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Archives</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/about"
        aria-label="About"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">About</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/friend"
        aria-label="Friend"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Friend</div>
    </div>
  
</div>

        </div>
      

      
        <div class="sidebar-btn-wrapper" style="position:static">
          <div class="sidebar-toc-btn current"></div>
          <div class="sidebar-common-btn"></div>
        </div>
      
    </div>
  </div>

  
</aside>

          
        </main>
        



  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  



<footer id="footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div id="footer-info">
    <div>
      <span class="icon-copyright"></span>
      2021 -
      2025
      <span class="footer-info-sep rotate"></span>
      NothingToSay0031
    </div>
    
      <div>
        Powered by&nbsp;<a
          href="https://gohugo.io/"
          target="_blank"
          >Hugo</a
        >&nbsp; Theme.<a
          href="https://github.com/D-Sketon/hugo-theme-reimu"
          target="_blank"
          >Reimu</a
        >
      </div>
    
    
      <div>
        <span class="icon-brush"
          >&nbsp;
            55.6k
          </span
        >
        &nbsp;|&nbsp;
        <span class="icon-coffee">&nbsp;
          
          

          04:33
        </span>
      </div>
    
    
    
    
      <div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv"
          >Number of visits&nbsp;<span
            id="busuanzi_value_site_pv"
          ></span
        ></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv"
          >Number of visitors&nbsp;<span
            id="busuanzi_value_site_uv"
          ></span
        ></span>
      </div>
    
  </div>
</footer>

        
          <div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div>
        
        <div id="mask" class="hide"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar">
        <div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#raygen-shader"><code>RayGen</code> Shader</a></li>
    <li><a href="#深入-nexthit-与-firsthitfrombaseplane">深入 <code>nextHit</code> 与 <code>firstHitFromBasePlane</code></a>
      <ul>
        <li><a href="#nexthit驱动光线在场景中持续弹射"><code>nextHit</code>：驱动光线在场景中持续弹射</a></li>
        <li><a href="#firsthitfrombaseplane从稳定平面开始的特殊首次命中"><code>firstHitFromBasePlane</code>：从“稳定平面”开始的特殊首次命中</a></li>
      </ul>
    </li>
    <li><a href="#深入-closesthit-与核心光线命中处理-pathtracerhandlehit">深入 ClosestHit 与核心光线命中处理 PathTracer::HandleHit</a>
      <ul>
        <li><a href="#samplehlsl-中的-closesthit-着色器"><code>Sample.hlsl</code> 中的 <code>ClosestHit</code> 着色器</a>
          <ul>
            <li><a href="#pathtracerhandlehit核心命中处理逻辑"><code>PathTracer::HandleHit</code>：核心命中处理逻辑</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#下一事件估计-nee-详解--handlenee-与光源采样">下一事件估计 (NEE) 详解 —— HandleNEE 与光源采样</a>
      <ul>
        <li><a href="#handleneenee-的主入口与决策点"><code>HandleNEE</code>：NEE 的主入口与决策点</a></li>
        <li><a href="#handlenee_multiplesamples管理多个光源样本"><code>HandleNEE_MultipleSamples</code>：管理多个光源样本</a></li>
        <li><a href="#processlightsample处理单个光源样本"><code>ProcessLightSample</code>：处理单个光源样本</a></li>
        <li><a href="#finalizelightsample最终处理"><code>FinalizeLightSample</code>：最终处理</a></li>
      </ul>
    </li>
    <li><a href="#多重重要性采样-mis-权重详解">多重重要性采样 (MIS) 权重详解</a>
      <ul>
        <li><a href="#1-computeinternalmis为nee样本计算mis权重">1. <code>ComputeInternalMIS</code>：为NEE样本计算MIS权重</a></li>
        <li><a href="#2-computebsdfmis为bsdf命中光源的样本计算mis权重">2. <code>ComputeBSDFMIS</code>：为BSDF命中光源的样本计算MIS权重</a></li>
        <li><a href="#3-computebsdfmisforemissivetriangle针对命中三角形光源的bsdf样本">3. <code>ComputeBSDFMISForEmissiveTriangle</code>：针对命中三角形光源的BSDF样本</a></li>
        <li><a href="#4-computebsdfmisforenvironmentquad针对命中环境四边形光源的bsdf样本">4. <code>ComputeBSDFMISForEnvironmentQuad</code>：针对命中环境四边形光源的BSDF样本</a></li>
      </ul>
    </li>
    <li><a href="#从细节到整体">从细节到整体</a>
      <ul>
        <li><a href="#1-handlehit-函数的行为分析">1. <code>HandleHit</code> 函数的行为分析</a>
          <ul>
            <li><a href="#a-当光线打到不发光的三角形时handlehit-会做什么">a. 当光线打到不发光的三角形时，<code>HandleHit</code> 会做什么？</a></li>
            <li><a href="#b-当光线打到发光的三角形时handlehit-会做什么">b. 当光线打到发光的三角形时，<code>HandleHit</code> 会做什么？</a></li>
          </ul>
        </li>
        <li><a href="#2-nee又做了什么呢">2. NEE又做了什么呢？</a></li>
        <li><a href="#3-nee的bsdf和光源采样的mis-weight有什么特殊的处理吗">3. NEE的BSDF和光源采样的MIS weight有什么特殊的处理吗？</a></li>
        <li><a href="#4-为什么这样是正确的">4. 为什么这样是正确的？</a></li>
      </ul>
    </li>
    <li><a href="#miss-shader揭秘--handlemiss-与环境光处理">Miss Shader揭秘 —— HandleMiss 与环境光处理</a></li>
    <li><a href="#阶段性总结">阶段性总结</a></li>
  </ul>
</nav>
  </div>
</div>
      </div>
      <div class="sidebar-common-sidebar hidden">
        
<div class="sidebar-author">
  <img
    data-src="https://nothingtosay0031.github.io/avatar/../avatar.webp"
    data-sizes="auto"
    alt="NothingToSay0031"
    class="lazyload"
  />
  <div class="sidebar-author-name">NothingToSay0031</div>
  <div class="sidebar-description">又是一个做水果蛋糕的好天气啊！</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div>
    
    <div class="sidebar-state-number">22</div>
  </div>
  <div class="sidebar-state-category">
    <div>Categories</div>
    <div class="sidebar-state-number">
      0
    </div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tags</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-email sidebar-social-icon">
      <a
        href="mailto:jhwzju@gmail.com"
        itemprop="url"
        target="_blank"
        aria-label="email"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-github sidebar-social-icon">
      <a
        href="https://github.com/NothingToSay0031"
        itemprop="url"
        target="_blank"
        aria-label="github"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-linkedin sidebar-social-icon">
      <a
        href="https://www.linkedin.com/in/hongweiji"
        itemprop="url"
        target="_blank"
        aria-label="linkedin"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/"
        aria-label="Home"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Home</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/archives"
        aria-label="Archives"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Archives</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/about"
        aria-label="About"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">About</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/friend"
        aria-label="Friend"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Friend</div>
    </div>
  
</div>

      </div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    
    






  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js"
    
    
    
    
    integrity="sha384-3gT/vsepWkfz/ff7PpWNUeMzeWoH3cDhm/A8jM7ouoAK0/fP/9bcHHR5kHq2nf&#43;e" crossorigin="anonymous"
  ></script>




  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js"
    
    
    
    
    integrity="sha384-J08i8An/QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"
  ></script>









  
      
      <script src="https://nothingtosay0031.github.io/js/main.js" integrity="" crossorigin="anonymous" ></script>
      



  





  
      
      <script src="https://nothingtosay0031.github.io/js/aos.js" integrity="" crossorigin="anonymous" ></script>
      

  <script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", aosInit);
    } else {
      aosInit();
    }
  </script>








  
      
      <script src="https://nothingtosay0031.github.io/js/pjax_main.js" integrity="" crossorigin="anonymous" data-pjax></script>
      





  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/mouse-firework@0.0.6/dist/index.umd.js"
    
    
    
    
    integrity="sha384-vkGvf25gm1C1PbcoD5dNfc137HzNL/hr1RKA5HniJOaawtvUmH5lTVFgFAruE9Ge" crossorigin="anonymous"
  ></script>


<script>
  if (window.firework) {
    const options = JSON.parse("{\"excludeelements\":[\"a\",\"button\"],\"particles\":[{\"colors\":[\"#ff5252\",\"#ff7c7c\",\"#ffafaf\",\"#ffd0d0\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"emit\"],\"number\":20,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.3,0.5],\"radius\":[16,32]}},{\"colors\":[\"#ff0000\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"diffuse\"],\"number\":1,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.2,0.5],\"lineWidth\":6,\"radius\":20}}]}");
    options.excludeElements = options.excludeelements;
    delete options.excludeelements;
    window.firework(options);
  }
</script>








<div id="lazy-script">
  <div>
    
    
      





  
      
      <script src="https://nothingtosay0031.github.io/js/insert_highlight.js" integrity="" crossorigin="anonymous" data-pjax></script>
      

      
      
      
      
      <script type="module" data-pjax>
        const PhotoSwipeLightbox = (await safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe-lightbox.esm.min.js", "sha384-DiL6M\/gG\u002bwmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF\/N6lrZi\/")).default;

        const pswp = () => {
          if (_$$('.article-entry a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-entry',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")
            }).init();
          }
          if(_$$('.article-gallery a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-gallery',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")
            }).init();
          }
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script>
      












    
    
      
        

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/katex@0.16.9/dist/katex.min.js"
    
    
    data-pjax
    
    integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8" crossorigin="anonymous"
  ></script>


        

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/katex@0.16.9/dist/contrib/auto-render.min.js"
    
    
    data-pjax
    
    integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05" crossorigin="anonymous"
  ></script>


        <script data-pjax>
          var renderMath = () => {
            if (!window.renderMathInElement) return;
            window.renderMathInElement(document.body, {
              delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "\\[", right: "\\]", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
              ],
            });
          };
          if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", renderMath, { once: true });
          } else {
            renderMath();
          }
        </script>
      
      
    
  </div>
</div>




  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js"
    
    async
    
    
    integrity="sha384-0M75wtSkhjIInv4coYlaJU83&#43;OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id&#43;S" crossorigin="anonymous"
  ></script>





  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then((registrations) => {
        for (let registration of registrations) {
          registration.unregister();
        }
      });
    }
  </script>


<script>
  const reimuCopyright = String.raw`
   ______     ______     __     __    __     __  __    
  /\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
  \ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
   \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
    \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                    
  `;
  console.log(String.raw`%c ${reimuCopyright}`, "color: #ff5252;");
  console.log(
    "%c Theme.Reimu" + " %c https://github.com/D-Sketon/hugo-theme-reimu ",
    "color: white; background: #ff5252; padding:5px 0;",
    "padding:4px;border:1px solid #ff5252;",
  );
</script>

  </body>
</html>
