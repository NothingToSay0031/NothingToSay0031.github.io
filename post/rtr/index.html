<!doctype html>
<html
  lang="en-us"
  
>
  <head>
    <meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, shrink-to-fit=no"
/>







  

<title>
  Real-Time Rendering | NothingToSay0031
</title>
<meta
  name="description"
  content="Real-Time Rendering, Fourth Edition."
/>










<script>
  window.siteConfig = JSON.parse("{\"anchor_icon\":null,\"clipboard\":{\"copyright\":{\"content\":\"本文版权：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！\",\"count\":50,\"enable\":false},\"fail\":\"复制失败 (ﾟ⊿ﾟ)ﾂ\",\"success\":\"复制成功(*^▽^*)\"},\"code_block\":{\"expand\":true},\"icon_font\":\"4552607_tq6stt6tcg\",\"outdate\":{\"daysago\":180,\"enable\":false,\"message\":\"本文最后更新于 {time}，请注意文中内容可能已经发生变化。\"}}");
</script>











  
  
  
    
  

  
  
  
    
  

  
    

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  rel="preload"
  as="style"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
/>
<link
  rel="stylesheet"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
  media="print"
  onload="this.media='all'"
/>






  <link
    rel="preload"
    href="//at.alicdn.com/t/c/font_4552607_tq6stt6tcg.woff2"
    as="font"
    type="font/woff2"
    crossorigin="anonymous"
  />



  







  
 <link rel="stylesheet" href="https://nothingtosay0031.github.io/css/loader.min.2ad0e9bbffb534e893c0ecefc44787a277cf851387e8ad9dccfbc3a5f0886dbe.css" />




  <meta property="og:type" content="website" />
  <meta property="og:title" content="Real-Time Rendering | NothingToSay0031" />
  <meta
    property="og:description"
    content="Real-Time Rendering, Fourth Edition."
  />
  <meta property="og:url" content="https://nothingtosay0031.github.io/post/rtr/" />
  <meta
    property="og:site_name"
    content="NothingToSay0031"
  />
  <meta
    property="og:image"
    content="/"
  />
  <meta property="article:author" content="NothingToSay0031" />
  <meta property="article:published_time" content="2025-05-28T19:25:47&#43;08:00" />
  <meta property="article:modified_time" content="2025-05-28T19:25:47&#43;08:00" />
  
  
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:image" content="/" />
  
  
  
  
  




<link rel="shortcut icon" href="https://nothingtosay0031.github.io/favicon.ico">








  
 <link rel="stylesheet" href="https://nothingtosay0031.github.io/css/main.min.4e3ed4ec96a449612baa01e942ad2e62fab14c5e1e8f6b3eeb13d1cbc2e0dc67.css" />





  <link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css"
    onload="this.onload=null;this.rel='stylesheet'"
  />






  <link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/katex@0.16.9/dist/katex.min.css"
    onload="this.onload=null;this.rel='stylesheet'"
  />








  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js"
    
    
    
    
    integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"
  ></script>





  


  <link rel="stylesheet" href="https://npm.webcache.cn/@reimujs/aos@0.1.0/dist/aos.css" />




  </head>
  <body>
    
  <div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        
          <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
            <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="#ff5252" />
            <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z 
          M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95z" fill="#ff5252" />
          </svg>
        
      </div>
      <div class="loading-word">少女祈祷中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>


<div id="copy-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
</div>


    <div id="container">
      <div id="wrap">
        
<div id="header-nav">
  <nav id="main-nav">
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/">Home</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/archives">Archives</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/about">About</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/friend">Friend</a>
      </span>
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
    
  </nav>
</div>
<header id="header">
  
    <img fetchpriority="high" src="https://nothingtosay0031.github.io/images/banner.webp" alt="Real-Time Rendering">
  

  <div id="header-outer">
    <div id="header-title">
      
        
        
          
        
  
        
          <a href="https://nothingtosay0031.github.io/" id="logo">
            <h1 data-aos="slide-up">Real-Time Rendering</h1>
          </a>
        
      
  
      
        
        
        <h2 id="subtitle-wrap" data-aos="slide-down">
          
        </h2>
      
    </div>
  </div>
</header>
        <main id="content">
          
          <section id="main">
  <article
  class="h-entry article"
  itemprop="blogPost"
  itemscope
  itemtype="https://schema.org/BlogPosting"
>
  <div
    class="article-inner"
    data-aos="fade-up"
  >
    <div class="article-meta">
      <div class="article-date">
  <a
    href="https://nothingtosay0031.github.io/post/rtr/"
    class="article-date-link"
    data-aos="zoom-in"
  >
    <time datetime="2025-05-28 19:25:47 &#43;0800 CST" itemprop="datePublished"
      >2025-05-28</time
    >
    <time style="display: none;" id="post-update-time"
      >2025-05-28</time
    >
  </a>
</div>

      <div class="article-category">
  
</div>

    </div>
    <div class="hr-line"></div>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
      
        <h1 id="前言-preface">
<a class="header-anchor" href="#%e5%89%8d%e8%a8%80-preface"></a>
前言 (Preface)
</h1><ul>
<li><strong>第四版更新背景</strong>:
<ul>
<li>作者们最初认为过去八年变化不大，更新工作会很简单，但最终耗时一年半，并增加了三位专家。</li>
<li>引用文献的Google Doc已超过170页，每页约20条参考文献和笔记，体现了领域的快速发展和信息丰富性。</li>
<li>许多章节（如阴影）本身就有专门的书籍论述，本书会指向这些主要来源以获取更详细信息。</li>
</ul>
</li>
<li><strong>本书核心内容</strong>:
<ul>
<li>专注于创建合成图像的算法，这些图像生成速度足够快，以便观看者能与虚拟环境互动。</li>
<li>重点是三维渲染，并有限地涉及用户交互机制。</li>
<li>建模、动画等对实时应用很重要的领域超出了本书范围。</li>
</ul>
</li>
<li><strong>目标读者与阅读前提</strong>:
<ul>
<li>期望读者具备计算机图形学的基础知识，以及计算机科学和编程知识。</li>
<li>本书侧重于算法，而非特定的API。</li>
<li>如果某些部分难以理解，建议略读或查阅参考文献。</li>
<li>本书最有价值的服务是让读者意识到自己尚不了解的领域——一个基本概念的核心，他人对此的发现，以及如果愿意，学习更多的方法。</li>
</ul>
</li>
<li><strong>参考文献策略</strong>:
<ul>
<li>尽可能引用相关材料，并在大多数章节末尾提供进一步阅读和资源的总结。</li>
<li>相较于早期版本力求详尽列出所有相关文献，本版更像是一本指南，只描述代表性方案，并用更新、更广泛的综述替代原始来源。</li>
</ul>
</li>
<li><strong>在线资源</strong>:
<ul>
<li>大多数参考文献可通过鼠标点击访问，参见 realtimerendering.com 获取参考文献链接。</li>
<li>网站还包含资源、教程、演示程序、代码示例、软件库、书籍更正等。</li>
</ul>
</li>
<li><strong>作者的目标</strong>:
<ul>
<li>编写一本他们希望自己在初学时拥有的书——既统一又包含入门教材中找不到的细节和参考文献。</li>
</ul>
</li>
<li><strong>致谢 (Acknowledgments for the Fourth Edition)</strong>:
<ul>
<li>感谢众多专业人士的回复和审阅，极大地改进了此版本。</li>
<li>特别感谢 Patrick Cozzi 审阅了本书的每一章。</li>
<li>列出了大量提供帮助的个人姓名，表达感激之情。</li>
</ul>
</li>
<li><strong>致谢 (Acknowledgments for the Third Edition)</strong>:
<ul>
<li>特别感谢ARM、微软、索尼等公司的合作，为图形架构案例研究提供了帮助。</li>
<li>感谢 Natalya Tatarchuk (ATI/AMD)、Wolfgang Engel、Ignacio Castaño (NVIDIA) 等人的大力支持。</li>
<li>感谢章节审阅者和提供其他帮助的众多个人。</li>
<li>感谢 Media Molecule 提供了封面设计的图像和概念。</li>
</ul>
</li>
<li><strong>致谢 (Acknowledgments for the Second Edition)</strong>:
<ul>
<li>感谢主要审阅者，特别是 Cass Everitt (NVIDIA) 和 Jason L. Mitchell (ATI Technologies) 的大量投入。</li>
<li>感谢 Wolfgang Engel 分享了他即将出版的书籍内容。</li>
<li>感谢众多提供图像、资源或审阅部分章节的个人。</li>
</ul>
</li>
<li><strong>致谢 (Acknowledgments for the First Edition)</strong>:
<ul>
<li>感谢审阅部分内容的专家，他们的专业知识显著提升了书的内容和风格。</li>
<li>感谢提供图像、模型、指出重要资源或引荐相关人士的众多贡献者。</li>
</ul>
</li>
</ul>
<h1 id="第一章导论-introduction">
<a class="header-anchor" href="#%e7%ac%ac%e4%b8%80%e7%ab%a0%e5%af%bc%e8%ae%ba-introduction"></a>
第一章：导论 (Introduction)
</h1><ul>
<li><strong>实时渲染的定义</strong>:
<ul>
<li>在计算机上快速生成图像。</li>
<li>计算机图形学中交互性最强的领域。</li>
<li>图像显示 -&gt; 观看者行动/反应 -&gt; 反馈影响下一帧生成 -&gt; 形成动态过程。</li>
</ul>
</li>
<li><strong>关键指标</strong>:
<ul>
<li><strong>帧率 (Frames Per Second, FPS) 或赫兹 (Hertz, Hz)</strong>: 衡量图像显示速率。
<ul>
<li>1 FPS：几乎没有交互感。</li>
<li>约 6 FPS：开始有交互感。</li>
<li>视频游戏目标：30, 60, 72 FPS 或更高，用户专注于动作和反应。</li>
</ul>
</li>
<li><strong>刷新率 (Refresh Rate)</strong>: 与显示率分开（例如电影放映机每帧显示2-4次以避免闪烁，LCD显示器也将刷新率与显示率分开）。</li>
<li><strong>延迟 (Latency)</strong>: 高刷新率对于最小化响应时间很重要。低至15毫秒的时间延迟就会干扰交互。例如，VR头显通常需要90 FPS以最小化延迟。</li>
</ul>
</li>
<li><strong>实时渲染的核心要素</strong>:
<ul>
<li><strong>交互性 (Interactivity)</strong>。</li>
<li><strong>三维图像 (Three-dimensional images)</strong>。</li>
<li><strong>图形加速硬件 (Graphics acceleration hardware)</strong>:
<ul>
<li>1996年 3Dfx Voodoo 1 卡被认为是消费级三维图形的真正开端。</li>
<li>如今，每台计算机、平板电脑和手机都内置图形处理器 (GPU)。</li>
<li>图1.1 (Forza Motorsport 7) 和图1.2 (The Witcher 3) 展示了硬件加速实时渲染的优秀成果。</li>
</ul>
</li>
</ul>
</li>
<li><strong>硬件发展的影响</strong>:
<ul>
<li>推动了交互式计算机图形学研究的爆炸式增长。</li>
</ul>
</li>
<li><strong>本书目标 (针对章节内容)</strong>:
<ul>
<li>提供提高速度和改善图像质量的方法。</li>
<li>描述加速算法和图形API的特性与局限性。</li>
<li>呈现关键概念和术语。</li>
<li>解释领域中最稳健和实用的算法。</li>
<li>提供进一步信息的指引。</li>
</ul>
</li>
</ul>
<h2 id="11-内容概览-contents-overview">
<a class="header-anchor" href="#11-%e5%86%85%e5%ae%b9%e6%a6%82%e8%a7%88-contents-overview"></a>
1.1 内容概览 (Contents Overview)
</h2><ul>
<li><strong>第2章 图形渲染管线 (The Graphics Rendering Pipeline)</strong>: 实时渲染的核心，将场景描述转换成可见图像的步骤。</li>
<li><strong>第3章 图形处理单元 (The Graphics Processing Unit)</strong>: 现代GPU使用固定功能和可编程单元组合实现渲染管线的各个阶段。</li>
<li><strong>第4章 变换 (Transforms)</strong>: 操作对象位置、方向、大小、形状以及相机位置和视图的基本工具。</li>
<li><strong>第5章 着色基础 (Shading Basics)</strong>: 定义材质和光源及其在实现期望表面外观（写实或风格化）中的应用。介绍抗锯齿、透明度和伽马校正等提高图像质量的主题。</li>
<li><strong>第6章 纹理映射 (Texturing)</strong>: 在表面上快速访问和显示图像的强大工具，及其各种应用方法。</li>
<li><strong>第7章 阴影 (Shadows)</strong>: 为场景添加阴影以增加真实感和可理解性。介绍流行的快速计算阴影算法。</li>
<li><strong>第8章 光与颜色 (Light and Color)</strong>: 在进行基于物理的渲染之前，理解如何量化光和颜色。渲染后，将结果转换为显示值，考虑屏幕和观看环境的属性。</li>
<li><strong>第9章 基于物理的着色 (Physically Based Shading)</strong>: 从基础物理现象开始构建基于物理的着色模型，涵盖各种渲染材质的模型，以及材质混合与滤波方法。</li>
<li><strong>第10章 局部光照 (Local Illumination)</strong>: 探索更复杂光源的算法，表面着色考虑光由具有特定形状的物理对象发出。</li>
<li><strong>第11章 全局光照 (Global Illumination)</strong>: 模拟光与场景多次交互的算法，进一步提高图像真实感。讨论环境光遮蔽、方向性遮蔽，以及漫反射和镜面反射表面的全局光照效果渲染方法。</li>
<li><strong>第12章 图像空间效果 (Image-Space Effects)</strong>: 图形硬件擅长快速执行图像处理。讨论图像滤波和重投影技术，以及镜头光晕、运动模糊和景深等后期处理效果。</li>
<li><strong>第13章 超越多边形 (Beyond Polygons)</strong>: 讨论基于图像、点云、体素等替代表示方法的优势。</li>
<li><strong>第14章 体积与半透明渲染 (Volumetric and Translucency Rendering)</strong>: 体积材质表示理论与实践及其与光源的相互作用，从大规模大气效果到细小毛发内的光散射。</li>
<li><strong>第15章 非真实感渲染 (Non-Photorealistic Rendering)</strong>: 渲染场景的非写实风格，如卡通着色和水彩效果，以及线条和文本生成技术。</li>
<li><strong>第16章 多边形技术 (Polygonal Techniques)</strong>: 几何数据的来源与修改，多边形数据表示和压缩的多个方面。</li>
<li><strong>第17章 曲线与曲面 (Curves and Curved Surfaces)</strong>: 更复杂表面表示的优势，如质量与渲染速度的权衡、更紧凑的表示和平滑表面生成。</li>
<li><strong>第18章 管线优化 (Pipeline Optimization)</strong>: 通过各种优化技术提高已运行应用的性能，找到瓶颈并决定如何处理，以及多重处理。</li>
<li><strong>第19章 加速算法 (Acceleration Algorithms)</strong>: 各种形式的剔除和细节层次 (LOD) 渲染。</li>
<li><strong>第20章 高效着色 (Efficient Shading)</strong>: 处理大量光源带来的性能问题，以及避免对不可见表面片元进行完全着色的方法。</li>
<li><strong>第21章 虚拟与增强现实 (Virtual and Augmented Reality)</strong>: 这些领域在高效生成快速且一致速率的真实感图像方面的特定挑战和技术。</li>
<li><strong>第22章 相交测试方法 (Intersection Test Methods)</strong>: 渲染、用户交互和碰撞检测中重要的相交测试，提供常见几何相交测试的高效算法。</li>
<li><strong>第23章 图形硬件 (Graphics Hardware)</strong>: 颜色深度、帧缓冲和基本架构类型等组件，以及代表性GPU的案例研究。</li>
<li><strong>第24章 未来 (The Future)</strong>: 作者的展望。</li>
<li><strong>额外内容</strong>: 关于碰撞检测的章节以及线性代数和三角函数的附录可在 realtimerendering.com 免费下载。</li>
</ul>
<h2 id="12-符号和定义-notation-and-definitions">
<a class="header-anchor" href="#12-%e7%ac%a6%e5%8f%b7%e5%92%8c%e5%ae%9a%e4%b9%89-notation-and-definitions"></a>
1.2 符号和定义 (Notation and Definitions)
</h2><ul>
<li>
<p><strong>1.2.1 数学符号 (Mathematical Notation)</strong>:</p>
<ul>
<li><strong>表格 1.1 符号总结</strong>:
<ul>
<li>角度 (angle): 小写希腊字母 (如 $\alpha_i, \phi, \theta$)</li>
<li>标量 (scalar): 小写斜体字母 (如 $a, b, t, u_k$)</li>
<li>向量或点 (vector or point): 小写粗体字母 (如 $\mathbf{a}, \mathbf{u}, \mathbf{v}_s$)</li>
<li>矩阵 (matrix): 大写粗体字母 (如 $\mathbf{T(t)}, \mathbf{X}, \mathbf{R}_x(\rho)$)</li>
<li>平面 (plane): $\pi: \mathbf{n} \cdot \mathbf{x} + d = 0$ (一个向量和一个标量)</li>
<li>三角形 (triangle): $\triangle \mathbf{v}_0 \mathbf{v}_1 \mathbf{v}_2$ (3个点)</li>
<li>线段 (line segment): $\mathbf{uv}, \mathbf{a}_i \mathbf{b}_j$ (两点)</li>
<li>几何实体 (geometric entity): 大写斜体字母 (如 $A_{OBB}, T, B_{AABB}$)</li>
</ul>
</li>
<li><strong>向量与点</strong>:
<ul>
<li>列向量格式，如 $\mathbf{v} = (v_x, v_y, v_z)^T$。有时文本中使用 $(v_x, v_y, v_z)$ 代替 $(v_x \ v_y \ v_z)^T$ 以方便阅读。</li>
<li>齐次坐标：向量 $\mathbf{v} = (v_x, v_y, v_z, 0)^T$，点 $\mathbf{v} = (v_x, v_y, v_z, 1)^T$。</li>
<li>有时使用数字索引，如 $\mathbf{v} = (v_0, v_1, v_2)^T$。</li>
</ul>
</li>
<li><strong>矩阵</strong>:
<ul>
<li>常用尺寸 $2 \times 2, 3 \times 3, 4 \times 4$。</li>
<li>元素表示 $m_{ij}$ (i表示行，j表示列)，如 $M = \begin{pmatrix} m_{00} & m_{01} & m_{02} \\ m_{10} & m_{11} & m_{12} \\ m_{20} & m_{21} & m_{22} \end{pmatrix}$。</li>
<li>$\mathbf{m}_{,j}$ 表示第 $j$ 列向量，$\mathbf{m}_{i,}$ 表示第 $i$ 行向量（以列向量形式）。</li>
</ul>
</li>
<li><strong>平面</strong>:
<ul>
<li>$\pi: \mathbf{n} \cdot \mathbf{x} + d = 0$，其中 $\mathbf{n}$ 是平面法向量，$d$ 是标量。</li>
<li>平面将空间分为正半空间 ($\mathbf{n} \cdot \mathbf{x} + d > 0$) 和负半空间 ($\mathbf{n} \cdot \mathbf{x} + d < 0$) 。</li>
</ul>
</li>
<li><strong>三角形</strong>:
<ul>
<li>由三个点 $\mathbf{v}_0, \mathbf{v}_1, \mathbf{v}_2$ 定义，表示为 $\triangle \mathbf{v}_0 \mathbf{v}_1 \mathbf{v}_2$。</li>
</ul>
</li>
<li><strong>表格 1.2 数学运算符</strong>:
<ul>
<li>$\cdot$: 点积 (dot product)</li>
<li>$\times$: 叉积 (cross product)</li>
<li>$\mathbf{v}^T$: 向量 $\mathbf{v}$ 的转置 (transpose)</li>
<li>$\mathbf{v}^\perp$:二维向量的垂直向量，若 $\mathbf{v} = (v_x, v_y)^T$，则 $\mathbf{v}^\perp = (-v_y, v_x)^T$ (perp dot product operator)</li>
<li>$|\mathbf{A}|$: 矩阵的行列式 (determinant)</li>
<li>$|a|$: 标量的绝对值 (absolute value)</li>
<li>$\|\cdot\|$: 参数的长度或范数 (length or norm)</li>
<li>$x^+$: 将 $x$ 限制到0或更大 ($x^+ = \max(x, 0)$)</li>
<li>$\lfloor x \rfloor^+$ (书中符号为带下标的 $x^+$): 将 $x$ 限制在 $[0, 1]$ 区间 ($x^+ = \min(\max(x,0),1)$ )</li>
<li>$n!$: 阶乘 ($n(n-1)\dots1$, $0!=1$)</li>
<li>$\binom{n}{k}$: 二项式系数 ($n! / (k!(n-k)!)$)</li>
</ul>
</li>
<li><strong>表格 1.3 特殊数学函数</strong>:
<ul>
<li>$\text{atan2}(y, x)$: 双参数反正切，值域 $[0, 2\pi)$，处理 $x=0$ 的情况。</li>
<li>$\log(n)$: 自然对数 ($\ln(n)$ 或 $\log_e(n)$)。</li>
</ul>
</li>
<li><strong>其他约定</strong>:
<ul>
<li>坐标系：右手坐标系。</li>
<li>颜色：三元素向量 (红, 绿, 蓝)，各分量范围 $[0, 1]$。</li>
<li>区间表示：$[a, b]$ (包含a,b)，$(a, b)$ (不包含a,b)，$[a, b)$ (包含a,不包含b)。</li>
<li>坐标平面：$x=0, y=0, z=0$ 平面。</li>
<li>主轴/主方向：$\mathbf{e}_x=(1,0,0)^T, \mathbf{e}_y=(0,1,0)^T, \mathbf{e}_z=(0,0,1)^T$。</li>
<li>除非另有说明，使用标准正交基。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>1.2.2 几何定义 (Geometrical Definitions)</strong>:</p>
<ul>
<li><strong>基本渲染图元 (rendering primitives)</strong>: 点、线、三角形 (几乎所有图形硬件使用)。</li>
<li><strong>模型 (model) / 对象 (object)</strong>: 几何实体的集合。可以是图元的集合，也可以是更高级的几何表示 (如贝塞尔曲线/曲面、细分曲面)。对象可以包含其他对象 (层次结构)。</li>
<li><strong>场景 (scene)</strong>: 构成待渲染环境的所有模型的集合，也可包括材质描述、光照和视图规格。</li>
</ul>
</li>
<li>
<p><strong>1.2.3 着色 (Shading)</strong>:</p>
<ul>
<li>&ldquo;Shading&rdquo;, &ldquo;shader&rdquo; 等词具有两个相关但不同的含义：
<ol>
<li>计算机生成的视觉外观 (例如：“着色模型 (shading model)”，“着色方程 (shading equation)”，“卡通着色 (toon shading)”)。</li>
<li>渲染系统的可编程组件 (例如：“顶点着色器 (vertex shader)”，“着色语言 (shading language)”)。</li>
</ol>
</li>
<li>具体含义应从上下文中明确。</li>
</ul>
</li>
<li>
<p><strong>进一步阅读和资源 (Further Reading and Resources)</strong>:</p>
<ul>
<li>最重要的资源是本书的网站：realtimerendering.com。</li>
<li>网站包含与每章相关的最新信息和网站链接。</li>
<li>本书侧重于基础概念和不太可能过时的技术，网站则提供与当今软件开发者相关且保持更新的信息。</li>
</ul>
</li>
</ul>
<h1 id="第二章-图形渲染管线-the-graphics-rendering-pipeline">
<a class="header-anchor" href="#%e7%ac%ac%e4%ba%8c%e7%ab%a0-%e5%9b%be%e5%bd%a2%e6%b8%b2%e6%9f%93%e7%ae%a1%e7%ba%bf-the-graphics-rendering-pipeline"></a>
第二章 图形渲染管线 (The Graphics Rendering Pipeline)
</h1><p>“链条的强度取决于其最薄弱的环节。”</p>
<p>本章介绍实时图形学的核心组件——图形渲染管线（简称“管线”）。其主要功能是根据虚拟相机、三维物体、光源等信息生成（渲染）一张二维图像。</p>
<ul>
<li><strong>管线核心功能</strong>：输入虚拟相机、三维物体、光源等，输出二维图像。</li>
<li><strong>图像内容决定因素</strong>：
<ul>
<li><strong>几何形状 (Geometry)</strong>：物体在图像中的位置和形状。</li>
<li><strong>环境特性 (Environment Characteristics)</strong>：影响物体渲染。</li>
<li><strong>相机位置 (Camera Placement)</strong>：决定观察视角。</li>
</ul>
</li>
<li><strong>物体外观影响因素</strong>：
<ul>
<li><strong>材质属性 (Material Properties)</strong></li>
<li><strong>光源 (Light Sources)</strong></li>
<li><strong>纹理 (Textures)</strong>：应用到物体表面的图像。</li>
<li><strong>着色方程 (Shading Equations)</strong></li>
</ul>
</li>
<li><strong>视体 (View Volume)</strong>：
<ul>
<li>只有位于视体内的图元才会被渲染。</li>
<li>透视投影中，视体是一个平截头体（frustum，即被截断的棱锥，底面为矩形）。</li>
<li>图2.1示例：红色甜甜圈因在视锥外而未被渲染，蓝色扭曲棱柱被视锥顶部平面裁剪。</li>
</ul>
</li>
</ul>
<h2 id="21-架构-architecture">
<a class="header-anchor" href="#21-%e6%9e%b6%e6%9e%84-architecture"></a>
2.1 架构 (Architecture)
</h2><ul>
<li><strong>流水线概念</strong>：将一个大任务分解为多个阶段，各阶段并行执行，但每个阶段依赖于前一阶段的结果。如同工厂装配线或快餐厨房。</li>
<li><strong>性能提升</strong>：流水线的主要目的是提高性能。理想情况下，一个n级流水线系统能提供n倍的加速。</li>
<li><strong>瓶颈 (Bottleneck)</strong>：流水线的整体速度取决于最慢的那个阶段。</li>
<li><strong>饥饿 (Starved)</strong>：较快的阶段等待较慢阶段完成任务的状态。</li>
<li><strong>实时渲染管线的四个主要阶段</strong> (图2.2)：
<ol>
<li><strong>应用阶段 (Application Stage)</strong></li>
<li><strong>几何处理阶段 (Geometry Processing Stage)</strong></li>
<li><strong>光栅化阶段 (Rasterization Stage)</strong></li>
<li><strong>像素处理阶段 (Pixel Processing Stage)</strong></li>
</ol>
</li>
<li><strong>阶段的实现</strong>：
<ul>
<li>每个主要阶段本身也可能是一个流水线。</li>
<li>一个功能阶段（定义任务）的具体实现可能将多个功能阶段合并，或将一个耗时阶段细分为多个硬件单元，或使用可编程核心执行。</li>
</ul>
</li>
<li><strong>渲染速度衡量</strong>：
<ul>
<li><strong>FPS (Frames Per Second)</strong>：每秒渲染的图像数量。</li>
<li><strong>Hz (Hertz)</strong>：更新频率 (1/秒)，常用于描述显示器等硬件。</li>
<li><strong>毫秒 (ms)</strong>：渲染单帧图像所需时间。</li>
</ul>
</li>
<li><strong>各阶段简介</strong>：
<ul>
<li><strong>应用阶段</strong>：由应用程序驱动，通常在CPU上以软件实现。任务包括碰撞检测、全局加速算法、动画、物理模拟等。</li>
<li><strong>几何处理阶段</strong>：处理变换、投影及所有几何操作。计算绘制内容、方式和位置。通常在GPU上执行。</li>
<li><strong>光栅化阶段</strong>：输入通常是构成三角形的三个顶点，找出所有被该三角形覆盖的像素，并传递给下一阶段。在GPU上执行。</li>
<li><strong>像素处理阶段</strong>：对每个像素执行一个程序来确定其颜色，可能执行深度测试判断可见性，或将新颜色与先前颜色混合。在GPU上执行。</li>
</ul>
</li>
</ul>
<h2 id="22-应用阶段-the-application-stage">
<a class="header-anchor" href="#22-%e5%ba%94%e7%94%a8%e9%98%b6%e6%ae%b5-the-application-stage"></a>
2.2 应用阶段 (The Application Stage)
</h2><ul>
<li><strong>开发者控制</strong>：开发者对应用阶段有完全控制权，因其通常在CPU上执行。可以修改以提升性能，这些改变也会影响后续阶段。</li>
<li><strong>GPU上的应用任务</strong>：GPU可通过一种称为<strong>计算着色器 (compute shader)</strong> 的独立模式执行部分应用层工作，此时GPU被视为高度并行的通用处理器。</li>
<li><strong>核心任务</strong>：在应用阶段结束时，将要渲染的几何数据（渲染图元，即点、线、三角形）喂给几何处理阶段。</li>
<li><strong>并行性</strong>：为提高性能，此阶段常在多个CPU核心上并行执行（超标量结构），而非细分为子流水线阶段。</li>
<li><strong>常见任务</strong>：
<ul>
<li><strong>碰撞检测 (Collision Detection)</strong>：检测物体间碰撞并生成响应。</li>
<li><strong>输入处理</strong>：处理键盘、鼠标、头戴显示器等输入。</li>
<li><strong>加速算法</strong>：如特定的剔除算法（第19章）。</li>
<li>其他管线无法处理的任务。</li>
</ul>
</li>
</ul>
<h2 id="23-几何处理阶段-geometry-processing">
<a class="header-anchor" href="#23-%e5%87%a0%e4%bd%95%e5%a4%84%e7%90%86%e9%98%b6%e6%ae%b5-geometry-processing"></a>
2.3 几何处理阶段 (Geometry Processing)
</h2><ul>
<li>
<p><strong>GPU负责</strong>：在GPU上进行，负责大部分逐三角形和逐顶点操作。</p>
</li>
<li>
<p><strong>功能子阶段</strong> (图2.3)：</p>
<ol>
<li><strong>顶点着色 (Vertex Shading)</strong></li>
<li><strong>投影 (Projection)</strong></li>
<li><strong>裁剪 (Clipping)</strong></li>
<li><strong>屏幕映射 (Screen Mapping)</strong></li>
</ol>
<p><strong>2.3.1 顶点着色 (Vertex Shading)</strong></p>
<ul>
<li><strong>两大任务</strong>：
<ol>
<li>计算顶点的位置。</li>
<li>评估程序员希望输出的任何顶点数据，如法线和纹理坐标。</li>
</ol>
</li>
<li><strong>历史命名原因</strong>：传统上，大部分物体明暗效果是通过对每个顶点的位置和法线应用光照计算，并将结果颜色存储在顶点上，然后在三角形内部插值这些颜色。因此这个可编程顶点处理单元被称为顶点着色器。</li>
<li><strong>现代GPU中的顶点着色</strong>：更为通用，可能不进行任何光照计算，具体取决于程序员的意图。它是一个用于设置与每个顶点相关数据的通用单元（例如，可用于第4.4和4.5节中的对象动画）。</li>
<li><strong>坐标空间变换</strong>：
<ul>
<li><strong>模型空间 (Model Space)</strong>：物体未经变换的初始坐标。</li>
<li><strong>模型变换 (Model Transform)</strong>：将模型顶点和法线从模型空间变换到世界空间，允许模型定位、定向和缩放。</li>
<li><strong>实例 (Instances)</strong>：同一模型可以通过多个不同的模型变换在场景中以不同位置、方向和大小出现多次，而无需复制基础几何体。</li>
<li><strong>世界空间 (World Space / World Coordinates)</strong>：所有模型经过各自的模型变换后所在的统一空间。</li>
<li><strong>视图变换 (View Transform)</strong>：将相机和所有模型进行变换，目的是将相机置于原点，使其朝向负z轴方向，y轴指向上方，x轴指向右方（此为一种常见约定，如OpenGL）。
<ul>
<li>这样做是为了简化后续的投影和裁剪操作。</li>
</ul>
</li>
<li><strong>相机空间 (Camera Space) / 视图空间 (View Space) / 观察空间 (Eye Space)</strong>：经过视图变换后的空间。</li>
<li>模型变换和视图变换通常可以用4x4矩阵实现（第四章）。</li>
</ul>
</li>
<li><strong>着色计算 (Shading)</strong>：
<ul>
<li>决定光照对材质的影响。</li>
<li>涉及在物体表面不同点计算着色方程。</li>
<li>部分计算在几何处理阶段对模型顶点进行，其他可能在逐像素处理阶段进行。</li>
<li>顶点数据（位置、法线、颜色等）被传递到光栅化和像素处理阶段，用于插值和计算表面着色。</li>
</ul>
</li>
<li><strong>投影 (Projection)</strong>：
<ul>
<li>在顶点着色阶段执行，将视体变换为一个<strong>单位立方体 (unit cube)</strong>，也称为<strong>规范视体 (canonical view volume)</strong>。其极值点通常是 <code>(-1, -1, -1)</code> 到 <code>(1, 1, 1)</code>，但也可能使用其他范围如z轴的 <code>[0, 1]</code>。</li>
<li><strong>两种常用投影方法</strong> (图2.5)：
<ol>
<li><strong>正交投影 (Orthographic Projection)</strong> (也叫平行投影)：
<ul>
<li>视体通常是一个矩形盒。</li>
<li>平行线在变换后仍然平行。</li>
<li>变换由平移和缩放组成。</li>
</ul>
</li>
<li><strong>透视投影 (Perspective Projection)</strong>：
<ul>
<li>物体离相机越远，投影后显得越小。</li>
<li>平行线可能在地平线处汇聚。</li>
<li>视体是一个<strong>平截头体 (frustum)</strong>。</li>
</ul>
</li>
</ol>
</li>
<li>投影用矩阵表示（4.7节），有时会与其余几何变换矩阵级联。</li>
<li>变换后的模型坐标称为<strong>裁剪坐标 (clip coordinates)</strong>，是齐次坐标，发生在除以w之前。GPU的顶点着色器必须输出这种类型的坐标。</li>
<li>虽然这些矩阵是体积到体积的变换，但称为“投影”是因为最终显示时，z坐标不存储在生成的图像中，而是存储在z缓冲中（2.5节），从而将模型从三维投影到二维。</li>
</ul>
</li>
</ul>
<p><strong>2.3.2 可选的顶点处理 (Optional Vertex Processing)</strong>
这些阶段在GPU上按顺序执行：曲面细分、几何着色、流输出。它们相互独立，通常不常用。</p>
<ul>
<li><strong>曲面细分 (Tessellation)</strong>：
<ul>
<li>解决问题：固定数量三角形的模型在近看时可能显露棱角，远看时又浪费性能。</li>
<li>功能：根据需要（如与相机的距离）动态生成曲面上的三角形数量。近处多，远处少。</li>
<li>处理对象：由一组面片（patch）描述的曲面，每个面片由一组顶点构成。</li>
<li>过程：包含一系列子阶段——外壳着色器 (hull shader)、镶嵌器 (tessellator)、域着色器 (domain shader)——将面片顶点集转换为（通常）更大的顶点集，用于生成新的三角形。</li>
</ul>
</li>
<li><strong>几何着色器 (Geometry Shader)</strong>：
<ul>
<li>出现早于曲面细分着色器，因此更常见。</li>
<li>功能：输入各种图元，可以产生新的顶点。创建范围和输出图元类型比曲面细分受限。</li>
<li>流行用途之一：粒子生成（例如，将一个点（单个顶点）转换为面向观察者的方形（由两个三角形构成），用于模拟烟花）。</li>
</ul>
</li>
<li><strong>流输出 (Stream Output)</strong>：
<ul>
<li>功能：允许将GPU用作几何引擎。可以将处理后的顶点输出到一个数组中供后续处理（CPU或GPU在之后的pass中使用），而不是发送到管线的其余部分进行屏幕渲染。</li>
<li>典型用途：粒子模拟（如烟花示例）。</li>
</ul>
</li>
</ul>
<p><strong>2.3.3 裁剪 (Clipping)</strong></p>
<ul>
<li>目的：只有完全或部分在视体内的图元需要传递给光栅化阶段。</li>
<li>处理方式：
<ul>
<li>完全在视体内的图元：原样传递。</li>
<li>完全在视体外的图元：不传递（丢弃）。</li>
<li>部分在视体内的图元：需要裁剪。例如，一条线段一个顶点在内一个在外，则外面的顶点被替换为线段与视体边界的交点。</li>
</ul>
</li>
<li><strong>裁剪空间</strong>：通过投影矩阵，原始图元被变换到单位立方体空间，裁剪操作是针对这个单位立方体进行的 (图2.6)。这使得裁剪问题保持一致性。</li>
<li><strong>用户定义裁剪平面</strong>：除了视体的六个裁剪平面，用户可以定义额外的裁剪平面来实现可见的物体切割效果（剖面图，如图19.1）。</li>
<li><strong>齐次坐标</strong>：裁剪步骤使用投影产生的4值齐次坐标。第四个坐标w对于透视投影下数据的正确插值和裁剪至关重要。</li>
<li><strong>透视除法 (Perspective Division)</strong>：裁剪后进行，将结果三角形的位置放入三维<strong>归一化设备坐标 (Normalized Device Coordinates, NDC)</strong>。如前述，此视体范围从<code>(-1, -1, -1)</code>到<code>(1, 1, 1)</code>。</li>
</ul>
<p><strong>2.3.4 屏幕映射 (Screen Mapping)</strong></p>
<ul>
<li>输入：位于单位立方体内的（裁剪后的）图元，坐标仍为三维。</li>
<li>功能：将每个图元的x和y坐标进行变换，形成<strong>屏幕坐标 (Screen Coordinates)</strong>。屏幕坐标连同z坐标一起也称为<strong>窗口坐标 (Window Coordinates)</strong>。</li>
<li>变换过程：假设场景渲染到一个窗口，最小角点<code>(x1, y1)</code>，最大角点<code>(x2, y2)</code>（<code>x1 &lt; x2</code>, <code>y1 &lt; y2</code>）。屏幕映射是一个平移后接一个缩放操作。</li>
<li><strong>Z坐标映射</strong>：z坐标（OpenGL为<code>[-1, +1]</code>，DirectX为<code>[0, 1]</code>）也被映射到<code>[z1, z2]</code>，默认值为<code>z1=0, z2=1</code>。这些可以通过API更改。</li>
<li>输出：窗口坐标（包含重新映射的z值）传递给光栅化阶段 (图2.7)。</li>
<li><strong>像素坐标与浮点坐标关系</strong>：
<ul>
<li>对于水平像素数组，最左侧像素的左边缘为浮点坐标0.0 (OpenGL, DirectX 10+)。</li>
<li>该像素中心为0.5。</li>
<li>像素范围 <code>[0, 9]</code> 覆盖浮点范围 <code>[0.0, 10.0)</code>。</li>
<li>转换公式：<code>d = floor(c)</code> (d为离散整数索引, c为连续浮点值), <code>c = d + 0.5</code>。</li>
</ul>
</li>
<li><strong>API间坐标系差异</strong>：
<ul>
<li>水平方向：所有API像素位置值从左到右增加。</li>
<li>垂直方向：OpenGL通常将左下角视为值最低的元素（笛卡尔坐标系）；DirectX有时根据上下文将左上角定义为值最低的元素。例如，OpenGL中图像的(0,0)在左下角，DirectX中在左上角。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="24-光栅化-rasterization">
<a class="header-anchor" href="#24-%e5%85%89%e6%a0%85%e5%8c%96-rasterization"></a>
2.4 光栅化 (Rasterization)
</h2><ul>
<li>
<p><strong>目标</strong>：给定变换和投影后的顶点及其关联的着色数据，找出所有位于被渲染图元（如三角形）内部的像素（pixel，picture elements的缩写）。</p>
</li>
<li>
<p><strong>两个功能子阶段</strong> (图2.8左)：</p>
<ol>
<li><strong>三角形设置 (Triangle Setup)</strong> (也称图元组装 Primitive Assembly)</li>
<li><strong>三角形遍历 (Triangle Traversal)</strong></li>
</ol>
<ul>
<li>这些阶段也能处理点和线，但因三角形最常用而以此命名。</li>
</ul>
</li>
<li>
<p><strong>也称扫描转换 (Scan Conversion)</strong>：将屏幕空间中的二维顶点（每个顶点带有一个z值/深度值和各种着色信息）转换为屏幕上的像素。</p>
</li>
<li>
<p><strong>同步点</strong>：光栅化可视为几何处理和像素处理之间的同步点，在此处由三个顶点形成三角形，并最终发送到像素处理。</p>
</li>
<li>
<p><strong>像素与三角形重叠判断</strong>：</p>
<ul>
<li><strong>点采样 (Point Sampling)</strong>：最简单的是使用每个像素中心的一个采样点，若中心点在三角形内，则像素被认为在三角形内。</li>
<li><strong>超级采样/多重采样抗锯齿 (Supersampling/Multisampling Antialiasing)</strong>：每像素使用多个采样点（5.4.2节）。</li>
<li><strong>保守光栅化 (Conservative Rasterization)</strong>：如果像素的至少一部分与三角形重叠，则该像素被认为“在”三角形内（23.1.2节）。</li>
</ul>
<p><strong>2.4.1 三角形设置 (Triangle Setup)</strong></p>
<ul>
<li><strong>功能</strong>：计算三角形的微分、边方程和其他数据。</li>
<li><strong>用途</strong>：这些数据用于三角形遍历（2.4.2节）以及插值几何阶段产生的各种着色数据。</li>
<li><strong>实现</strong>：使用固定功能硬件。</li>
</ul>
<p><strong>2.4.2 三角形遍历 (Triangle Traversal)</strong></p>
<ul>
<li><strong>功能</strong>：检查每个其中心（或采样点）被三角形覆盖的像素，并为与三角形重叠的像素部分生成一个<strong>片元 (fragment)</strong>。</li>
<li><strong>片元属性生成</strong>：通过在三个三角形顶点间插值数据（第五章）来生成每个三角形片元的属性。包括片元的深度以及来自几何阶段的任何着色数据。</li>
<li><strong>透视校正插值 (Perspective-Correct Interpolation)</strong>：在此处执行（694, 23.1.1节）。</li>
<li><strong>输出</strong>：所有位于图元内部的像素或采样点（作为片元）被发送到像素处理阶段。</li>
</ul>
</li>
</ul>
<h2 id="25-像素处理-pixel-processing">
<a class="header-anchor" href="#25-%e5%83%8f%e7%b4%a0%e5%a4%84%e7%90%86-pixel-processing"></a>
2.5 像素处理 (Pixel Processing)
</h2><ul>
<li>
<p>此阶段对位于图元内部的像素或采样点（片元）执行逐像素或逐样本的计算和操作。</p>
</li>
<li>
<p><strong>两个功能子阶段</strong> (图2.8右)：</p>
<ol>
<li><strong>像素着色 (Pixel Shading)</strong></li>
<li><strong>合并 (Merging)</strong></li>
</ol>
<p><strong>2.5.1 像素着色 (Pixel Shading)</strong></p>
<ul>
<li><strong>功能</strong>：使用插值后的着色数据执行任何逐像素的着色计算。</li>
<li><strong>输出</strong>：一个或多个颜色，传递给下一阶段。</li>
<li><strong>实现</strong>：由可编程GPU核心执行。程序员提供<strong>像素着色器 (pixel shader)</strong> 程序（在OpenGL中称为<strong>片元着色器 (fragment shader)</strong>）。</li>
<li><strong>重要技术：纹理映射 (Texturing)</strong> (第六章)：将一个或多个图像“粘贴”到物体上，以达到各种目的 (图2.9示例)。图像可以是一维、二维或三维，二维最常见。</li>
</ul>
<p><strong>2.5.2 合并 (Merging)</strong></p>
<ul>
<li><strong>颜色缓冲 (Color Buffer)</strong>：存储每个像素颜色信息（红、绿、蓝分量）的矩形数组。</li>
<li><strong>合并阶段责任</strong>：将像素着色阶段产生的片元颜色与当前存储在缓冲区中的颜色组合起来。</li>
<li><strong>也称 ROP</strong>：代表“光栅操作（管线）(Raster Operations Pipeline)”或“渲染输出单元 (Render Output Unit)”。</li>
<li><strong>实现</strong>：执行此阶段的GPU子单元通常不是完全可编程的，但高度可配置，可实现各种效果。</li>
<li><strong>可见性解析 (Visibility Resolution)</strong>：
<ul>
<li><strong>Z缓冲 (Z-buffer / Depth Buffer) 算法</strong> [238]：
<ul>
<li>与颜色缓冲同样大小和形状，为每个像素存储到当前最近图元的z值。</li>
<li>渲染图元到某像素时，计算该图元在该像素的z值，并与Z缓冲中对应像素的z值比较。</li>
<li>如果新z值更小，则该图元更近，更新该像素的z值和颜色。</li>
<li>如果新z值更大，则颜色缓冲和Z缓冲保持不变。</li>
<li>优点：简单，O(n)收敛（n为图元数量），适用于任何可计算z值的图元，允许大多数图元以任意顺序渲染。</li>
<li>缺点：Z缓冲只存储每个点单个深度，不能用于半透明图元。半透明图元必须在所有不透明图元之后，按从后到前顺序渲染，或使用独立的顺序无关算法（5.5节）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>其他缓冲和通道</strong>：
<ul>
<li><strong>Alpha通道 (Alpha Channel)</strong>：与颜色缓冲关联，存储每个像素相关的不透明度值（5.5节）。</li>
<li><strong>Alpha测试 (Alpha Test)</strong> (旧API)：曾用于选择性丢弃像素。</li>
<li><strong>Discard操作</strong> (现代像素着色器)：可在像素着色器程序中插入，根据任意计算触发丢弃。可确保完全透明的片元不影响Z缓冲（6.6节）。</li>
<li><strong>模板缓冲 (Stencil Buffer)</strong>：一个离屏缓冲，用于记录渲染图元的位置，通常每像素8位。
<ul>
<li>图元可以使用各种函数渲染到模板缓冲，然后其内容可用于控制对颜色缓冲和Z缓冲的渲染。</li>
<li>例如，在模板缓冲中绘制一个填充圆形，然后设置操作符仅允许在圆形区域内渲染后续图元到颜色缓冲。</li>
</ul>
</li>
</ul>
</li>
<li><strong>光栅操作 (ROP) / 混合操作 (Blend Operations)</strong>：在管线末端进行的这些功能。可以将颜色缓冲中当前的颜色与正在处理的三角形内部像素的颜色混合，以实现透明度或颜色样本累积等效果。
<ul>
<li>混合通常通过API进行配置，而非完全可编程。但某些API支持<strong>光栅顺序视图 (Raster Order Views)</strong> 或 <strong>像素着色器排序 (Pixel Shader Ordering)</strong>，可实现可编程混合功能。</li>
</ul>
</li>
<li><strong>帧缓冲 (Framebuffer)</strong>：通常指系统上所有缓冲区的总称。</li>
<li><strong>双缓冲 (Double Buffering)</strong>：
<ul>
<li>为避免用户看到图元光栅化并发送到屏幕的过程。</li>
<li>场景渲染在离屏的<strong>后缓冲区 (Back Buffer)</strong> 中。</li>
<li>场景在后缓冲区渲染完毕后，后缓冲区内容与之前显示在屏幕上的<strong>前缓冲区 (Front Buffer)</strong> 内容进行交换。</li>
<li>交换通常发生在<strong>垂直回扫 (Vertical Retrace)</strong> 期间。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="26-完整管线流程示例-through-the-pipeline">
<a class="header-anchor" href="#26-%e5%ae%8c%e6%95%b4%e7%ae%a1%e7%ba%bf%e6%b5%81%e7%a8%8b%e7%a4%ba%e4%be%8b-through-the-pipeline"></a>
2.6 完整管线流程示例 (Through the Pipeline)
</h2><p>以一个交互式计算机辅助设计(CAD)应用的华夫饼机模型为例，该模型包含线条（显示部件边缘）和三角形（显示表面），部分三角形通过二维图像纹理化（制造商徽标）。表面着色完全在几何阶段计算，纹理应用在光栅化阶段（原文此处表述可能简化，纹理采样通常在像素着色阶段）。</p>
<ul>
<li><strong>应用阶段 (Application)</strong>：
<ul>
<li>用户操作（如移动鼠标打开华夫饼机盖子）被转换为相应的旋转矩阵，并确保该矩阵在渲染盖子时正确应用。</li>
<li>相机沿预定路径移动的动画，应用阶段根据时间更新相机参数（位置、观察方向）。</li>
<li>为每帧待渲染图像，应用阶段将相机位置、光照和模型图元传递给几何阶段。</li>
</ul>
</li>
<li><strong>几何处理阶段 (Geometry Processing)</strong>：
<ul>
<li>假设应用已提供投影矩阵。对每个对象，应用已计算一个矩阵，描述视图变换及对象自身的位置和方向（例如，华夫饼机底座一个矩阵，盖子一个矩阵）。</li>
<li>对象的顶点和法线使用此矩阵进行变换，将对象置于视图空间。</li>
<li>然后可能使用材质和光源属性在顶点处计算着色或其他计算。</li>
<li>接着使用用户提供的独立投影矩阵执行投影，将对象变换到表示眼睛所见的单位立方体空间。</li>
<li>所有在该立方体之外的图元被丢弃。所有与此单位立方体相交的图元被裁剪，以获得一组完全位于单位立方体内的图元。</li>
<li>然后顶点被映射到屏幕上的窗口中。</li>
<li>所有这些逐三角形和逐顶点操作完成后，结果数据传递给光栅化阶段。</li>
</ul>
</li>
<li><strong>光栅化阶段 (Rasterization)</strong>：
<ul>
<li>在前一阶段裁剪后存活的所有图元被光栅化，即找出所有位于图元内部的像素，并发送到像素处理阶段。</li>
</ul>
</li>
<li><strong>像素处理阶段 (Pixel Processing)</strong>：
<ul>
<li>目标是计算每个可见图元的每个像素的颜色。</li>
<li>与任何纹理（图像）关联的三角形，在渲染时会按需应用这些图像。</li>
<li>通过Z缓冲算法以及可选的丢弃和模板测试来解决可见性问题。</li>
<li>每个对象依次处理，最终图像显示在屏幕上。</li>
</ul>
</li>
</ul>
<p><strong>结论 (Conclusion)</strong></p>
<ul>
<li>该管线是数十年来API和图形硬件针对实时渲染应用演进的结果。</li>
<li>这不是唯一可能的渲染管线；离线渲染管线经历了不同的演进路径（例如，电影制作曾常用微多边形管线，近来光线追踪和路径追踪占据主导，这些技术也用于建筑和设计预可视化）。</li>
<li>多年来，开发者通过图形API使用此流程的唯一方式是通过<strong>固定功能管线 (fixed-function pipeline)</strong>（硬件实现不可灵活编程，如任天堂Wii）。</li>
<li><strong>可编程GPU (Programmable GPUs)</strong> 则允许精确决定在管线各子阶段应用的操作（本书第四版假设所有开发都使用可编程GPU）。</li>
</ul>
<p><strong>进一步阅读和资源 (Further Reading and Resources)</strong></p>
<ul>
<li>Blinn的书《A Trip Down the Graphics Pipeline》：关于从头编写软件渲染器，解释裁剪和透视插值等关键算法的细节。</li>
<li>《OpenGL Programming Guide》（红宝书）：详尽描述图形管线及其相关算法。</li>
<li>本书网站 realtimerendering.com 提供各种管线图、渲染引擎实现等链接。</li>
</ul>
<h1 id="第三章-图形处理单元-the-graphics-processing-unit">
<a class="header-anchor" href="#%e7%ac%ac%e4%b8%89%e7%ab%a0-%e5%9b%be%e5%bd%a2%e5%a4%84%e7%90%86%e5%8d%95%e5%85%83-the-graphics-processing-unit"></a>
第三章 图形处理单元 (The Graphics Processing Unit)
</h1><p>“显示即计算机 (The display is the computer.)” — 黄仁勋 (Jen-Hsun Huang)</p>
<ul>
<li><strong>历史开端</strong>：图形加速最初始于在覆盖三角形的每个像素扫描线上插值颜色并显示。</li>
<li><strong>纹理映射</strong>：引入访问图像数据的能力，使得纹理可以应用于表面。</li>
<li><strong>Z-深度测试</strong>：增加硬件插值和测试z深度，提供了内置的可见性检查。</li>
<li><strong>专用硬件</strong>：由于常用，这些流程被固化到专用硬件以提高性能。</li>
<li><strong>GPU的演进</strong>：
<ul>
<li>NVIDIA于1999年推出GeForce256，首次包含硬件顶点处理，并创造了“图形处理单元”(GPU)这一术语，以区别于此前仅支持光栅化的芯片。</li>
<li>GPU从复杂固定功能管线的可配置实现，演变为高度可编程的平台，开发者可以实现自己的算法。</li>
<li><strong>可编程着色器 (Programmable Shaders)</strong> 是控制GPU的主要手段。</li>
<li>趋势是向可编程性和灵活性发展，尽管某些部分为效率仍保持可配置。</li>
</ul>
</li>
<li><strong>GPU的速度优势</strong>：GPU相对于CPU的唯一计算优势是速度，而速度至关重要。</li>
<li><strong>并行处理</strong>：GPU通过专注于一组狭窄的、高度可并行的任务来获得高速。
<ul>
<li>拥有专用硅片来实现z缓冲、快速访问纹理图像和其他缓冲区、以及确定哪些像素被三角形覆盖等。</li>
</ul>
</li>
<li><strong>着色器核心 (Shader Core)</strong>：是一个小型处理器，执行相对独立的任务（如顶点变换、像素颜色计算）。每秒可能有数十亿次着色器调用。</li>
<li><strong>延迟 (Latency)</strong>：所有处理器都面临的问题，指访问数据所需的时间。信息离处理器越远，等待时间越长。
<ul>
<li>内存芯片中的信息比本地寄存器访问慢。</li>
<li>等待数据检索会导致处理器停顿，降低性能。</li>
</ul>
</li>
</ul>
<h2 id="31-数据并行架构-data-parallel-architectures">
<a class="header-anchor" href="#31-%e6%95%b0%e6%8d%ae%e5%b9%b6%e8%a1%8c%e6%9e%b6%e6%9e%84-data-parallel-architectures"></a>
3.1 数据并行架构 (Data-Parallel Architectures)
</h2><ul>
<li><strong>CPU的延迟处理策略</strong>：
<ul>
<li>优化用于处理各种数据结构和大型代码库。</li>
<li>多处理器，但每个处理器主要串行运行代码（SIMD向量处理是例外）。</li>
<li>大量芯片面积用于快速本地缓存 (Caches)。</li>
<li>使用分支预测、指令重排、寄存器重命名、缓存预取等技术避免停顿。</li>
</ul>
</li>
<li><strong>GPU的延迟处理策略</strong>：
<ul>
<li>大量芯片面积用于大量处理器，称为<strong>着色器核心 (Shader Cores)</strong>，数量可达数千。</li>
<li>是一种<strong>流处理器 (Stream Processor)</strong>，按顺序处理有序的相似数据集（如顶点或像素）。</li>
<li><strong>大规模并行处理</strong>：由于数据相似性，GPU可以大规模并行处理。</li>
<li><strong>调用独立性</strong>：着色器调用尽可能独立，不依赖相邻调用的信息，不共享可写内存位置（打破规则会有潜在延迟代价）。</li>
<li><strong>优化吞吐量 (Throughput)</strong>：GPU优化的是最大数据处理速率。</li>
<li><strong>高延迟</strong>：由于缓存内存和控制逻辑的芯片面积较少，每个着色器核心的延迟通常远高于CPU处理器。</li>
</ul>
</li>
<li><strong>延迟隐藏 (Latency Hiding) 机制</strong>：
<ul>
<li><strong>示例</strong>：单个着色器处理器处理2000个片段。当遇到纹理访问等高延迟操作时，处理器会停顿。</li>
<li><strong>改进</strong>：为每个片段提供少量存储空间（本地寄存器）。当一个片段因数据获取（如纹理读取）而需要等待时，处理器<strong>切换 (Switch)</strong> 到执行另一个片段。</li>
<li>切换速度极快，不影响片段数据。</li>
<li>单个片段执行时间可能更长，但整体片段处理时间大大缩短。</li>
</ul>
</li>
<li><strong>单指令多数据 (SIMD, Single Instruction, Multiple Data)</strong>：
<ul>
<li>将指令执行逻辑与数据分离。</li>
<li>在固定数量的着色器程序上以锁步 (Lock-step) 方式执行相同命令。</li>
<li>优势：相比为每个程序使用独立逻辑和分发单元，SIMD需要更少的硅片和功耗。</li>
</ul>
</li>
<li><strong>线程 (Thread) 和 Warp/Wavefront</strong>：
<ul>
<li>GPU中，每个像素着色器调用（针对一个片段）称为一个<strong>线程 (Thread)</strong>。这不同于CPU线程，仅包含输入值内存和执行所需寄存器空间。</li>
<li>使用相同着色器程序的线程被捆绑成组，NVIDIA称之为 <strong>Warps</strong>，AMD称之为 <strong>Wavefronts</strong>。</li>
<li>一个Warp/Wavefront由一定数量（8到64个）的GPU着色器核心使用SIMD处理进行调度。每个线程映射到一个SIMD通道。</li>
<li><strong>Warp执行与切换</strong>：
<ul>
<li>例如，NVIDIA GPU的Warp包含32个线程。2000个线程会产生63个Warps。</li>
<li>Warp中的所有线程（例如32个）同步执行着色器程序的指令。</li>
<li>当遇到内存读取（如纹理读取）时，所有线程同时遇到，导致整个Warp准备停顿。</li>
<li>此时，该Warp被<strong>换出 (Swapped Out)</strong>，另一个Warp被换入执行。</li>
<li>Warp切换非常快，因为不触及每个线程内的数据；每个线程有自己的寄存器，每个Warp跟踪其执行的指令。</li>
<li>Warp交换是所有GPU使用的主要延迟隐藏机制。</li>
</ul>
</li>
</ul>
</li>
<li><strong>影响效率的因素</strong>：
<ul>
<li><strong>线程数量</strong>：线程少则Warp少，延迟隐藏效果差。</li>
<li><strong>寄存器使用量</strong>：每个线程所需寄存器越多，GPU能容纳的驻留线程和Warp就越少。</li>
<li><strong>占用率 (Occupancy)</strong>：“驻留 (In Flight)” 的Warp数量。高占用率意味着有许多Warp可供处理，处理器空闲可能性小；低占用率通常导致性能不佳。</li>
<li><strong>内存读取频率</strong>：影响需要多少延迟隐藏。</li>
<li><strong>动态分支 (Dynamic Branching)</strong>：由 &ldquo;if&rdquo; 语句和循环引起。
<ul>
<li><strong>线程分化 (Thread Divergence)</strong>：如果Warp中的线程采取不同分支，Warp必须执行所有路径，并丢弃不需要的结果，导致部分线程在某些路径执行时空闲。这会降低效率。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="32-gpu管线概述-gpu-pipeline-overview">
<a class="header-anchor" href="#32-gpu%e7%ae%a1%e7%ba%bf%e6%a6%82%e8%bf%b0-gpu-pipeline-overview"></a>
3.2 GPU管线概述 (GPU Pipeline Overview)
</h2><ul>
<li>GPU实现了第二章中描述的概念性几何处理、光栅化和像素处理阶段。</li>
<li>这些阶段被划分为几个硬件阶段，具有不同程度的可配置性或可编程性。</li>
<li><strong>逻辑模型 vs. 物理模型</strong>：
<ul>
<li>API向程序员暴露的是<strong>逻辑模型</strong>。</li>
<li>硬件供应商的<strong>物理模型</strong>实现可能不同（例如，逻辑模型中的固定功能阶段可能由相邻可编程阶段的额外命令在GPU上执行）。</li>
</ul>
</li>
<li><strong>管线阶段 (按图3.2颜色编码)</strong>：
<ul>
<li><strong>绿色 (完全可编程 Fully Programmable)</strong>：
<ul>
<li><strong>顶点着色器 (Vertex Shader)</strong>：实现几何处理。</li>
<li><strong>几何着色器 (Geometry Shader)</strong>：操作图元顶点，可进行逐图元着色、销毁或创建新图元。</li>
<li><strong>曲面细分着色器 (Tessellation Stage Shaders)</strong>：（可选）</li>
<li><strong>像素着色器 (Pixel Shader)</strong>：</li>
</ul>
</li>
<li><strong>黄色 (可配置但不可编程 Configurable but not Programmable)</strong>：
<ul>
<li>例如，合并阶段 (Merger Stage) 可以设置多种混合模式。</li>
</ul>
</li>
<li><strong>蓝色 (功能完全固定 Completely Fixed)</strong>：
<ul>
<li><strong>裁剪 (Clipping)</strong></li>
<li><strong>屏幕映射 (Screen Mapping)</strong>：受窗口和视口设置影响，内部形成简单的缩放和重定位。</li>
<li><strong>三角形设置与遍历 (Triangle Setup &amp; Traversal)</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>可选阶段</strong>：曲面细分阶段和几何着色器是可选的，并非所有GPU（尤其移动设备）都支持。</li>
<li><strong>合并阶段 (Merger Stage)</strong>：高度可配置，负责修改颜色、z缓冲、混合、模板以及其他输出相关缓冲区。</li>
<li><strong>演进趋势</strong>：GPU管线已从硬编码操作向增加灵活性和控制演进，可编程着色器阶段是此演进中最重要的步骤。</li>
</ul>
<h2 id="33-可编程着色器阶段-the-programmable-shader-stage">
<a class="header-anchor" href="#33-%e5%8f%af%e7%bc%96%e7%a8%8b%e7%9d%80%e8%89%b2%e5%99%a8%e9%98%b6%e6%ae%b5-the-programmable-shader-stage"></a>
3.3 可编程着色器阶段 (The Programmable Shader Stage)
</h2><ul>
<li><strong>统一着色器设计 (Unified Shader Design)</strong>：
<ul>
<li>现代着色器程序使用统一设计，顶点、像素、几何和曲面细分相关着色器共享一个<strong>通用编程模型</strong>。</li>
<li>内部具有相同的<strong>指令集架构 (ISA, Instruction Set Architecture)</strong>。</li>
<li>实现此模型的处理器在DirectX中称为<strong>通用着色器核心 (Common-Shader Core)</strong>，拥有此类核心的GPU被称为具有<strong>统一着色器架构 (Unified Shader Architecture)</strong>。</li>
<li>优势：着色器处理器可用于多种角色，GPU可根据需要分配，动态平衡负载。</li>
</ul>
</li>
<li><strong>着色语言 (Shading Languages)</strong>：
<ul>
<li>使用类C语言编写，如DirectX的<strong>HLSL (High-Level Shading Language)</strong> 和OpenGL的<strong>GLSL (OpenGL Shading Language)</strong>。</li>
<li>HLSL可编译为虚拟机字节码（也称<strong>中间语言 IL 或 DXIL</strong>），以提供硬件无关性。驱动程序将其转换为特定GPU的ISA。</li>
<li>主机编程通常避免中间语言步骤。</li>
</ul>
</li>
<li><strong>基本数据类型</strong>：
<ul>
<li>32位单精度浮点标量和向量（向量仅是代码层面，硬件不支持）。</li>
<li>现代GPU原生支持32位整数和64位浮点数。</li>
<li>浮点向量通常包含位置 (xyzw)、法线、矩阵行、颜色 (rgba) 或纹理坐标 (uvwq)。</li>
<li>整数常用于计数器、索引或位掩码。</li>
<li>支持聚合数据类型，如结构体、数组和矩阵。</li>
</ul>
</li>
<li><strong>输入类型</strong>：
<ul>
<li><strong>Uniform 输入 (Uniform Inputs)</strong>：在一次绘制调用 (Draw Call) 中保持不变的值（但在不同绘制调用之间可更改）。</li>
<li><strong>Varying 输入 (Varying Inputs)</strong>：来自三角形顶点或光栅化的数据（例如，像素着色器中逐像素变化的表面位置）。</li>
<li><strong>纹理 (Texture)</strong>：一种特殊的Uniform输入，现在可视为任何大型数据数组，而不仅是应用于表面的颜色图像。</li>
</ul>
</li>
<li><strong>虚拟机寄存器 (Virtual Machine Registers - Shader Model 4.0)</strong> (见图3.3)：
<ul>
<li><strong>临时寄存器 (Temporary Registers)</strong>：多达4096个，用于暂存空间。</li>
<li><strong>Varying输入寄存器</strong>：顶点/几何/像素着色器分别有 16/16/32 个。</li>
<li><strong>输出寄存器</strong>：顶点/几何/像素着色器分别有 16/32/8 个。</li>
<li><strong>常量寄存器 (Constant Registers)</strong>：16个缓冲区，每个缓冲区4096个寄存器。用于Uniforms。</li>
<li><strong>纹理</strong>：128个数组，每个数组512个纹理。</li>
<li>Uniforms的常量寄存器数量远大于Varying输入/输出寄存器，因为Varying数据需为每个顶点/像素单独存储，而Uniforms则在整个绘制调用中复用。</li>
</ul>
</li>
<li><strong>高效运算</strong>：
<ul>
<li>图形计算中的常见运算（如加法、乘法）通过操作符（*、+）暴露。</li>
<li>其他通过<strong>内建函数 (Intrinsic Functions)</strong> 暴露（如atan(), sqrt(), log()），这些函数针对GPU进行了优化。</li>
<li>也存在用于更复杂操作的函数（如向量归一化、反射、叉积、矩阵转置和行列式计算）。</li>
</ul>
</li>
<li><strong>流控制 (Flow Control)</strong>：使用分支指令改变代码执行流程。
<ul>
<li><strong>静态流控制 (Static Flow Control)</strong>：分支基于Uniform输入的值。代码流在整个绘制调用中是恒定的。允许同一着色器用于不同情况（如不同数量的光源）。无线程分化。</li>
<li><strong>动态流控制 (Dynamic Flow Control)</strong>：分支基于Varying输入的值。每个片段可以不同地执行代码。功能更强大，但可能牺牲性能，尤其当代码流在着色器调用间不规律变化时（导致线程分化）。</li>
</ul>
</li>
</ul>
<h2 id="34-可编程着色与api的演进-the-evolution-of-programmable-shading-and-apis">
<a class="header-anchor" href="#34-%e5%8f%af%e7%bc%96%e7%a8%8b%e7%9d%80%e8%89%b2%e4%b8%8eapi%e7%9a%84%e6%bc%94%e8%bf%9b-the-evolution-of-programmable-shading-and-apis"></a>
3.4 可编程着色与API的演进 (The Evolution of Programmable Shading and APIs)
</h2><ul>
<li><strong>早期概念</strong>：
<ul>
<li>1984年，Cook的<strong>Shade Trees</strong> 提出了可编程着色框架。</li>
<li><strong>RenderMan Shading Language</strong> (20世纪80年代末) 基于此思想发展而来，仍用于电影制作渲染。</li>
<li><strong>Open Shading Language (OSL)</strong> 是其他演进中的规范。</li>
</ul>
</li>
<li><strong>消费级硬件与早期尝试</strong>：
<ul>
<li>1996年10月1日，3dfx Interactive 推出 Voodoo 显卡，实现了固定功能管线。</li>
<li>在GPU原生支持可编程着色器之前，有通过<strong>多遍渲染 (Multiple Rendering Passes)</strong> 实现可编程着色操作的尝试。</li>
<li>1999年，《雷神之锤III：竞技场》的脚本语言是该领域首个广泛商业成功的例子。</li>
<li>NVIDIA GeForce256 (1999) 被称为GPU，但不可编程，是可配置的。</li>
</ul>
</li>
<li><strong>可编程顶点与像素着色器的出现</strong>：
<ul>
<li>2001年初，NVIDIA GeForce 3 是首款支持<strong>可编程顶点着色器</strong>的GPU，通过DirectX 8.0和OpenGL扩展暴露。
<ul>
<li>用类汇编语言编程，驱动动态转换为微码。</li>
</ul>
</li>
<li>DirectX 8.0 也包含像素着色器，但功能有限（“程序”被转换为纹理混合状态，长度受限，缺乏依赖纹理读取和浮点数据等关键功能）。</li>
<li>Peercy等人指出，真正的可编程性需要<strong>依赖纹理读取 (Dependent Texture Reads)</strong> 和<strong>浮点数据 (Floating Point Data)</strong>。</li>
<li>此时着色器不允许流控制（分支）。</li>
</ul>
</li>
<li><strong>Shader Model (SM) 与真正可编程性</strong>：
<ul>
<li>DirectX 定义了<strong>Shader Model (SM)</strong> 来区分具有不同着色器能力的硬件。</li>
<li>2002年，DirectX 9.0 发布，包含 <strong>SM 2.0</strong>，特点是<strong>真正可编程的顶点和像素着色器</strong>。
<ul>
<li>OpenGL通过各种扩展提供了类似功能。</li>
<li>增加了对任意依赖纹理读取和16位浮点值存储的支持。</li>
<li>增加了指令、纹理、寄存器等资源限制。</li>
<li>增加了流控制支持。</li>
</ul>
</li>
<li>DirectX 9.0 同时引入了 <strong>HLSL</strong> (由微软与NVIDIA合作开发)。</li>
<li>OpenGL ARB 发布了 <strong>GLSL</strong> (与C语言及RenderMan Shading Language语法和设计哲学相似)。</li>
</ul>
</li>
<li><strong>进一步发展</strong>：
<ul>
<li>2004年，<strong>SM 3.0</strong> 引入，增加了<strong>动态流控制</strong>，使着色器更强大。可选特性变为必需，资源限制进一步增加，并有限支持顶点着色器中的纹理读取。</li>
<li>Xbox 360 (2005) 和 PLAYSTATION 3 (2006) 配备了SM 3.0级别GPU。</li>
<li>Nintendo Wii (2006) 是最后 notables 之一的固定功能GPU。</li>
</ul>
</li>
<li><strong>现代着色器模型与API</strong>：
<ul>
<li>2006年底，<strong>SM 4.0</strong> (随 DirectX 10.0 发布) 引入主要特性：
<ul>
<li><strong>几何着色器 (Geometry Shader)</strong></li>
<li><strong>流输出 (Stream Output)</strong></li>
<li>所有着色器（顶点、像素、几何）的<strong>统一编程模型</strong>（即统一着色器设计）。</li>
<li>进一步增加资源限制，支持整数数据类型（包括位运算）。</li>
<li>OpenGL 3.3 中的 GLSL 3.30 提供了类似的着色器模型。</li>
</ul>
</li>
<li>2009年，DirectX 11 和 <strong>SM 5.0</strong> 发布：
<ul>
<li>增加了<strong>曲面细分阶段着色器 (Tessellation Stage Shaders)</strong> 和<strong>计算着色器 (Compute Shader, 或 DirectCompute)</strong>。</li>
<li>专注于更有效地支持CPU多处理。</li>
<li>OpenGL 在 4.0 版添加曲面细分，4.3 版添加计算着色器。</li>
</ul>
</li>
</ul>
</li>
<li><strong>API发展差异与低开销API</strong>：
<ul>
<li>DirectX 由微软控制，与硬件供应商 (IHV) 及开发者合作。</li>
<li>OpenGL 由Khronos Group管理的硬件和软件供应商联盟开发，新特性通常在DirectX之后出现在OpenGL版本中，但OpenGL允许<strong>扩展 (Extensions)</strong> 提前使用新功能。</li>
<li>2013年，AMD 推出 <strong>Mantle API</strong>，旨在剥离驱动程序开销，将控制权直接交给开发者，并支持高效CPU多处理。</li>
<li><strong>低开销API (Low-Overhead APIs)</strong>：专注于大幅减少CPU在驱动程序中的时间，以及更高效的CPU多处理器支持。</li>
<li>2015年，微软发布 <strong>DirectX 12</strong>，采纳Mantle思想。它是一个API的彻底重新设计，更好地映射现代GPU架构（与DX 11.3暴露相同的硬件特性）。移植可能困难，简单实现可能导致性能下降。</li>
<li>2014年，苹果发布 <strong>Metal API</strong>，首先用于移动设备，后用于Mac。注重效率和功耗节省。有自己的着色语言。</li>
<li>AMD 将 Mantle 贡献给 Khronos Group，后者于2016年初发布 <strong>Vulkan</strong>。
<ul>
<li>Vulkan 跨操作系统，使用新的高级中间语言 <strong>SPIR-V</strong>（用于着色器表示和通用GPU计算）。</li>
<li>预编译着色器可移植。</li>
<li>可用于非图形GPU计算，无需显示窗口。</li>
<li>旨在适用于从工作站到移动设备的广泛系统。</li>
</ul>
</li>
</ul>
</li>
<li><strong>移动与Web API</strong>：
<ul>
<li>移动设备上，<strong>OpenGL ES (Embedded Systems)</strong> 是常态。
<ul>
<li>OpenGL ES 1.0 (2003)：OpenGL 1.3的精简版，描述固定功能管线。</li>
<li>OpenGL ES 2.0 (2007)：基于OpenGL 2.0，提供可编程着色，但不向后兼容1.1。</li>
<li>OpenGL ES 3.0 (2012)：增加多渲染目标、纹理压缩、变换反馈、实例化等。</li>
<li>OpenGL ES 3.1：增加计算着色器。</li>
<li>OpenGL ES 3.2：增加几何和曲面细分着色器。</li>
</ul>
</li>
<li><strong>WebGL</strong>：基于浏览器的API，通过JavaScript调用。
<ul>
<li>WebGL 1.0 (2011)：功能等同于OpenGL ES 2.0。</li>
<li>WebGL 2.0：基于OpenGL ES 3.0支持。</li>
<li><strong>WebGL优势</strong>：跨平台、驱动由浏览器处理、解释性语言、内置调试器、易于部署。</li>
<li>高级库如 three.js 提供更复杂效果的便捷访问。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="35-顶点着色器-the-vertex-shader">
<a class="header-anchor" href="#35-%e9%a1%b6%e7%82%b9%e7%9d%80%e8%89%b2%e5%99%a8-the-vertex-shader"></a>
3.5 顶点着色器 (The Vertex Shader)
</h2><ul>
<li><strong>位置</strong>：功能管线中的第一个可编程阶段。</li>
<li><strong>输入装配器 (Input Assembler - DirectX术语)</strong>：在顶点着色器前进行数据操作。
<ul>
<li>可将多个数据流编织在一起，形成顶点和图元集。</li>
<li>支持<strong>实例化 (Instancing)</strong>：一次绘制调用多次绘制对象，每次实例可带不同数据。</li>
</ul>
</li>
<li><strong>顶点数据</strong>：
<ul>
<li>三角形网格由一组顶点表示，每个顶点关联模型表面的特定位置及其他可选属性（颜色、纹理坐标）。</li>
<li><strong>顶点法线 (Vertex Normals)</strong>：通常用于表示底层曲面（而非三角形网格本身）的朝向。</li>
</ul>
</li>
<li><strong>功能</strong>：
<ul>
<li>处理传入的顶点，不能访问三角形的形成数据。</li>
<li>修改、创建或忽略与每个三角形顶点相关的属性值（颜色、法线、纹理坐标、位置）。</li>
<li><strong>核心任务</strong>：通常将顶点从模型空间 (Model Space) 变换到齐次裁剪空间 (Homogeneous Clip Space)。至少必须输出此位置。</li>
</ul>
</li>
<li><strong>特性</strong>：
<ul>
<li>与统一着色器类似。</li>
<li>每个传入顶点由顶点着色器程序处理，输出的值将在三角形或线上插值。</li>
<li>不能创建或销毁顶点，一个顶点的结果不能传递给另一个顶点。</li>
<li>由于顶点独立处理，GPU上的任意数量着色器处理器可并行应用于顶点流。</li>
</ul>
</li>
<li><strong>物理模型差异</strong>：输入装配在逻辑上先于顶点着色器，但物理上，顶点数据获取可能在顶点着色器内发生，驱动程序会悄悄地在每个着色器前添加相应指令。</li>
<li><strong>应用示例</strong>：
<ul>
<li>对象生成（创建一次网格，由顶点着色器变形）。</li>
<li>角色身体和面部动画（蒙皮、变形）。</li>
<li>程序化变形（旗帜、布料、水面运动）。</li>
<li>粒子创建（发送退化网格，在需要时赋予面积）。</li>
<li>镜头畸变、热浪、水波纹、翻页等效果（使用整个帧缓冲作为屏幕对齐网格的纹理并进行程序化变形）。</li>
<li>通过顶点纹理拾取 (Vertex Texture Fetch) 应用地形高度场。</li>
</ul>
</li>
<li><strong>输出</strong>：
<ul>
<li>通常路径：图元生成、光栅化，产生的像素片段发送给像素着色器。</li>
<li>在某些GPU上，数据也可发送到曲面细分阶段、几何着色器或存储到内存。</li>
</ul>
</li>
</ul>
<h2 id="36-曲面细分阶段-the-tessellation-stage">
<a class="header-anchor" href="#36-%e6%9b%b2%e9%9d%a2%e7%bb%86%e5%88%86%e9%98%b6%e6%ae%b5-the-tessellation-stage"></a>
3.6 曲面细分阶段 (The Tessellation Stage)
</h2><ul>
<li><strong>目的</strong>：允许渲染曲面。GPU将每个曲面描述转换为一组代表性的三角形。</li>
<li><strong>要求</strong>：DirectX 11必需的可选GPU特性，OpenGL 4.0和OpenGL ES 3.2也支持。</li>
<li><strong>优势</strong>：
<ul>
<li>曲面描述通常比提供相应三角形更紧凑（节省内存，减少CPU-GPU总线瓶颈）。</li>
<li>可根据给定视图高效生成适当数量的三角形（<strong>细节级别控制 Level of Detail, LOD</strong>），例如，远处的球体用少量三角形，近处则用数千个。</li>
<li>LOD控制应用性能，或在弱GPU上使用低质量网格。</li>
<li>可将平面模型转换为精细三角网格后进行变形，或用于减少昂贵着色计算的频率。</li>
</ul>
</li>
<li><strong>三个组成部分 (DirectX术语/OpenGL术语)</strong>：
<ol>
<li><strong>外壳着色器 (Hull Shader)</strong> / <strong>曲面细分控制着色器 (Tessellation Control Shader)</strong>：
<ul>
<li>输入：一个特殊的<strong>面片图元 (Patch Primitive)</strong>，由定义细分曲面、贝塞尔面片等的控制点组成。</li>
<li>功能1：告诉镶嵌器应生成多少三角形以及配置方式（通过<strong>曲面细分因子 Tessellation Factors, TFs</strong>）。</li>
<li>功能2：对每个控制点进行处理。</li>
<li>可选：修改输入面片描述（增删控制点）。</li>
<li>输出：其控制点集、曲面细分控制数据给域着色器。</li>
</ul>
</li>
<li><strong>镶嵌器 (Tessellator)</strong> / <strong>图元生成器 (Primitive Generator)</strong>：
<ul>
<li>固定功能阶段。</li>
<li>任务：为域着色器添加若干新顶点以供处理。</li>
<li>从外壳着色器接收信息：
<ul>
<li>期望的曲面细分类型：三角形、四边形或<strong>等值线 (Isoline)</strong>（用于头发渲染等）。</li>
<li><strong>曲面细分因子 (Tessellation Factors)</strong> / <strong>曲面细分级别 (Tessellation Levels)</strong>：
<ul>
<li><strong>内部因子 (Inner Factors)</strong>：决定三角形或四边形内部细分程度。</li>
<li><strong>外部边缘因子 (Outer Edge Factors)</strong>：决定每个外部边缘分割程度。</li>
<li>允许相邻曲面边缘在细分上匹配，避免裂缝。</li>
</ul>
</li>
</ul>
</li>
<li>为顶点分配<strong>重心坐标 (Barycentric Coordinates)</strong>。</li>
</ul>
</li>
<li><strong>域着色器 (Domain Shader)</strong> / <strong>曲面细分评估着色器 (Tessellation Evaluation Shader)</strong>：
<ul>
<li>数据流模式类似顶点着色器，处理来自镶嵌器的每个输入顶点，生成相应输出顶点。</li>
<li>使用来自外壳着色器的曲面控制点和镶嵌器生成的重心坐标，计算每个输出顶点的属性值（位置、法线、纹理坐标等）。</li>
<li>形成的三角形向下传递到管线。</li>
</ul>
</li>
</ol>
</li>
<li><strong>流程效率</strong>：结构设计旨在提高效率，每个着色器可以相当简单。
<ul>
<li>外壳着色器可根据面片距离或屏幕尺寸动态计算TFs（如地形渲染），或传递应用计算的固定值。</li>
<li>镶嵌器执行固定但复杂的顶点生成、定位和三角化过程，此数据放大步骤在着色器外执行以提高效率。</li>
</ul>
</li>
<li><strong>面片丢弃</strong>：外壳着色器可通过发送零或负（或NaN）的外部曲面细分级别给镶嵌器，以丢弃面片。</li>
</ul>
<h2 id="37-几何着色器-the-geometry-shader">
<a class="header-anchor" href="#37-%e5%87%a0%e4%bd%95%e7%9d%80%e8%89%b2%e5%99%a8-the-geometry-shader"></a>
3.7 几何着色器 (The Geometry Shader)
</h2><ul>
<li><strong>功能</strong>：可以将图元转换为其他图元（曲面细分阶段不能）。
<ul>
<li>示例：将三角形网格转换为线框视图（每个三角形创建线边缘）；或用面向观察者的四边形替换线条，制作更粗的线框。</li>
</ul>
</li>
<li><strong>引入时间</strong>：DirectX 10 (2006年底) 加入硬件加速图形管线。位于曲面细分着色器之后，可选。SM 4.0必需，早期模型无。OpenGL 3.2和OpenGL ES 3.2也支持。</li>
<li><strong>输入</strong>：单个对象及其关联顶点。通常是三角形带、线段或点。
<ul>
<li>可定义和处理扩展图元（例如，三角形外的三个附加顶点，多段线上相邻的两个顶点）。</li>
<li>DirectX 11 / SM 5.0：可传入更复杂的面片（最多32个控制点），但曲面细分阶段对面片生成更高效。</li>
</ul>
</li>
<li><strong>输出</strong>：处理输入图元并输出零个或多个顶点，这些顶点被视为点、多段线或三角形带。
<ul>
<li>可以不生成任何输出，从而选择性修改网格（编辑顶点、添加新图元、移除其他图元）。</li>
</ul>
</li>
<li><strong>设计用途</strong>：修改传入数据或进行有限数量的复制。
<ul>
<li>示例：生成六个变换后的数据副本以同时渲染立方体贴图的六个面；高效创建级联阴影贴图。</li>
<li>其他算法：从点数据创建可变大小粒子、沿轮廓挤压鳍片用于毛发渲染、为阴影算法查找对象边缘。</li>
</ul>
</li>
<li><strong>特性</strong>：
<ul>
<li>DirectX 11增加了<strong>实例化 (Instancing)</strong> 能力，几何着色器可以在任何给定图元上运行设定次数。OpenGL 4.0中通过调用计数指定。</li>
<li>最多可输出到<strong>四个流 (Streams)</strong>。一个流可继续送往渲染管线，所有流可选择性发送到流输出渲染目标。</li>
</ul>
</li>
<li><strong>局限性</strong>：
<ul>
<li>保证按输入顺序输出图元结果，这影响并行性能，因为结果需保存和排序。</li>
<li>不适合在单次调用中复制或创建大量几何体。</li>
<li>实际使用较少，因其与GPU优势的映射不佳。在某些移动设备上是软件实现，不鼓励使用。</li>
</ul>
</li>
<li><strong>工作创建点</strong>：发出绘制调用后，GPU上只有三个地方可以创建工作：光栅化、曲面细分阶段、几何着色器。几何着色器行为在资源和内存需求方面最不可预测。</li>
</ul>
<p><strong>3.7.1 流输出 (Stream Output)</strong> / <strong>变换反馈 (Transform Feedback - OpenGL术语)</strong></p>
<ul>
<li><strong>概念</strong>：SM 4.0引入。顶点经顶点着色器（可选地，曲面细分和几何着色器）处理后，除了送往光栅化阶段，还可以流形式（有序数组）输出。</li>
<li><strong>用途</strong>：
<ul>
<li>可以将光栅化完全关闭，管线纯粹用作非图形流处理器。</li>
<li>处理后的数据可以送回管线进行迭代处理（如模拟流动水或其他粒子效果）。</li>
<li>蒙皮模型后，使这些顶点可供重用。</li>
</ul>
</li>
<li><strong>限制</strong>：
<ul>
<li>仅以浮点数形式返回数据，可能产生显著内存成本。</li>
<li>作用于图元，而非直接作用于顶点。若网格送入管线，每个三角形生成其自己的三个输出顶点，原始网格中的顶点共享会丢失。因此，更典型的用法是将顶点作为点集图元送过管线。</li>
</ul>
</li>
<li><strong>顺序保证</strong>：图元保证按输入顺序发送到流输出目标，顶点顺序将保持。</li>
</ul>
<h2 id="38-像素着色器-pixel-shader--片段着色器-fragment-shader---opengl术语">
<a class="header-anchor" href="#38-%e5%83%8f%e7%b4%a0%e7%9d%80%e8%89%b2%e5%99%a8-pixel-shader--%e7%89%87%e6%ae%b5%e7%9d%80%e8%89%b2%e5%99%a8-fragment-shader---opengl%e6%9c%af%e8%af%ad"></a>
3.8 像素着色器 (Pixel Shader) / 片段着色器 (Fragment Shader - OpenGL术语)
</h2><ul>
<li><strong>时机</strong>：在顶点、曲面细分和几何着色器操作后，图元被裁剪并设置为光栅化。</li>
<li><strong>光栅化</strong>：相对固定的处理步骤。每个三角形被遍历以确定其覆盖的像素。光栅器也可能粗略计算三角形覆盖每个像素单元区域的程度。覆盖像素的三角形部分称为<strong>片段 (Fragment)</strong>。</li>
<li><strong>插值</strong>：三角形顶点处的值（包括z值）在三角形表面上为每个像素进行插值。这些值传递给像素着色器。
<ul>
<li>插值类型由像素着色器程序指定，通常是<strong>透视校正插值 (Perspective-Correct Interpolation)</strong>。也可用屏幕空间插值。</li>
</ul>
</li>
<li><strong>输入</strong>：
<ul>
<li>顶点着色器输出（经插值后）成为像素着色器的输入。</li>
<li>其他输入：片段的屏幕位置（SM 3.0+）、三角形可见面标志（用于单遍渲染正反面不同材质）。</li>
</ul>
</li>
<li><strong>输出与功能</strong>：
<ul>
<li>通常计算并输出片段的<strong>颜色 (Color)</strong>。</li>
<li>可能产生<strong>不透明度值 (Opacity Value)</strong>。</li>
<li>可选地修改其<strong>z深度 (z-depth)</strong>。</li>
<li><strong>丢弃片段 (Discard Fragment)</strong>：像素着色器可以不产生输出（例如用于用户定义裁剪平面）。</li>
<li>雾计算和alpha测试已从合并操作移至SM 4.0中的像素着色器计算。</li>
</ul>
</li>
<li><strong>多渲染目标 (Multiple Render Targets, MRT)</strong>：
<ul>
<li>像素着色器可以将多个值集（针对每个片段）生成并保存到不同的缓冲区（渲染目标）。</li>
<li>渲染目标通常具有相同的x和y维度，某些API允许不同尺寸（渲染区域为最小者）。</li>
<li>某些架构要求渲染目标具有相同的位深度，甚至相同的数据格式。</li>
<li>可用渲染目标数量通常为4或8个。</li>
<li>MRT有助于更高效地执行渲染算法（例如，单遍生成颜色、对象ID、世界空间距离）。</li>
<li>催生了<strong>延迟着色 (Deferred Shading)</strong>：将可见性和着色分在不同遍完成。</li>
</ul>
</li>
<li><strong>局限与例外</strong>：
<ul>
<li>通常只能写入其处理片段位置的渲染目标，不能读取邻近像素的当前结果。</li>
<li><strong>梯度/导数信息 (Gradient/Derivative Information)</strong>：像素着色器可间接访问相邻片段信息。
<ul>
<li>提供任何插值量沿屏幕x和y轴每像素的变化量。</li>
<li>用于纹理过滤等计算。</li>
<li>现代GPU通过处理2x2的片段组（称为<strong>quad</strong>）来实现，请求梯度值时返回相邻片段间的差异。</li>
<li>结果：梯度信息不能在受动态流控制影响的着色器部分访问（quad中所有片段需用相同指令集处理）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>高级缓冲区访问</strong>：
<ul>
<li><strong>无序访问视图 (Unordered Access View, UAV - DirectX 11)</strong> / <strong>着色器存储缓冲对象 (Shader Storage Buffer Object, SSBO - OpenGL 4.3)</strong>：允许对任何位置进行写访问。最初仅用于像素和计算着色器，DX 11.1扩展到所有着色器。
<ul>
<li><strong>数据竞争 (Data Race Condition)</strong>：多个着色器程序竞争影响同一值。GPU通过着色器可访问的<strong>原子操作单元 (Atomic Units)</strong> 避免此问题，但原子操作可能导致着色器等待。</li>
</ul>
</li>
<li><strong>光栅器顺序视图 (Rasterizer Order Views, ROVs - DirectX 11.3)</strong>：
<ul>
<li>类似UAV，但保证数据按正确顺序访问（按绘制顺序）。</li>
<li>使得像素着色器可以编写自己的混合方法，无需合并阶段。</li>
<li>代价：若检测到乱序访问，像素着色器调用可能停顿。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="39-合并阶段-the-merging-stage--输出合并器-output-merger---directx术语--每样本操作-per-sample-operations---opengl术语">
<a class="header-anchor" href="#39-%e5%90%88%e5%b9%b6%e9%98%b6%e6%ae%b5-the-merging-stage--%e8%be%93%e5%87%ba%e5%90%88%e5%b9%b6%e5%99%a8-output-merger---directx%e6%9c%af%e8%af%ad--%e6%af%8f%e6%a0%b7%e6%9c%ac%e6%93%8d%e4%bd%9c-per-sample-operations---opengl%e6%9c%af%e8%af%ad"></a>
3.9 合并阶段 (The Merging Stage) / 输出合并器 (Output Merger - DirectX术语) / 每样本操作 (Per-Sample Operations - OpenGL术语)
</h2><ul>
<li><strong>功能</strong>：将像素着色器生成的单个片段的深度和颜色与帧缓冲结合。
<ul>
<li>发生模板缓冲 (Stencil-Buffer) 和Z缓冲 (z-buffer) 操作。</li>
<li>若片段可见，则进行<strong>颜色混合 (Color Blending)</strong>。
<ul>
<li>不透明表面：片段颜色替换先前存储颜色。</li>
<li>透明与合成操作：片段与存储颜色实际混合。</li>
</ul>
</li>
</ul>
</li>
<li><strong>提前Z测试 (Early-Z)</strong>：
<ul>
<li>许多GPU在像素着色器执行前进行某些合并测试，以避免浪费处理。</li>
<li>使用片段的z深度（及模板缓冲、裁剪等）测试可见性，若隐藏则剔除片段。</li>
<li>若像素着色器程序修改z深度或丢弃片段，Early-Z通常不能使用而被关闭，降低管线效率。</li>
<li>DirectX 11和OpenGL 4.2允许像素着色器强制开启Early-Z（有诸多限制）。</li>
</ul>
</li>
<li><strong>可配置性</strong>：介于固定功能阶段和完全可编程阶段之间。不可编程，但高度可配置。
<ul>
<li>颜色混合可设置为多种操作（加减乘、最小/最大、位逻辑运算）。</li>
<li>DirectX 10增加了**双源颜色混合 (Dual Source-Color Blending)**能力（像素着色器输出两种颜色与帧缓冲颜色混合），不能与MRT同时使用。</li>
<li>MRT支持混合，DirectX 10.1引入了对每个独立缓冲区执行不同混合操作的能力。</li>
</ul>
</li>
<li><strong>绘制顺序保证</strong>：ROVs和合并阶段都保证<strong>绘制顺序 (Draw Order)</strong> 或<strong>输出不变性 (Output Invariance)</strong>。无论像素着色器结果生成顺序如何，API要求结果按输入顺序（逐对象、逐三角形）排序并发送到合并阶段。</li>
</ul>
<h2 id="310-计算着色器-the-compute-shader">
<a class="header-anchor" href="#310-%e8%ae%a1%e7%ae%97%e7%9d%80%e8%89%b2%e5%99%a8-the-compute-shader"></a>
3.10 计算着色器 (The Compute Shader)
</h2><ul>
<li><strong>GPU计算 (GPU Computing)</strong>：将GPU用于传统图形管线之外的非图形用途（如金融计算、深度学习神经网络训练）。
<ul>
<li>平台如 CUDA 和 OpenCL 用于控制GPU作为大规模并行处理器。</li>
</ul>
</li>
<li><strong>计算着色器特性 (DirectX 11引入)</strong>：
<ul>
<li>一种GPU计算形式，不由图形管线中的位置锁定。</li>
<li>通过图形API调用，与顶点、像素等其他着色器并用。</li>
<li>使用与管线中其他着色器相同的统一着色器处理器池。</li>
<li>有输入数据集，可访问缓冲区（如纹理）进行输入输出。</li>
<li>Warps和线程在计算着色器中更可见（例如，每次调用获得可访问的线程索引）。</li>
<li><strong>线程组 (Thread Group)</strong>：DirectX 11中为1到1024个线程，通过x,y,z坐标指定。</li>
<li>每个线程组有少量共享内存（DirectX 11中为32KB）。</li>
<li>计算着色器按线程组执行，保证组内所有线程并发运行。</li>
</ul>
</li>
<li><strong>优势与用途</strong>：
<ul>
<li>可访问GPU上生成的数据，避免GPU到CPU的数据传输延迟。</li>
<li><strong>后处理 (Post-processing)</strong>：修改已渲染图像。共享内存意味着采样图像像素的中间结果可与相邻线程共享（例如，计算图像亮度分布或平均亮度，比像素着色器快两倍）。</li>
<li>粒子系统、网格处理（如面部动画）、剔除、图像过滤、改进深度精度、阴影、景深等。</li>
<li>在某些情况下比曲面细分外壳着色器更高效。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>总结：</strong> 本章回顾了GPU对渲染管线的实现，GPU的功能可以通过多种方式组合以执行各种与渲染相关的过程。后续章节将关注变换和着色等相关理论与算法。</p>
<h1 id="第4章-变换-transforms">
<a class="header-anchor" href="#%e7%ac%ac4%e7%ab%a0-%e5%8f%98%e6%8d%a2-transforms"></a>
第4章 变换 (Transforms)
</h1><p>变换是一种操作，它接收点、向量或颜色等实体，并以某种方式转换它们。对于计算机图形从业者来说，掌握变换至关重要。通过变换，你可以定位、重塑和动画化对象、光源和相机。你还可以确保所有计算都在同一坐标系中执行，并以不同方式将对象投影到平面上。这些只是变换可以执行的部分操作，但足以证明变换在实时图形乃至任何计算机图形中的重要性。</p>
<ul>
<li><strong>线性变换 (Linear Transform)</strong>: 保持向量加法和标量乘法的变换。
<ul>
<li>$f(x) + f(y) = f(x+y)$ (公式 4.1)</li>
<li>$kf(x) = f(kx)$ (公式 4.2)</li>
<li>示例：$f(x) = 5x$ 是一个线性变换（缩放变换）。</li>
<li>旋转变换也是线性变换。</li>
<li>对于三元素向量，所有线性变换（如缩放和旋转）都可以用一个 $3 \times 3$ 矩阵表示。</li>
</ul>
</li>
<li><strong>平移变换 (Translation)</strong>: 例如 $f(x) = x + (7, 3, 2)$，它不是线性的。它将所有位置移动相同的量。</li>
<li><strong>仿射变换 (Affine Transform)</strong>: 执行线性变换然后进行平移的变换。
<ul>
<li>通常存储为 $4 \times 4$ 矩阵。</li>
<li><strong>齐次坐标 (Homogeneous Notation)</strong>: 用于表示四元素向量，统一表示点和方向。
<ul>
<li>方向向量: $v = (v_x, v_y, v_z, 0)^T$</li>
<li>点: $v = (v_x, v_y, v_z, 1)^T$</li>
</ul>
</li>
<li>所有平移、旋转、缩放、反射和错切矩阵都是仿射的。</li>
<li>仿射矩阵的主要特性是保持线的平行性，但不一定保持长度和角度。</li>
<li>任何仿射变换序列的级联也是仿射变换。</li>
</ul>
</li>
<li><strong>本章内容概览</strong>:
<ul>
<li>基础仿射变换（可视为简单变换的“参考手册”）。</li>
<li>更专门的矩阵。</li>
<li>四元数 (Quaternions) 及其应用。</li>
<li>顶点混合 (Vertex Blending) 和变形 (Morphing)。</li>
<li>投影矩阵 (Projection Matrices)。</li>
<li><strong>表4.1</strong>: 总结了本章讨论的大多数变换及其特性（如正交矩阵的逆是其转置）。</li>
</ul>
</li>
<li><strong>理解矩阵的重要性</strong>: 即使图形API封装了矩阵操作，理解矩阵本身及其交互仍然重要。例如，知道何时处理正交矩阵（其逆是其转置）可以加速矩阵求逆，从而优化代码。</li>
</ul>
<h3 id="41-基础变换-basic-transforms">
<a class="header-anchor" href="#41-%e5%9f%ba%e7%a1%80%e5%8f%98%e6%8d%a2-basic-transforms"></a>
4.1 基础变换 (Basic Transforms)
</h3><p>本节描述最基本的变换，如平移、旋转、缩放、错切、变换级联、刚体变换、法线变换和逆矩阵计算。</p>
<ul>
<li>
<p><strong>4.1.1 平移 (Translation)</strong></p>
<ul>
<li>平移矩阵 $T(t)$ 将实体通过向量 $t = (t_x, t_y, t_z)$ 进行平移。
$$
        T(t) = T(t_x, t_y, t_z) = \begin{pmatrix} 1 & 0 & 0 & t_x \\ 0 & 1 & 0 & t_y \\ 0 & 0 & 1 & t_z \\ 0 & 0 & 0 & 1 \end{pmatrix} \quad \text{(公式 4.3)}
        $$</li>
<li>点 $p = (p_x, p_y, p_z, 1)$ 乘以 $T(t)$ 得到新点 $p' = (p_x+t_x, p_y+t_y, p_z+t_z, 1)$。</li>
<li>方向向量 $v = (v_x, v_y, v_z, 0)$ 不受平移影响（因为方向向量不能被平移）。</li>
<li>其他仿射变换会同时影响点和向量。</li>
<li>平移矩阵的逆: $T^{-1}(t) = T(-t)$。</li>
<li><strong>行主序 (row-major) vs 列主序 (column-major)</strong>: 本书使用列主序。DirectX使用行主序，矩阵顺序会相反，应用顺序从左到右。这纯粹是记法差异；内存中，平移向量通常位于16个元素的最后（或接近最后）位置。</li>
</ul>
</li>
<li>
<p><strong>4.1.2 旋转 (Rotation)</strong></p>
<ul>
<li>旋转变换将向量（位置或方向）围绕通过原点的给定轴旋转给定角度。</li>
<li>是刚体变换：保持变换点之间的距离，并保持手性（handedness）。</li>
<li><strong>方向矩阵 (Orientation Matrix)</strong>: 与相机视图或对象关联的旋转矩阵，定义其在空间中的方向。</li>
<li>二维旋转矩阵 $R(\phi)$ (公式 4.4):
$$
        R(\phi) = \begin{pmatrix} \cos\phi & -\sin\phi \\ \sin\phi & \cos\phi \end{pmatrix}
        $$</li>
<li>三维中常用的旋转矩阵：$R_x(\phi)$, $R_y(\phi)$, $R_z(\phi)$ (分别围绕x,y,z轴旋转 $\phi$ 弧度)。
$$
        R_x(\phi) = \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & \cos\phi & -\sin\phi & 0 \\ 0 & \sin\phi & \cos\phi & 0 \\ 0 & 0 & 0 & 1 \end{pmatrix} \quad \text{(公式 4.5)}
        $$    <br>
$$
        R_y(\phi) = \begin{pmatrix} \cos\phi & 0 & \sin\phi & 0 \\ 0 & 1 & 0 & 0 \\ -\sin\phi & 0 & \cos\phi & 0 \\ 0 & 0 & 0 & 1 \end{pmatrix} \quad \text{(公式 4.6)}
        $$    <br>
$$
        R_z(\phi) = \begin{pmatrix} \cos\phi & -\sin\phi & 0 & 0 \\ \sin\phi & \cos\phi & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{pmatrix} \quad \text{(公式 4.7)}
        $$</li>
<li>对于任何 $3 \times 3$ 旋转矩阵 $R$ (旋转 $\phi$ 弧度)，其迹 (trace，对角元素之和) 为 $tr(R) = 1 + 2\cos\phi$ (公式 4.8)，且与旋转轴无关。</li>
<li>旋转矩阵 $R_i(\phi)$ 的特性是它保持旋转轴 $i$ 上的所有点不变。</li>
<li>所有旋转矩阵的行列式为1，并且是正交的。级联的旋转矩阵也是如此。</li>
<li>逆矩阵: $R_i^{-1}(\phi) = R_i(-\phi)$ (围绕同一轴反向旋转)，或 $R^{-1} = R^T$ (因为正交)。</li>
<li><strong>示例：绕点旋转</strong> (图 4.2): 绕z轴和点p旋转对象 $\phi$ 弧度。变换 $X = T(p)R_z(\phi)T(-p)$ (公式 4.9)。注意矩阵顺序。</li>
</ul>
</li>
<li>
<p><strong>4.1.3 缩放 (Scaling)</strong></p>
<ul>
<li>缩放矩阵 $S(s) = S(s_x, s_y, s_z)$ 分别沿x, y, z方向缩放实体。
$$
        S(s) = \begin{pmatrix} s_x & 0 & 0 & 0 \\ 0 & s_y & 0 & 0 \\ 0 & 0 & s_z & 0 \\ 0 & 0 & 0 & 1 \end{pmatrix} \quad \text{(公式 4.10)}
        $$</li>
<li><strong>均匀缩放 (Uniform Scaling)</strong>: $s_x = s_y = s_z$。否则为 <strong>非均匀缩放 (Nonuniform Scaling)</strong>。也称各向同性/各向异性缩放。</li>
<li>逆矩阵: $S^{-1}(s) = S(1/s_x, 1/s_y, 1/s_z)$。</li>
<li><strong>通过齐次坐标w分量进行均匀缩放</strong>: 将矩阵元素 (3,3)（右下角）设置为 $1/s$ 可实现均匀缩放因子 $s$。
$$
        S = \begin{pmatrix} 5 & 0 & 0 & 0 \\ 0 & 5 & 0 & 0 \\ 0 & 0 & 5 & 0 \\ 0 & 0 & 0 & 1 \end{pmatrix} \quad \text{或} \quad S' = \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1/5 \end{pmatrix} \quad \text{(公式 4.11)}
        $$
使用 $S'$ 必须进行齐次化（除以w分量），可能效率较低，因为涉及除法。如果右下角元素为1，则不需要除法。</li>
<li><strong>反射矩阵 (Reflection Matrix / Mirror Matrix)</strong>: 当s的一个或三个分量为负值时。若只有两个缩放因子为-1，则旋转 $\pi$ 弧度。</li>
<li>旋转矩阵与反射矩阵的级联也是反射矩阵 (公式 4.12)。</li>
<li>检测反射矩阵：计算矩阵左上角 $3 \times 3$ 部分的行列式。若为负，则是反射性的。这会导致顶点顺序反转（例如，逆时针变顺时针），影响光照和背面剔除。</li>
<li><strong>示例：沿特定方向缩放</strong>: 若沿正交单位向量 $f_x, f_y, f_z$ 方向缩放。首先构造基变换矩阵 $F$ (公式 4.13)。变换 $X = FS(s)F^T$ (公式 4.14)。</li>
</ul>
</li>
<li>
<p><strong>4.1.4 错切 (Shearing)</strong></p>
<ul>
<li>错切矩阵可用于扭曲场景或模型外观。</li>
<li>六种基本错切矩阵: $H_{xy}(s), H_{xz}(s), H_{yx}(s), H_{yz}(s), H_{zx}(s), H_{zy}(s)$。第一个下标表示被改变的坐标，第二个下标表示进行错切的坐标。</li>
<li>示例 $H_{xz}(s)$ (公式 4.15):
$$
        H_{xz}(s) = \begin{pmatrix} 1 & 0 & s & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{pmatrix}
        $$
将点 $p$ 变为 $(p_x+sp_z, p_y, p_z)^T$。图 4.3 说明了单位正方形上的效果。</li>
<li>逆矩阵: $H_{ij}^{-1}(s) = H_{ij}(-s)$。</li>
<li>另一种错切矩阵 $H'_{xy}(s,t)$ (公式 4.16)：两个下标表示的坐标都通过第三个坐标进行错切。</li>
<li>任何错切矩阵 $|H|=1$，因此是保体积变换。</li>
</ul>
</li>
<li>
<p><strong>4.1.5 变换的级联 (Concatenation of Transforms)</strong></p>
<ul>
<li>由于矩阵乘法的非交换性，矩阵出现的顺序很重要。变换级联是顺序相关的。</li>
<li>示例 (图 4.4): $S(s)R_z(\pi/6)$ 与 $R_z(\pi/6)S(s)$ 的结果不同。</li>
<li>目的：提高效率。例如，场景中所有对象需缩放、旋转、平移。将三个矩阵 $T, R, S$ 级联成单一矩阵 $C=TRS$。然后将 $C$ 应用于顶点。</li>
<li>注意顺序：$TRS p = (T(R(Sp)))$，表示S先作用于点p。TRS是场景图系统常用的顺序。</li>
<li>矩阵级联是可结合的：$(TR)(Sp)$。</li>
</ul>
</li>
<li>
<p><strong>4.1.6 刚体变换 (The Rigid-Body Transform)</strong></p>
<ul>
<li>仅由平移和旋转级联组成的变换。</li>
<li>特性：保持长度、角度和手性。</li>
<li>形式 $X = T(t)R$ (公式 4.17):
$$
        X = T(t)R = \begin{pmatrix} r_{00} & r_{01} & r_{02} & t_x \\ r_{10} & r_{11} & r_{12} & t_y \\ r_{20} & r_{21} & r_{22} & t_z \\ 0 & 0 & 0 & 1 \end{pmatrix}
        $$</li>
<li>逆矩阵: $X^{-1} = (T(t)R)^{-1} = R^{-1}T(t)^{-1} = R^T T(-t)$。计算时，将 $R$ 的左上 $3 \times 3$ 部分转置，将 $T$ 的平移值取反，然后以相反顺序相乘。</li>
<li>另一种计算逆矩阵的方法 (公式 4.19): $X^{-1} = \begin{pmatrix} \bar{R}^T & -\bar{R}^T t \\ 0^T & 1 \end{pmatrix}$。</li>
<li><strong>示例：相机定向 (Orienting the Camera)</strong> (图 4.5): 类似 <code>gluLookAt()</code> 功能。
<ul>
<li>相机位置 $c$，目标点 $l$，给定相机上方向 $u'$。</li>
<li>计算视图向量 $v = (c-l)/||c-l||$ (从目标指向相机位置的归一化向量)。</li>
<li>右向量 $r = (u' \times v)/||u' \times v||$。</li>
<li>最终上向量 $u = v \times r$ (保证归一化且正交)。</li>
<li>变换矩阵 $M$ (公式 4.20): 首先平移使相机位置到原点，然后进行基变换使 $r, u, v$ 分别与 $(1,0,0), (0,1,0), (0,0,1)$对齐。
$$M = \begin{pmatrix} r_x & r_y & r_z & 0 \\ u_x & u_y & u_z & 0 \\ v_x & v_y & v_z & 0 \\ 0 & 0 & 0 & 1 \end{pmatrix} \begin{pmatrix} 1 & 0 & 0 & -c_x \\ 0 & 1 & 0 & -c_y \\ 0 & 0 & 1 & -c_z \\ 0 & 0 & 0 & 1 \end{pmatrix} = \begin{pmatrix} r_x & r_y & r_z & -r \cdot c \\ u_x & u_y & u_z & -u \cdot c \\ v_x & v_y & v_z & -v \cdot c \\ 0 & 0 & 0 & 1 \end{pmatrix}$$
注意这里 $M$ 的第一部分是基变换矩阵的逆 (即转置)，行向量是 $r,u,v$。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>4.1.7 法线变换 (Normal Transform)</strong></p>
<ul>
<li>单一矩阵可一致地变换点、线、三角形等几何体，以及切向量。</li>
<li>但该矩阵<strong>不能</strong>总用于变换表面法线 (图 4.6)。</li>
<li>正确方法：使用原矩阵伴随矩阵的转置 $(M^{adj})^T$。伴随矩阵总存在。</li>
<li>传统方法：原矩阵逆的转置 $(M^{-1})^T$。通常有效，但如果矩阵奇异（行列式为0），逆不存在。</li>
<li>对于不进行投影的仿射变换（即 $w$ 分量不变），只需计算左上角 $3 \times 3$ 部分的伴随矩阵的转置。</li>
<li><strong>特殊情况</strong>：若变换矩阵仅由平移、旋转和均匀缩放构成：
<ul>
<li>平移不影响法线。</li>
<li>均匀缩放只改变法线长度。</li>
<li>旋转序列仍是旋转。此时，$(M^{-1})^T = ((R S U)^T)^{-T} = (U^T S^T R^T)^{-T} = (U^T S R^T)^{-T}$。如果只有旋转，$(R^{-1})^T = (R^T)^T = R$。因此原变换矩阵 $M$ 本身可用于变换法线。</li>
</ul>
</li>
<li>变换后的法线通常需要重新归一化。
<ul>
<li>若只有平移和旋转，法线长度不变，无需归一化。</li>
<li>若有均匀缩放，可用整体缩放因子归一化，或将原矩阵的左上 $3 \times 3$ 部分除以该因子来创建法线变换矩阵。</li>
</ul>
</li>
<li>若变换后从三角形边重新计算法线，则法线变换不是问题。</li>
<li>切向量总是用原矩阵直接变换。</li>
</ul>
</li>
<li>
<p><strong>4.1.8 逆矩阵的计算 (Computation of Inverses)</strong></p>
<ul>
<li>逆矩阵用于坐标系切换等。</li>
<li>计算方法：
<ol>
<li><strong>简单变换序列</strong>: 对参数取逆，并反转矩阵顺序。例如，若 $M = T(t)R(\phi)$，则 $M^{-1} = R(-\phi)T(-t)$。简单且保持精度。</li>
<li><strong>正交矩阵</strong>: $M^{-1} = M^T$。旋转序列是正交的。</li>
<li><strong>通用情况</strong>: 伴随矩阵法、克莱默法则、LU分解或高斯消元。伴随矩阵法和克莱默法则分支较少，更可取。</li>
</ol>
</li>
<li>优化：若逆矩阵仅用于变换向量，通常只需对左上角 $3 \times 3$ 部分求逆。</li>
</ul>
</li>
</ul>
<h3 id="42-特殊矩阵变换和运算-special-matrix-transforms-and-operations">
<a class="header-anchor" href="#42-%e7%89%b9%e6%ae%8a%e7%9f%a9%e9%98%b5%e5%8f%98%e6%8d%a2%e5%92%8c%e8%bf%90%e7%ae%97-special-matrix-transforms-and-operations"></a>
4.2 特殊矩阵变换和运算 (Special Matrix Transforms and Operations)
</h3><ul>
<li>
<p><strong>4.2.1 欧拉变换 (The Euler Transform)</strong></p>
<ul>
<li>一种直观的构造方向矩阵的方法（相机或物体）。</li>
<li>默认视图方向：通常沿负z轴，头部沿y轴 (图 4.7)。</li>
<li>欧拉变换 $E(h,p,r)$ 是三个旋转矩阵的乘积：$E(h,p,r) = R_z(r)R_x(p)R_y(h)$ (公式 4.21)。
<ul>
<li>$h$: head (航向/yaw)，绕y轴旋转。</li>
<li>$p$: pitch (俯仰)，绕x轴旋转。</li>
<li>$r$: roll (翻滚)，绕z轴旋转。</li>
<li>矩阵顺序有24种，书中为常用的一种。</li>
</ul>
</li>
<li>由于是旋转的级联，欧拉变换是正交的，其逆 $E^{-1} = E^T = (R_z R_x R_y)^T = R_y^T R_x^T R_z^T$。</li>
<li>术语：head有时称yaw；roll有时指所有轴的旋转 (如y-roll, x-roll)。</li>
<li>全局轴 vs 局部参考系。</li>
<li>世界坐标系向上方向：y-up (媒体相关建模) vs z-up (制造、建筑)。本书默认为y-up。</li>
<li>相机视图空间的上方向与世界空间的上方向无关。</li>
<li><strong>局限性</strong>:
<ul>
<li>难以组合两组欧拉角（例如，插值每个角不正确）。</li>
<li>不同欧拉角集合可能产生相同方向。</li>
<li><strong>万向节死锁 (Gimbal Lock)</strong> (见4.2.2)。</li>
<li>因此，可考虑四元数等替代表示。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>4.2.2 从欧拉变换中提取参数 (Extracting Parameters from the Euler Transform)</strong></p>
<ul>
<li>从正交矩阵 $E$ 中提取欧拉参数 $h, p, r$。
$$E(h,p,r) = \begin{pmatrix} e_{00} & e_{01} & e_{02} \\ e_{10} & e_{11} & e_{12} \\ e_{20} & e_{21} & e_{22} \end{pmatrix} = R_z(r)R_x(p)R_y(h) \quad \text{(公式 4.22)}$$
（这里使用 $3 \times 3$ 矩阵，因旋转信息已足够）。</li>
<li>级联结果 (公式 4.23) 显示 $\sin p = e_{21}$。</li>
<li>提取公式 (使用 <code>atan2(y,x)</code>) (公式 4.25):
<ul>
<li>$h = \text{atan2}(-e_{20}, e_{22})$</li>
<li>$p = \arcsin(e_{21})$</li>
<li>$r = \text{atan2}(-e_{01}, e_{11})$</li>
</ul>
</li>
<li><strong>万向节死锁处理</strong>: 若 $\cos p = 0$ (即 $p = \pm \pi/2 + 2\pi k$)，则 $r$ 和 $h$ 绕同轴旋转（方向可能不同），失去一个自由度。此时，矩阵只依赖于一个角 ($r+h$ 或 $r-h$)。
<ul>
<li>可任意设 $h=0$，则 $r = \text{atan2}(e_{10}, e_{00})$ (从公式 4.26 推导)。</li>
</ul>
</li>
<li>$\arcsin$ 的定义域为 $[-\pi/2, \pi/2]$，若 $p$ 在此范围外，无法提取原始参数。</li>
<li>$h, p, r$ 不唯一，多组参数可产生相同变换。</li>
<li>简单提取方法可能导致数值不稳定性。</li>
<li><strong>万向节死锁解释</strong>: 当旋转使得一个自由度丢失时发生。例如，x/y/z顺序，绕y轴旋转 $\pi/2$ 会使局部z轴与原始x轴对齐，导致最后绕z轴的旋转冗余。</li>
<li>不同欧拉角顺序 (如z/x/y, z/x/z) 用于不同领域。z/x/z顺序仅在绕x轴旋转 $\pi$ 时发生万向节死锁。没有完美的序列能避免万向节死锁。</li>
<li><strong>示例：约束变换</strong>: 例如，扳手只能绕x轴旋转。从输入设备获取旋转矩阵 $P$，提取欧拉角 $h,p,r$，然后创建新矩阵 $R_x(p_{提取})$ 应用于扳手。</li>
</ul>
</li>
<li>
<p><strong>4.2.3 矩阵分解 (Matrix Decomposition)</strong></p>
<ul>
<li>从级联矩阵中检索各种变换。</li>
<li>用途：
<ul>
<li>提取对象的缩放因子。</li>
<li>为特定系统找到所需变换（某些系统可能不允许任意 $4 \times 4$ 矩阵）。</li>
<li>确定模型是否只经历了刚体变换。</li>
<li>在只有对象矩阵可用的动画关键帧之间进行插值。</li>
<li>从旋转矩阵中移除错切。</li>
</ul>
</li>
<li>已介绍：刚体变换的平移和旋转矩阵分解 (4.1.6)，从正交矩阵导出欧拉角 (4.2.2)。</li>
<li>平移矩阵：简单，取 $4 \times 4$ 矩阵的最后一列。</li>
<li>反射：检查左上角 $3 \times 3$ 行列式是否为负。</li>
<li>分离旋转、缩放、错切：更复杂。参考文献：Thomas [1769], Goldman [552, 553], Shoemake [1635]。</li>
</ul>
</li>
<li>
<p><strong>4.2.4 绕任意轴旋转 (Rotation about an Arbitrary Axis)</strong></p>
<ul>
<li>使实体绕任意归一化轴 $r$ 旋转 $\alpha$ 弧度。</li>
<li><strong>方法1：基变换</strong> (图 4.8) [314]
<ol>
<li>构造旋转矩阵 $M$，将 $r$ 变换为x轴。</li>
<li>为此，找到与 $r$ 正交且相互正交的另外两个轴 $s, t$ ($t = r \times s$)。</li>
<li>寻找 $s$ 的数值稳定方法 (公式 4.27)：找到 $r$ 中绝对值最小的分量，设为0，交换另两个分量，然后对第一个非零分量取反。然后归一化 $\bar{s}$ 得到 $s$。</li>
<li>$M = \begin{pmatrix} r^T \\ s^T \\ t^T \end{pmatrix}$ (公式 4.28)。此矩阵将 $r, s, t$ 分别变换到x, y, z轴。</li>
<li>最终变换 $X = M^T R_x(\alpha) M$ (公式 4.29)。$M^T$ 是 $M$ 的逆，因为 $M$ 是正交的。
(注意：原文公式4.28 $M$ 的行是 $r^T, s^T, t^T$，这意味着它将标准基向量变换到 $r,s,t$。要将 $r$ 变换到x轴，应该使用 $M^{-1}=M^T$ 的形式，或者 $M$ 的列是 $r,s,t$。公式4.29 $X = M^T R_x(\alpha) M$ 意味着 $M$ 将 $r$ 变换到x轴，然后 $R_x(\alpha)$ 作用，然后 $M^T$ 变换回来。这要求 $M$ 的第一行是 $r$，第二行是 $s$，第三行是 $t$，这样 $Mr = (1,0,0)^T$。)
更准确地说，如果 $M$ 的行向量是 $r, s, t$，那么 $M$ 将向量从 $(r,s,t)$ 基转换到标准基。它的逆 $M^T$ 将向量从标准基转换到 $(r,s,t)$ 基。所以，若要将 $r$ 对齐x轴，应先用一个矩阵 $M_{align}$ 使得 $M_{align} r = (1,0,0)^T$。这个 $M_{align}$ 的行应该是 $r, s, t$ (如果 $r,s,t$ 是列向量组成一个基，则 $M_{align}$ 是这个基的逆)。
参照Frisvad[496], Max[1147], Duff[388]的方法，通常构造一个矩阵 $M_{frame}$，其列向量为 $s, t, r$ (或 $r,s,t$的某种排列)，然后 $X = M_{frame} R_k(\alpha) M_{frame}^T$，其中 $k$ 是 $r$ 映射到的轴。
书中的 $M=\begin{pmatrix} r^T \\ s^T \\ t^T \end{pmatrix}$ 意味着 $Mv = (r \cdot v, s \cdot v, t \cdot v)^T$。如果 $r,s,t$ 是一个标准正交基，那么这个矩阵就是将向量在新基下的坐标表示出来。如果 $r$ 是世界x轴， $s$ 是世界y轴， $t$ 是世界z轴，则 $M$ 是单位阵。如果 $v=r$，则 $Mr=(1,0,0)^T$。所以 $M$ 的行是 $r,s,t$ 的坐标，它将 $r$ 映射到 $e_x$, $s$ 映射到 $e_y$, $t$ 映射到 $e_z$。因此 $X=M^T R_x(\alpha) M$ 是正确的。</li>
</ol>
</li>
<li><strong>方法2：Goldman 公式</strong> [550] (公式 4.30): 直接构造旋转矩阵，无需基变换。
$$
        R = \begin{pmatrix} \cos\phi + (1-\cos\phi)r_x^2 & (1-\cos\phi)r_x r_y - r_z \sin\phi & (1-\cos\phi)r_x r_z + r_y \sin\phi \\ (1-\cos\phi)r_x r_y + r_z \sin\phi & \cos\phi + (1-\cos\phi)r_y^2 & (1-\cos\phi)r_y r_z - r_x \sin\phi \\ (1-\cos\phi)r_x r_z - r_y \sin\phi & (1-\cos\phi)r_y r_z + r_x \sin\phi & \cos\phi + (1-\cos\phi)r_z^2 \end{pmatrix}
        $$
(对于 $4 \times 4$ 矩阵，右下角补0和1)。</li>
</ul>
</li>
</ul>
<h3 id="43-四元数-quaternions">
<a class="header-anchor" href="#43-%e5%9b%9b%e5%85%83%e6%95%b0-quaternions"></a>
4.3 四元数 (Quaternions)
</h3><ul>
<li>
<p>1843年由哈密尔顿发明，1985年由Shoemake引入计算机图形学。</p>
</li>
<li>
<p>用于表示旋转和方向。在某些方面优于欧拉角和矩阵。</p>
</li>
<li>
<p>任何三维方向可表示为绕特定轴的单一旋转。从轴/角表示到四元数的转换直接，而欧拉角转换困难。</p>
</li>
<li>
<p>可用于方向的稳定和平滑插值（欧拉角不行）。</p>
</li>
<li>
<p>四元数有四个部分。前三部分与旋转轴密切相关，旋转角影响所有四个部分。</p>
</li>
<li>
<p>表示为 $\hat{q}$。</p>
</li>
<li>
<p><strong>4.3.1 数学背景 (Mathematical Background)</strong></p>
<ul>
<li><strong>定义</strong> (公式 4.31):
$\hat{q} = (q_v, q_w) = iq_x + jq_y + kq_z + q_w = q_v + q_w$
$q_v = iq_x + jq_y + kq_z = (q_x, q_y, q_z)$ (虚部)
$q_w$ (实部)
$i^2 = j^2 = k^2 = -1$
$jk=i, kj=-i, ki=j, ik=-j, ij=k, ji=-k$ (虚数单位乘法规则)</li>
<li><strong>乘法</strong> $\hat{q}\hat{r}$ (公式 4.32):
$\hat{q}\hat{r} = (q_v \times r_v + r_w q_v + q_w r_v, q_w r_w - q_v \cdot r_v)$
注意虚数单位乘法非交换。</li>
<li><strong>运算定义</strong> (公式 4.33):
<ul>
<li>加法: $\hat{q} + \hat{r} = (q_v + r_v, q_w + r_w)$</li>
<li>共轭: $\hat{q}^* = (-q_v, q_w)$</li>
<li>模 (Norm): $n(\hat{q}) = \sqrt{\hat{q}\hat{q}^*} = \sqrt{q_x^2+q_y^2+q_z^2+q_w^2}$。有时记为 $||\hat{q}||$。</li>
<li>单位四元数 (Identity): $\hat{i} = (0, 1)$ (指乘法单位元，即实部为1，虚部为0的四元数)。</li>
</ul>
</li>
<li><strong>逆 (Inverse)</strong> (公式 4.35): $\hat{q}^{-1} = \frac{1}{n(\hat{q})^2} \hat{q}^*$。</li>
<li>标量乘法 $s\hat{q} = (sq_v, sq_w)$，是可交换的: $s\hat{q} = \hat{q}s$。</li>
<li><strong>规则集合</strong> (公式 4.36-4.38):
<ul>
<li>共轭规则: $(\hat{q}^*)^* = \hat{q}$, $(\hat{q}+\hat{r})^* = \hat{q}^*+\hat{r}^*$, $(\hat{q}\hat{r})^* = \hat{r}^*\hat{q}^*$</li>
<li>模规则: $n(\hat{q}^*) = n(\hat{q})$, $n(\hat{q}\hat{r}) = n(\hat{q})n(\hat{r})$</li>
<li>乘法律: 线性律 $\hat{p}(s\hat{q}+t\hat{r}) = s\hat{p}\hat{q} + t\hat{p}\hat{r}$, 结合律 $\hat{p}(\hat{q}\hat{r}) = (\hat{p}\hat{q})\hat{r}$</li>
</ul>
</li>
<li><strong>单位四元数 (Unit Quaternion)</strong>: $n(\hat{q})=1$。可写为 (公式 4.39):
$\hat{q} = (\sin\phi u_q, \cos\phi) = \sin\phi u_q + \cos\phi$，其中 $u_q$ 是三维单位向量 ($||u_q||=1$)。</li>
<li><strong>指数形式</strong> (公式 4.41): $\hat{q} = \sin\phi u_q + \cos\phi = e^{\phi u_q}$</li>
<li><strong>对数 (Logarithm)</strong>: $\log(\hat{q}) = \log(e^{\phi u_q}) = \phi u_q$</li>
<li><strong>幂 (Power)</strong>: $\hat{q}^t = (\sin\phi u_q + \cos\phi)^t = e^{\phi t u_q} = \sin(\phi t)u_q + \cos(\phi t)$ (公式 4.42)</li>
</ul>
</li>
<li>
<p><strong>4.3.2 四元数变换 (Quaternion Transforms)</strong></p>
<ul>
<li>单位四元数可表示任何三维旋转，表示紧凑简单。</li>
<li>将点 $p=(p_x, p_y, p_z, p_w)^T$ (通常 $p_w=0$ for vector, $p_w=1$ for point, but here $p$ is a pure quaternion $(p_x,p_y,p_z,0)$) 放入四元数 $\hat{p}=( (p_x,p_y,p_z), 0)$。</li>
<li>用单位四元数 $\hat{q} = (\sin\phi u_q, \cos\phi)$ 旋转 $\hat{p}$ (公式 4.43): $\hat{q}\hat{p}\hat{q}^{-1}$。
<ul>
<li>这会将 $\hat{p}$ (即点 $p$) 绕轴 $u_q$ 旋转 $2\phi$ 弧度 (图 4.9)。</li>
<li>因为 $\hat{q}$ 是单位四元数，$\hat{q}^{-1} = \hat{q}^*$。</li>
</ul>
</li>
<li>$\hat{q}$ 和 $-\hat{q}$ 代表相同的旋转。</li>
<li><strong>级联</strong>: 先应用 $\hat{q}$ 再应用 $\hat{r}$ 于 $\hat{p}$: $\hat{r}(\hat{q}\hat{p}\hat{q}^*)\hat{r}^* = (\hat{r}\hat{q})\hat{p}(\hat{r}\hat{q})^* = \hat{c}\hat{p}\hat{c}^*$ (公式 4.44)。
<ul>
<li>$\hat{c} = \hat{r}\hat{q}$ 是表示级联的单位四元数。</li>
</ul>
</li>
<li><strong>矩阵转换 (Matrix Conversion)</strong>
<ul>
<li><strong>四元数到矩阵 ($M_q$)</strong> (公式 4.45, 单位四元数简化版公式 4.46):
$$
            M_q = \begin{pmatrix} 1-s(q_y^2+q_z^2) & s(q_x q_y - q_w q_z) & s(q_x q_z + q_w q_y) & 0 \\ s(q_x q_y + q_w q_z) & 1-s(q_x^2+q_z^2) & s(q_y q_z - q_w q_x) & 0 \\ s(q_x q_z - q_w q_y) & s(q_y q_z + q_w q_x) & 1-s(q_x^2+q_y^2) & 0 \\ 0 & 0 & 0 & 1 \end{pmatrix}
            $$
其中 $s = 2/(n(\hat{q}))^2$。对于单位四元数, $s=2$。
$$
            M_q = \begin{pmatrix} 1-2(q_y^2+q_z^2) & 2(q_x q_y - q_w q_z) & 2(q_x q_z + q_w q_y) & 0 \\ 2(q_x q_y + q_w q_z) & 1-2(q_x^2+q_z^2) & 2(q_y q_z - q_w q_x) & 0 \\ 2(q_x q_z - q_w q_y) & 2(q_y q_z + q_w q_x) & 1-2(q_x^2+q_y^2) & 0 \\ 0 & 0 & 0 & 1 \end{pmatrix} \quad \text{(单位四元数)}
            $$
构造后无需三角函数，转换高效。</li>
<li><strong>正交矩阵到单位四元数 ($\hat{q}$)</strong>:
<ul>
<li>关键差异 (公式 4.47): $m_{21}-m_{12} = 4q_w q_x$, $m_{02}-m_{20} = 4q_w q_y$, $m_{10}-m_{01} = 4q_w q_z$。</li>
<li>迹: $tr(M_q) = 4q_w^2 - 1$ (对于单位四元数，来自 $M_q$ 左上 $3 \times 3$ 部分的迹是 $3-4(q_x^2+q_y^2+q_z^2) = 3-4(1-q_w^2)=4q_w^2-1$)</li>
<li>转换 (公式 4.49): $q_w = \frac{1}{2}\sqrt{tr(M_q)+1}$, $q_x = \frac{m_{21}-m_{12}}{4q_w}$, 等。 (注意书中tr(Mq)的计算有些绕，直接使用 $3 \times 3$ 部分的迹 $tr(R) = m_{00}+m_{11}+m_{22}$，则 $4q_w^2 = tr(R)+1$ 是错误的。应该是 $q_w = \frac{1}{2}\sqrt{m_{00}+m_{11}+m_{22}+1}$ 当 $m_{00}+m_{11}+m_{22}+1$ 是最大的时候。更准确的是，根据原文公式4.48 $tr(M_q) = 4q_w^2 - 2s(q_x^2+q_y^2+q_z^2)$，对于单位四元数 $s=2$ 且 $q_x^2+q_y^2+q_z^2 = 1-q_w^2$，所以 $tr(M_q) = 4q_w^2 - 4(1-q_w^2) = 8q_w^2 - 4$ (指 $4 \times 4$ 矩阵的迹，其中 $m_{33}=1$)。如果仅指 $3 \times 3$ 部分的迹 $tr_3(M_q) = m_{00}+m_{11}+m_{22}$, 则 $tr_3(M_q) = 3-4(q_x^2+q_y^2+q_z^2) = 3-4(1-q_w^2) = 4q_w^2-1$。那么 $q_w = \frac{1}{2}\sqrt{tr_3(M_q)+1}$。)</li>
<li><strong>数值稳定例程</strong> [1634]: 避免除以小数字。找到 $m_{00}, m_{11}, m_{22}, tr_3(M_q)$ 中的最大值来确定 $q_x, q_y, q_z, q_w$ 中哪个最大，然后使用对应公式 (公式 4.50, 4.51)。</li>
</ul>
</li>
</ul>
</li>
<li><strong>球面线性插值 (Spherical Linear Interpolation - slerp)</strong>
<ul>
<li>给定两个单位四元数 $\hat{q}, \hat{r}$ 和参数 $t \in [0,1]$，计算插值四元数。</li>
<li>用于动画对象，但插值相机方向可能导致“上”向量倾斜。</li>
<li>代数形式 (公式 4.52): $\hat{s}(\hat{q}, \hat{r}, t) = (\hat{r}\hat{q}^{-1})^t \hat{q}$</li>
<li>软件实现形式 (公式 4.53):
$\text{slerp}(\hat{q}, \hat{r}, t) = \frac{\sin(\phi(1-t))}{\sin\phi}\hat{q} + \frac{\sin(\phi t)}{\sin\phi}\hat{r}$
其中 $\cos\phi = q_x r_x + q_y r_y + q_z r_z + q_w r_w$ (即 $\hat{q} \cdot \hat{r}$)。</li>
<li>计算从 $\hat{q}$ 到 $\hat{r}$ 的4D单位球上的最短弧（大圆弧）。路径是恒速、固定轴旋转（测地线）。</li>
<li>比欧拉角插值好。</li>
<li>为确保最短路径，如果 $\hat{q} \cdot \hat{r} < 0$，则对 $\hat{r}$ (或 $\hat{q}$) 取反再插值。</li>
<li>直接计算slerp开销大（三角函数）。有更快方法 (Malyshau [1114], Li [1039,1040], Eberly [406])。</li>
</ul>
</li>
<li><strong>球面三次插值 (Spherical Cubic Interpolation - squad)</strong>
<ul>
<li>用于平滑插值多个方向 $\hat{q}_0, \hat{q}_1, \dots, \hat{q}_{n-1}$。避免slerp序列的突兀。</li>
<li>在 $\hat{q}_i, \hat{q}_{i+1}$ 之间引入 $\hat{a}_i, \hat{a}_{i+1}$ (公式 4.54):
$\hat{a}_i = \hat{q}_i \exp\left[-\frac{\log(\hat{q}_i^{-1}\hat{q}_{i-1}) + \log(\hat{q}_i^{-1}\hat{q}_{i+1})}{4}\right]$</li>
<li>Squad公式 (公式 4.55):
$\text{squad}(\hat{q}_i, \hat{q}_{i+1}, \hat{a}_i, \hat{a}_{i+1}, t) = \text{slerp}(\text{slerp}(\hat{q}_i, \hat{q}_{i+1}, t), \text{slerp}(\hat{a}_i, \hat{a}_{i+1}, t), 2t(1-t))$</li>
<li>插值会通过 $\hat{q}_i$，但通常不通过 $\hat{a}_i$ (用于指示切线方向)。</li>
</ul>
</li>
<li><strong>从一个向量旋转到另一个向量 (Rotation from One Vector to Another)</strong> (s到t)
<ul>
<li>归一化 $s, t$。旋转轴 $u = (s \times t) / ||s \times t||$。$s,t$ 间的夹角为 $2\phi$。$\cos(2\phi) = s \cdot t$。</li>
<li>旋转四元数 $\hat{q} = (\sin\phi u, \cos\phi)$。</li>
<li>直接生成 $\hat{q}$ (公式 4.56) [1197]:
$\hat{q} = \left( \frac{s \times t}{\sqrt{2(1 + s \cdot t)}}, \sqrt{\frac{1 + s \cdot t}{2}} \right)$
(原文为 $e = s \cdot t$, $q_v = \frac{s \times t}{\sqrt{2(1+e)}}$, $q_w = \frac{\sqrt{2(1+e)}}{2}$，分子分母同乘 $\sqrt{2(1+e)}$ 后分母为 $2(1+e)$)
当 $s,t$ 方向接近时数值稳定。当 $s,t$ 方向相反时，两种方法都有稳定性问题 (除以0)。此时，绕任何垂直于 $s$ 的轴旋转 $\pi$ 弧度即可。</li>
<li><strong>矩阵表示</strong> (公式 4.57) [1233]:
令 $v = s \times t$, $e = s \cdot t$ (即 $\cos(2\phi)$), $h = \frac{1}{1+e}$。
$$
            R(s,t) = \begin{pmatrix} e + h v_x^2 & h v_x v_y - v_z & h v_x v_z + v_y & 0 \\ h v_x v_y + v_z & e + h v_y^2 & h v_y v_z - v_x & 0 \\ h v_x v_z - v_y & h v_y v_z + v_x & e + h v_z^2 & 0 \\ 0 & 0 & 0 & 1 \end{pmatrix}
            $$
(注意：原书公式4.58 $h = \frac{1-\cos(2\phi)}{\sin^2(2\phi)} = \frac{1-e}{v \cdot v} = \frac{1}{1+e}$。这个 $h$ 的推导有点技巧。)
此方法高效，因简化后无平方根和三角函数。</li>
<li>注意 $s,t$ 平行或接近平行的情况：
<ul>
<li>若 $\phi \approx 0$ ($s \approx t$), $v \approx 0$, $e \approx 1$。返回单位矩阵。</li>
<li>若 $2\phi \approx \pi$ ($s \approx -t$), $e \approx -1$。此时 $1+e \approx 0$，上述公式不稳定。可绕任意垂直于 $s$ 的轴旋转 $\pi$ 弧度。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="44-顶点混合-vertex-blending">
<a class="header-anchor" href="#44-%e9%a1%b6%e7%82%b9%e6%b7%b7%e5%90%88-vertex-blending"></a>
4.4 顶点混合 (Vertex Blending)
</h3><ul>
<li>也称线性混合蒙皮 (linear-blend skinning), 包裹 (enveloping), 或骨骼子空间形变 (skeleton-subspace deformation)。</li>
<li>解决刚体部件连接处（如肘部）不自然的问题 (图 4.11)。</li>
<li>使用单一网格，其顶点受骨骼 (bones) 系统影响。网格常被称为皮肤 (skin)。(图 4.12)</li>
<li><strong>数学表达</strong> (公式 4.59): 顶点 $p$ 的变换后位置 $u(t)$ 取决于时间 $t$。
$u(t) = \sum_{i=0}^{n-1} w_i B_i(t) M_i^{-1} p$，其中 $\sum_{i=0}^{n-1} w_i = 1, w_i \ge 0$。
<ul>
<li>$p$: 原始顶点（世界坐标）。</li>
<li>$n$: 影响顶点 $p$ 的骨骼数量。</li>
<li>$w_i$: 骨骼 $i$ 对顶点 $p$ 的权重。</li>
<li>$M_i$: 将顶点从骨骼 $i$ 的初始坐标系（绑定姿势，通常关节在原点）变换到世界坐标系的矩阵。$M_i^{-1}$ 将世界坐标的顶点变换到骨骼 $i$ 的局部空间。</li>
<li>$B_i(t)$: 骨骼 $i$ 在时间 $t$ 的世界变换矩阵（动画），通常是骨骼层级中先前骨骼变换和局部动画矩阵的级联。</li>
</ul>
</li>
<li>$B_i(t)$ 和 $M_i^{-1}$ 通常为每个骨骼的每帧动画预先级联。</li>
<li>法线通常也可用此公式变换，或根据需要使用 $(B_i(t)M_i^{-1})^{-T}$ (见4.1.7)。</li>
<li><strong>GPU友好</strong>: 网格顶点可放入静态缓冲区一次发送给GPU。每帧只需更新骨骼矩阵，顶点着色器计算其影响。</li>
<li><strong>缺点</strong>: 可能出现不必要的折叠、扭曲（“糖纸”现象）和自相交 (图 4.13)。</li>
<li><strong>改进方案</strong>:
<ul>
<li><strong>双四元数 (Dual Quaternions)</strong> [872, 873]: 帮助保持原始变换的刚性，避免“糖纸”扭曲。计算成本约为线性混合蒙皮的1.5倍。可能导致膨胀效应。</li>
<li><strong>旋转中心蒙皮 (Center-of-rotation skinning)</strong> [1001]: 作为双四元数的更好替代，解决膨胀问题。假设局部变换是刚体，且相似权重的顶点有相似变换。</li>
</ul>
</li>
</ul>
<h3 id="45-变形-morphing">
<a class="header-anchor" href="#45-%e5%8f%98%e5%bd%a2-morphing"></a>
4.5 变形 (Morphing)
</h3><ul>
<li>将一个三维模型随时间变成另一个模型 (图 4.14)。</li>
<li>两个主要问题：
<ol>
<li><strong>顶点对应问题 (Vertex Correspondence)</strong>: 对于不同拓扑、顶点数、连接性的任意模型，建立顶点对应关系困难。</li>
<li><strong>插值问题 (Interpolation)</strong>:</li>
</ol>
</li>
<li>若存在一对一顶点对应：可逐顶点插值。
<ul>
<li>线性插值 (公式 4.60): $m = (1-s)p_0 + sp_1$，其中 $s = (t-t_0)/(t_1-t_0)$。</li>
</ul>
</li>
<li><strong>变形目标 (Morph Targets / Blend Shapes)</strong> [907] (图 4.15):
<ul>
<li>中性模型 $N$。一组姿态 $P_i$ ($i \in [1, \dots, k]$)。</li>
<li>预处理计算“差异面” (Difference Faces): $D_i = P_i - N$。</li>
<li>变形后的模型 $M$ (公式 4.61): $M = N + \sum_{i=1}^{k} w_i D_i$。</li>
<li>权重 $w_i$ 可以为负或大于1，实现外插效果。</li>
<li>为动画师提供强大控制，可独立操纵模型不同特征。</li>
</ul>
</li>
<li><strong>姿态空间形变 (Pose-space deformation)</strong> [1037]: 结合顶点混合和变形目标。</li>
<li>高级技术：预计算顶点纹理存储位移 [1608]，GPU硬件支持 (stream-out, vertex ID) [841, 1074]，低分辨率网格+细分+位移贴图 [1971]。</li>
<li>图 4.16: 《声名狼藉：次子》中角色面部动画示例。</li>
</ul>
<h3 id="46-几何缓存回放-geometry-cache-playback">
<a class="header-anchor" href="#46-%e5%87%a0%e4%bd%95%e7%bc%93%e5%ad%98%e5%9b%9e%e6%94%be-geometry-cache-playback"></a>
4.6 几何缓存回放 (Geometry Cache Playback)
</h3><ul>
<li>用于过场动画等高质量动画，可能无法用上述方法表示。</li>
<li>朴素方法：存储所有帧的所有顶点，从磁盘读取并更新网格。数据量巨大 (例如3万顶点模型短动画可能50MB/s)。</li>
<li><strong>减少内存成本方法</strong> [545] (可降至约10%):
<ol>
<li><strong>量化 (Quantization)</strong>: 例如，位置和纹理坐标用16位整数存储。有损压缩。</li>
<li><strong>空间压缩 (Spatial Compression)</strong>: 如平行四边形预测 (用于三角带)。预测下一个顶点位置，编码差异。</li>
<li><strong>时间压缩 (Temporal Compression)</strong>: 类似MPEG。每n帧进行空间压缩，中间帧进行时间预测（如基于前一帧的运动增量）。</li>
</ol>
</li>
<li>这些技术可使数据足以进行实时流式传输。</li>
</ul>
<h3 id="47-投影-projections">
<a class="header-anchor" href="#47-%e6%8a%95%e5%bd%b1-projections"></a>
4.7 投影 (Projections)
</h3><ul>
<li>
<p>渲染前，场景中所有相关对象必须投影到某个平面或简单体中。之后进行裁剪和渲染。</p>
</li>
<li>
<p>本章之前的变换不影响w分量，且 $4 \times 4$ 矩阵底行为 (0 0 0 1)。</p>
</li>
<li>
<p><strong>透视投影矩阵 (Perspective Projection)</strong> 是例外：底行可包含操纵点和向量的数字，通常需要齐次化（w通常不为1，需除以w）。</p>
</li>
<li>
<p><strong>正交投影 (Orthographic Projection)</strong> 较简单，不影响w分量。</p>
</li>
<li>
<p><strong>坐标系假设</strong>: 观察者沿相机负z轴观看，y轴向上，x轴向右 (右手坐标系)。DirectX等使用左手坐标系 (沿正z轴观看)。</p>
</li>
<li>
<p><strong>4.7.1 正交投影 (Orthographic Projection)</strong></p>
<ul>
<li>特性：平行线投影后仍然平行。物体大小与距离相机远近无关。</li>
<li>简单正交投影矩阵 $P_o$ (公式 4.62): 保持x,y不变，z设为0 (投影到z=0平面)。
$$P_o = \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 \end{pmatrix}$$
不可逆 ($|P_o|=0$)。投影正负z值上的点。</li>
<li>更常用矩阵：由六元组 $(l, r, b, t, n, f)$ (左、右、底、顶、近、远平面) 定义。
<ul>
<li>将这些平面构成的轴对齐包围盒 (AABB) 缩放和平移到以原点为中心的轴对齐立方体。</li>
<li>AABB最小角 $(l,b,n)$，最大角 $(r,t,f)$。</li>
<li><strong>注意</strong>: $n > f$ (因为沿负z轴观看)。用户可能提供 $n < f$，内部取反。</li>
<li><strong>规范观察体 (Canonical View Volume - CVV)</strong>:
<ul>
<li>OpenGL: 最小角 $(-1,-1,-1)$，最大角 $(1,1,1)$。</li>
<li>DirectX: 最小角 $(-1,-1,0)$，最大角 $(1,1,1)$。</li>
<li>在此体中的坐标称为 <strong>规范化设备坐标 (Normalized Device Coordinates - NDC)</strong>。</li>
<li>变换到CVV的原因：裁剪更高效。</li>
</ul>
</li>
<li>变换过程 (图 4.18): 先平移使AABB中心与原点重合，再缩放至CVV大小。</li>
<li>正交变换矩阵 $P_o$ (公式 4.63):
$$P_o = \begin{pmatrix} \frac{2}{r-l} & 0 & 0 & -\frac{r+l}{r-l} \\ 0 & \frac{2}{t-b} & 0 & -\frac{t+b}{t-b} \\ 0 & 0 & \frac{2}{n-f} & -\frac{n+f}{n-f} \\ 0 & 0 & 0 & 1 \end{pmatrix}$$
可写为平移 $T(t)$ 后接缩放 $S(s)$ 的级联。可逆（若维度非零）。</li>
<li>包含镜像变换：将右手观察坐标系转换为左手NDC。例如，若原AABB与CVV大小相同，则 $n=1, f=-1$，导致 $z$ 轴反转 (公式 4.64)。</li>
<li><strong>DirectX的z映射到[0,1]</strong>: 在OpenGL的 $P_o$ 之后应用一个简单的缩放平移矩阵 (公式 4.65)，得到DirectX的正交矩阵 $P_{o[0,1]}$ (公式 4.66)。
$$P_{o[0,1]} = \begin{pmatrix} \frac{2}{r-l} & 0 & 0 & -\frac{r+l}{r-l} \\ 0 & \frac{2}{t-b} & 0 & -\frac{t+b}{t-b} \\ 0 & 0 & \frac{1}{n-f} & -\frac{f}{n-f} \\ 0 & 0 & 0 & 1 \end{pmatrix}$$
(DirectX文档中通常为转置形式，因其使用行主序)。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>4.7.2 透视投影 (Perspective Projection)</strong></p>
<ul>
<li>平行线投影后通常不平行，可能汇聚到一点。物体越远越小，更符合视觉感知。</li>
<li><strong>推导</strong>: 相机在原点，点 $p$ 投影到平面 $z=-d (d>0)$，得到点 $q$ (图 4.19)。
<ul>
<li>由相似三角形: $q_x/p_x = (-d)/p_z \Rightarrow q_x = -dp_x/p_z$ (公式 4.67)。</li>
<li>类似地 $q_y = -dp_y/p_z$, $q_z = -d$。</li>
<li>透视投影矩阵 $P_p$ (公式 4.68):
$$P_p = \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & -1/d & 0 \end{pmatrix}$$
(注意：书中此矩阵将z映射到z，且w为 $p_z/d$。实际上，更常见的简单透视投影矩阵会把 $z$ 映射到 $d$，并且w分量是 $p_z/d$ (或类似)。这里的公式 (4.68) 将 $z$ 映射到 $p_z$，并将 $w$ 设置为 $p_z/(-d)$。应用此矩阵并齐次化后得到 $q = (-dp_x/p_z, -dp_y/p_z, d, 1)$。书中公式 (4.69) 的 $P_p$ 矩阵为：
$$
            P_p = \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & -1/d & 1 \end{pmatrix}
            $$
(如果投影到平面z=0,且相机在z=d, 那么w应该是 $p_z/d$)
让我们以书上的 (4.68) 为准:
$$
            P_p = \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & -1/d & 0 \end{pmatrix}
            $$
乘以 $p=(p_x, p_y, p_z, 1)^T$ 得到 $(p_x, p_y, p_z, -p_z/d)^T$。齐次化后 $( -dp_x/p_z, -dp_y/p_z, -d, 1)^T$。这表示投影到 $z=-d$ 平面。</li>
<li>齐次坐标允许投影：几何上可解释为将点 $(p_x,p_y,p_z)$ 投影到平面 $w=1$。</li>
</ul>
</li>
<li><strong>将视锥体 (View Frustum) 变换到CVV</strong> (图 4.20):
<ul>
<li>视锥体由 $(l,r,b,t,n,f)$ 定义，其中 $0 > n > f$。$z=n$ 处的矩形最小角 $(l,b,n)$，最大角 $(r,t,n)$。</li>
<li>这些参数决定水平和垂直视场角 (Field of View - FOV)。</li>
<li>FOV 计算: $\phi = 2 \arctan(w/(2d))$ (公式 4.70)。</li>
<li>透视变换矩阵 $P_p$ (公式 4.71):
$$P_p = \begin{pmatrix} \frac{2n}{r-l} & 0 & \frac{r+l}{r-l} & 0 \\ 0 & \frac{2n}{t-b} & \frac{t+b}{t-b} & 0 \\ 0 & 0 & \frac{n+f}{n-f} & \frac{2fn}{n-f} \\ 0 & 0 & -1 & 0 \end{pmatrix}$$</li>
<li>应用此变换后，点 $q=(q_x,q_y,q_z,q_w)^T$ 的 $q_w$ 通常非零且不为1。需除以 $q_w$ (齐次化) 得到投影点 $p=(q_x/q_w, q_y/q_w, q_z/q_w, 1)$ (公式 4.72)。</li>
<li>$P_p$ 总是使 $z=f$ 映射到 $+1$，$z=n$ 映射到 $-1$ (OpenGL风格CVV)。</li>
<li><strong>无限远平面 (Infinite Far Plane)</strong>: 公式 4.71 变为 (公式 4.73):
$$P_p = \begin{pmatrix} \frac{2n}{r-l} & 0 & \frac{r+l}{r-l} & 0 \\ 0 & \frac{2n}{t-b} & \frac{t+b}{t-b} & 0 \\ 0 & 0 & -1 & -2n \\ 0 & 0 & -1 & 0 \end{pmatrix}$$
(注意：当 $f \to -\infty$, $\frac{n+f}{n-f} \to -1$, $\frac{2fn}{n-f} \to -2n$)</li>
</ul>
</li>
<li><strong>OpenGL透视矩阵 ($P_{OpenGL}$)</strong> (公式 4.74): 先乘以 $S(1,1,-1,1)$ (镜像变换，第三列取反)，然后用户输入正的 $n', f'$ ($0 < n' < f'$，但仍表示沿负z轴距离)。
$$P_{OpenGL} = \begin{pmatrix} \frac{2n'}{r-l} & 0 & \frac{r+l}{r-l} & 0 \\ 0 & \frac{2n'}{t-b} & \frac{t+b}{t-b} & 0 \\ 0 & 0 & -\frac{f'+n'}{f'-n'} & -\frac{2f'n'}{f'-n'} \\ 0 & 0 & -1 & 0 \end{pmatrix}$$</li>
<li><strong>从FOV_y, aspect, n&rsquo;, f&rsquo; 构造OpenGL透视矩阵</strong> (公式 4.75):
$c = 1.0/\tan(\phi/2)$，其中 $\phi$ 是垂直FOV。$a = w/h$ 是宽高比。
$$P_{OpenGL} = \begin{pmatrix} c/a & 0 & 0 & 0 \\ 0 & c & 0 & 0 \\ 0 & 0 & -\frac{f'+n'}{f'-n'} & -\frac{2f'n'}{f'-n'} \\ 0 & 0 & -1 & 0 \end{pmatrix}$$
(这与旧的 <code>gluPerspective()</code> 功能相同)。</li>
<li><strong>DirectX透视矩阵 ($P_{p[0,1]}$)</strong> (公式 4.76): $z$ 映射到 $[0,1]$，左手坐标系 (沿正z轴看)，$n', f'$ 为正数。
$$P_{p[0,1]} = \begin{pmatrix} \frac{2n'}{r-l} & 0 & \frac{r+l}{l-r} & 0 \\ 0 & \frac{2n'}{t-b} & \frac{t+b}{b-t} & 0 \\ 0 & 0 & \frac{f'}{f'-n'} & -\frac{f'n'}{f'-n'} \\ 0 & 0 & 1 & 0 \end{pmatrix}$$
(注意：DirectX矩阵通常转置书写)。</li>
<li><strong>深度缓冲非线性问题</strong>: 计算出的深度值 $z_{NDC}$ 与输入 $p_z$ 不呈线性关系。
$z_{NDC} = d - e/p_z$ (公式 4.78)，其中 $z_{NDC} \in [-1, +1]$ (OpenGL)。输出深度与输入深度成反比。
<ul>
<li>例如，若 $n'=10, f'=110$ (OpenGL)，$p_z = -60$ (中点)，则 $z_{NDC}=0.833$ 而非0。</li>
<li>近平面离原点越近，远平面附近的点使用的NDC深度空间范围越小，导致远处z缓冲精度降低 (图 4.21)。</li>
<li>近远平面设置影响z缓冲精度 (详见23.7)。</li>
</ul>
</li>
<li><strong>提高深度精度方法</strong>:
<ul>
<li><strong>反向Z (Reversed Z)</strong>: 存储 $1.0 - z_{NDC}$。对于浮点和整数深度缓冲都是最佳方法 (图 4.22)。</li>
<li>分离投影矩阵变换 [1803]。</li>
<li><strong>对数深度 (Logarithmic Depth)</strong> [1063, 991]:
Kemen [881] 提议 (公式 4.79): $z_{out} = w \cdot \log_2(\dots)$。
$f_c = 2/\log_2(f+1)$。可逐顶点或逐片元应用。</li>
<li><strong>多视锥体 (Multiple Frusta)</strong> [1605]: 将视锥体沿深度方向划分为多个子视锥体，从后往前渲染，每次清空深度缓冲。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进一步阅读和资源">
<a class="header-anchor" href="#%e8%bf%9b%e4%b8%80%e6%ad%a5%e9%98%85%e8%af%bb%e5%92%8c%e8%b5%84%e6%ba%90"></a>
进一步阅读和资源
</h3><ul>
<li>沉浸式线性代数网站 [1718]。</li>
<li>Farin and Hansford 的《The Geometry Toolbox》[461]。</li>
<li>Lengyel 的《Mathematics for 3D Game Programming and Computer Graphics》[1025]。</li>
<li>其他计算机图形学教材。</li>
<li>Graphics Gems 系列。</li>
<li>Golub and Van Loan 的《Matrix Computations》[556]。</li>
<li>关于骨骼子空间形变/顶点混合和形状插值的论文。</li>
<li>四元数可视化和插值相关文献。</li>
<li>变形技术综述。</li>
<li>Parent 的《Computer Animation》[1354]。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      

      

      

      

      

      

      
      <ul class="article-tag-list" itemprop="keywords">
  
</ul>

    </footer>
  </div>
  
    
  <nav
    id="article-nav"
    data-aos="fade-up"
  >
    
      <div class="article-nav-link-wrap article-nav-link-left">
        
          
          
            <img
              data-src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202412220910158.jpg"
              data-sizes="auto"
              alt="Unreal Engine 与着色器卡顿：PSO 预缓存解决方案"
              class="lazyload"
            />
          
        
        <a href="https://nothingtosay0031.github.io/post/ue_pso/"></a>
        <div class="article-nav-caption">Newer</div>
        <h3 class="article-nav-title">
          
            Unreal Engine 与着色器卡顿：PSO 预缓存解决方案
          
        </h3>
      </div>
    

    
  </nav>


  
</article>










</section>
          
            <aside id="sidebar">
  <div class="sidebar-wrapper wrap-sticky">
    <div
      class="sidebar-wrap"
      data-aos="fade-up"
    >
      
        <div class="sidebar-toc-sidebar">
          <div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#前言-preface">前言 (Preface)</a></li>
    <li><a href="#第一章导论-introduction">第一章：导论 (Introduction)</a>
      <ul>
        <li><a href="#11-内容概览-contents-overview">1.1 内容概览 (Contents Overview)</a></li>
        <li><a href="#12-符号和定义-notation-and-definitions">1.2 符号和定义 (Notation and Definitions)</a></li>
      </ul>
    </li>
    <li><a href="#第二章-图形渲染管线-the-graphics-rendering-pipeline">第二章 图形渲染管线 (The Graphics Rendering Pipeline)</a>
      <ul>
        <li><a href="#21-架构-architecture">2.1 架构 (Architecture)</a></li>
        <li><a href="#22-应用阶段-the-application-stage">2.2 应用阶段 (The Application Stage)</a></li>
        <li><a href="#23-几何处理阶段-geometry-processing">2.3 几何处理阶段 (Geometry Processing)</a></li>
        <li><a href="#24-光栅化-rasterization">2.4 光栅化 (Rasterization)</a></li>
        <li><a href="#25-像素处理-pixel-processing">2.5 像素处理 (Pixel Processing)</a></li>
        <li><a href="#26-完整管线流程示例-through-the-pipeline">2.6 完整管线流程示例 (Through the Pipeline)</a></li>
      </ul>
    </li>
    <li><a href="#第三章-图形处理单元-the-graphics-processing-unit">第三章 图形处理单元 (The Graphics Processing Unit)</a>
      <ul>
        <li><a href="#31-数据并行架构-data-parallel-architectures">3.1 数据并行架构 (Data-Parallel Architectures)</a></li>
        <li><a href="#32-gpu管线概述-gpu-pipeline-overview">3.2 GPU管线概述 (GPU Pipeline Overview)</a></li>
        <li><a href="#33-可编程着色器阶段-the-programmable-shader-stage">3.3 可编程着色器阶段 (The Programmable Shader Stage)</a></li>
        <li><a href="#34-可编程着色与api的演进-the-evolution-of-programmable-shading-and-apis">3.4 可编程着色与API的演进 (The Evolution of Programmable Shading and APIs)</a></li>
        <li><a href="#35-顶点着色器-the-vertex-shader">3.5 顶点着色器 (The Vertex Shader)</a></li>
        <li><a href="#36-曲面细分阶段-the-tessellation-stage">3.6 曲面细分阶段 (The Tessellation Stage)</a></li>
        <li><a href="#37-几何着色器-the-geometry-shader">3.7 几何着色器 (The Geometry Shader)</a></li>
        <li><a href="#38-像素着色器-pixel-shader--片段着色器-fragment-shader---opengl术语">3.8 像素着色器 (Pixel Shader) / 片段着色器 (Fragment Shader - OpenGL术语)</a></li>
        <li><a href="#39-合并阶段-the-merging-stage--输出合并器-output-merger---directx术语--每样本操作-per-sample-operations---opengl术语">3.9 合并阶段 (The Merging Stage) / 输出合并器 (Output Merger - DirectX术语) / 每样本操作 (Per-Sample Operations - OpenGL术语)</a></li>
        <li><a href="#310-计算着色器-the-compute-shader">3.10 计算着色器 (The Compute Shader)</a></li>
      </ul>
    </li>
    <li><a href="#第4章-变换-transforms">第4章 变换 (Transforms)</a>
      <ul>
        <li>
          <ul>
            <li><a href="#41-基础变换-basic-transforms">4.1 基础变换 (Basic Transforms)</a></li>
            <li><a href="#42-特殊矩阵变换和运算-special-matrix-transforms-and-operations">4.2 特殊矩阵变换和运算 (Special Matrix Transforms and Operations)</a></li>
            <li><a href="#43-四元数-quaternions">4.3 四元数 (Quaternions)</a></li>
            <li><a href="#44-顶点混合-vertex-blending">4.4 顶点混合 (Vertex Blending)</a></li>
            <li><a href="#45-变形-morphing">4.5 变形 (Morphing)</a></li>
            <li><a href="#46-几何缓存回放-geometry-cache-playback">4.6 几何缓存回放 (Geometry Cache Playback)</a></li>
            <li><a href="#47-投影-projections">4.7 投影 (Projections)</a></li>
            <li><a href="#进一步阅读和资源">进一步阅读和资源</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
        </div>
        <div class="sidebar-common-sidebar hidden">
          
<div class="sidebar-author">
  <img
    data-src="https://nothingtosay0031.github.io/avatar/../avatar.webp"
    data-sizes="auto"
    alt="NothingToSay0031"
    class="lazyload"
  />
  <div class="sidebar-author-name">NothingToSay0031</div>
  <div class="sidebar-description">又是一个做水果蛋糕的好天气啊！</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div>
    
    <div class="sidebar-state-number">22</div>
  </div>
  <div class="sidebar-state-category">
    <div>Categories</div>
    <div class="sidebar-state-number">
      0
    </div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tags</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-email sidebar-social-icon">
      <a
        href="mailto:jhwzju@gmail.com"
        itemprop="url"
        target="_blank"
        aria-label="email"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-github sidebar-social-icon">
      <a
        href="https://github.com/NothingToSay0031"
        itemprop="url"
        target="_blank"
        aria-label="github"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-linkedin sidebar-social-icon">
      <a
        href="https://www.linkedin.com/in/hongweiji"
        itemprop="url"
        target="_blank"
        aria-label="linkedin"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/"
        aria-label="Home"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Home</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/archives"
        aria-label="Archives"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Archives</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/about"
        aria-label="About"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">About</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/friend"
        aria-label="Friend"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Friend</div>
    </div>
  
</div>

        </div>
      

      
        <div class="sidebar-btn-wrapper" style="position:static">
          <div class="sidebar-toc-btn current"></div>
          <div class="sidebar-common-btn"></div>
        </div>
      
    </div>
  </div>

  
</aside>

          
        </main>
        



  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  



<footer id="footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div id="footer-info">
    <div>
      <span class="icon-copyright"></span>
      2021 -
      2025
      <span class="footer-info-sep rotate"></span>
      NothingToSay0031
    </div>
    
      <div>
        Powered by&nbsp;<a
          href="https://gohugo.io/"
          target="_blank"
          >Hugo</a
        >&nbsp; Theme.<a
          href="https://github.com/D-Sketon/hugo-theme-reimu"
          target="_blank"
          >Reimu</a
        >
      </div>
    
    
      <div>
        <span class="icon-brush"
          >&nbsp;
            55.6k
          </span
        >
        &nbsp;|&nbsp;
        <span class="icon-coffee">&nbsp;
          
          

          04:33
        </span>
      </div>
    
    
    
    
      <div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv"
          >Number of visits&nbsp;<span
            id="busuanzi_value_site_pv"
          ></span
        ></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv"
          >Number of visitors&nbsp;<span
            id="busuanzi_value_site_uv"
          ></span
        ></span>
      </div>
    
  </div>
</footer>

        
          <div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div>
        
        <div id="mask" class="hide"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar">
        <div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#前言-preface">前言 (Preface)</a></li>
    <li><a href="#第一章导论-introduction">第一章：导论 (Introduction)</a>
      <ul>
        <li><a href="#11-内容概览-contents-overview">1.1 内容概览 (Contents Overview)</a></li>
        <li><a href="#12-符号和定义-notation-and-definitions">1.2 符号和定义 (Notation and Definitions)</a></li>
      </ul>
    </li>
    <li><a href="#第二章-图形渲染管线-the-graphics-rendering-pipeline">第二章 图形渲染管线 (The Graphics Rendering Pipeline)</a>
      <ul>
        <li><a href="#21-架构-architecture">2.1 架构 (Architecture)</a></li>
        <li><a href="#22-应用阶段-the-application-stage">2.2 应用阶段 (The Application Stage)</a></li>
        <li><a href="#23-几何处理阶段-geometry-processing">2.3 几何处理阶段 (Geometry Processing)</a></li>
        <li><a href="#24-光栅化-rasterization">2.4 光栅化 (Rasterization)</a></li>
        <li><a href="#25-像素处理-pixel-processing">2.5 像素处理 (Pixel Processing)</a></li>
        <li><a href="#26-完整管线流程示例-through-the-pipeline">2.6 完整管线流程示例 (Through the Pipeline)</a></li>
      </ul>
    </li>
    <li><a href="#第三章-图形处理单元-the-graphics-processing-unit">第三章 图形处理单元 (The Graphics Processing Unit)</a>
      <ul>
        <li><a href="#31-数据并行架构-data-parallel-architectures">3.1 数据并行架构 (Data-Parallel Architectures)</a></li>
        <li><a href="#32-gpu管线概述-gpu-pipeline-overview">3.2 GPU管线概述 (GPU Pipeline Overview)</a></li>
        <li><a href="#33-可编程着色器阶段-the-programmable-shader-stage">3.3 可编程着色器阶段 (The Programmable Shader Stage)</a></li>
        <li><a href="#34-可编程着色与api的演进-the-evolution-of-programmable-shading-and-apis">3.4 可编程着色与API的演进 (The Evolution of Programmable Shading and APIs)</a></li>
        <li><a href="#35-顶点着色器-the-vertex-shader">3.5 顶点着色器 (The Vertex Shader)</a></li>
        <li><a href="#36-曲面细分阶段-the-tessellation-stage">3.6 曲面细分阶段 (The Tessellation Stage)</a></li>
        <li><a href="#37-几何着色器-the-geometry-shader">3.7 几何着色器 (The Geometry Shader)</a></li>
        <li><a href="#38-像素着色器-pixel-shader--片段着色器-fragment-shader---opengl术语">3.8 像素着色器 (Pixel Shader) / 片段着色器 (Fragment Shader - OpenGL术语)</a></li>
        <li><a href="#39-合并阶段-the-merging-stage--输出合并器-output-merger---directx术语--每样本操作-per-sample-operations---opengl术语">3.9 合并阶段 (The Merging Stage) / 输出合并器 (Output Merger - DirectX术语) / 每样本操作 (Per-Sample Operations - OpenGL术语)</a></li>
        <li><a href="#310-计算着色器-the-compute-shader">3.10 计算着色器 (The Compute Shader)</a></li>
      </ul>
    </li>
    <li><a href="#第4章-变换-transforms">第4章 变换 (Transforms)</a>
      <ul>
        <li>
          <ul>
            <li><a href="#41-基础变换-basic-transforms">4.1 基础变换 (Basic Transforms)</a></li>
            <li><a href="#42-特殊矩阵变换和运算-special-matrix-transforms-and-operations">4.2 特殊矩阵变换和运算 (Special Matrix Transforms and Operations)</a></li>
            <li><a href="#43-四元数-quaternions">4.3 四元数 (Quaternions)</a></li>
            <li><a href="#44-顶点混合-vertex-blending">4.4 顶点混合 (Vertex Blending)</a></li>
            <li><a href="#45-变形-morphing">4.5 变形 (Morphing)</a></li>
            <li><a href="#46-几何缓存回放-geometry-cache-playback">4.6 几何缓存回放 (Geometry Cache Playback)</a></li>
            <li><a href="#47-投影-projections">4.7 投影 (Projections)</a></li>
            <li><a href="#进一步阅读和资源">进一步阅读和资源</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
      </div>
      <div class="sidebar-common-sidebar hidden">
        
<div class="sidebar-author">
  <img
    data-src="https://nothingtosay0031.github.io/avatar/../avatar.webp"
    data-sizes="auto"
    alt="NothingToSay0031"
    class="lazyload"
  />
  <div class="sidebar-author-name">NothingToSay0031</div>
  <div class="sidebar-description">又是一个做水果蛋糕的好天气啊！</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div>
    
    <div class="sidebar-state-number">22</div>
  </div>
  <div class="sidebar-state-category">
    <div>Categories</div>
    <div class="sidebar-state-number">
      0
    </div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tags</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-email sidebar-social-icon">
      <a
        href="mailto:jhwzju@gmail.com"
        itemprop="url"
        target="_blank"
        aria-label="email"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-github sidebar-social-icon">
      <a
        href="https://github.com/NothingToSay0031"
        itemprop="url"
        target="_blank"
        aria-label="github"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-linkedin sidebar-social-icon">
      <a
        href="https://www.linkedin.com/in/hongweiji"
        itemprop="url"
        target="_blank"
        aria-label="linkedin"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/"
        aria-label="Home"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Home</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/archives"
        aria-label="Archives"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Archives</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/about"
        aria-label="About"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">About</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/friend"
        aria-label="Friend"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Friend</div>
    </div>
  
</div>

      </div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    
    






  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js"
    
    
    
    
    integrity="sha384-3gT/vsepWkfz/ff7PpWNUeMzeWoH3cDhm/A8jM7ouoAK0/fP/9bcHHR5kHq2nf&#43;e" crossorigin="anonymous"
  ></script>




  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js"
    
    
    
    
    integrity="sha384-J08i8An/QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"
  ></script>









  
      
      <script src="https://nothingtosay0031.github.io/js/main.js" integrity="" crossorigin="anonymous" ></script>
      



  





  
      
      <script src="https://nothingtosay0031.github.io/js/aos.js" integrity="" crossorigin="anonymous" ></script>
      

  <script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", aosInit);
    } else {
      aosInit();
    }
  </script>








  
      
      <script src="https://nothingtosay0031.github.io/js/pjax_main.js" integrity="" crossorigin="anonymous" data-pjax></script>
      





  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/mouse-firework@0.0.6/dist/index.umd.js"
    
    
    
    
    integrity="sha384-vkGvf25gm1C1PbcoD5dNfc137HzNL/hr1RKA5HniJOaawtvUmH5lTVFgFAruE9Ge" crossorigin="anonymous"
  ></script>


<script>
  if (window.firework) {
    const options = JSON.parse("{\"excludeelements\":[\"a\",\"button\"],\"particles\":[{\"colors\":[\"#ff5252\",\"#ff7c7c\",\"#ffafaf\",\"#ffd0d0\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"emit\"],\"number\":20,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.3,0.5],\"radius\":[16,32]}},{\"colors\":[\"#ff0000\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"diffuse\"],\"number\":1,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.2,0.5],\"lineWidth\":6,\"radius\":20}}]}");
    options.excludeElements = options.excludeelements;
    delete options.excludeelements;
    window.firework(options);
  }
</script>








<div id="lazy-script">
  <div>
    
    
      





  
      
      <script src="https://nothingtosay0031.github.io/js/insert_highlight.js" integrity="" crossorigin="anonymous" data-pjax></script>
      

      
      
      
      
      <script type="module" data-pjax>
        const PhotoSwipeLightbox = (await safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe-lightbox.esm.min.js", "sha384-DiL6M\/gG\u002bwmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF\/N6lrZi\/")).default;

        const pswp = () => {
          if (_$$('.article-entry a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-entry',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")
            }).init();
          }
          if(_$$('.article-gallery a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-gallery',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")
            }).init();
          }
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script>
      












    
    
      
        

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/katex@0.16.9/dist/katex.min.js"
    
    
    data-pjax
    
    integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8" crossorigin="anonymous"
  ></script>


        

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/katex@0.16.9/dist/contrib/auto-render.min.js"
    
    
    data-pjax
    
    integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05" crossorigin="anonymous"
  ></script>


        <script data-pjax>
          var renderMath = () => {
            if (!window.renderMathInElement) return;
            window.renderMathInElement(document.body, {
              delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "\\[", right: "\\]", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
              ],
            });
          };
          if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", renderMath, { once: true });
          } else {
            renderMath();
          }
        </script>
      
      
    
  </div>
</div>




  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js"
    
    async
    
    
    integrity="sha384-0M75wtSkhjIInv4coYlaJU83&#43;OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id&#43;S" crossorigin="anonymous"
  ></script>





  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then((registrations) => {
        for (let registration of registrations) {
          registration.unregister();
        }
      });
    }
  </script>


<script>
  const reimuCopyright = String.raw`
   ______     ______     __     __    __     __  __    
  /\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
  \ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
   \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
    \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                    
  `;
  console.log(String.raw`%c ${reimuCopyright}`, "color: #ff5252;");
  console.log(
    "%c Theme.Reimu" + " %c https://github.com/D-Sketon/hugo-theme-reimu ",
    "color: white; background: #ff5252; padding:5px 0;",
    "padding:4px;border:1px solid #ff5252;",
  );
</script>

  </body>
</html>
