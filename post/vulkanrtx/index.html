<!doctype html>
<html
  lang="en-us"
  
>
  <head>
    <meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, shrink-to-fit=no"
/>







  

<title>
  Realtime Ray Tracing with Vulkan | NothingToSay0031
</title>
<meta
  name="description"
  content="DDGI, Raytraced Shadows, Raytraced Reflections, and TAA."
/>










<script>
  window.siteConfig = JSON.parse("{\"anchor_icon\":null,\"clipboard\":{\"copyright\":{\"content\":\"本文版权：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！\",\"count\":50,\"enable\":false},\"fail\":\"复制失败 (ﾟ⊿ﾟ)ﾂ\",\"success\":\"复制成功(*^▽^*)\"},\"code_block\":{\"expand\":true},\"icon_font\":\"4552607_tq6stt6tcg\",\"outdate\":{\"daysago\":180,\"enable\":false,\"message\":\"本文最后更新于 {time}，请注意文中内容可能已经发生变化。\"}}");
</script>











  
  
  
    
  

  
  
  
    
  

  
    

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  rel="preload"
  as="style"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
/>
<link
  rel="stylesheet"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
  media="print"
  onload="this.media='all'"
/>






  <link
    rel="preload"
    href="//at.alicdn.com/t/c/font_4552607_tq6stt6tcg.woff2"
    as="font"
    type="font/woff2"
    crossorigin="anonymous"
  />



  







  
 <link rel="stylesheet" href="https://nothingtosay0031.github.io/css/loader.min.2ad0e9bbffb534e893c0ecefc44787a277cf851387e8ad9dccfbc3a5f0886dbe.css" />




  <meta property="og:type" content="website" />
  <meta property="og:title" content="Realtime Ray Tracing with Vulkan | NothingToSay0031" />
  <meta
    property="og:description"
    content="DDGI, Raytraced Shadows, Raytraced Reflections, and TAA."
  />
  <meta property="og:url" content="https://nothingtosay0031.github.io/post/vulkanrtx/" />
  <meta
    property="og:site_name"
    content="NothingToSay0031"
  />
  <meta
    property="og:image"
    content="/"
  />
  <meta property="article:author" content="NothingToSay0031" />
  <meta property="article:published_time" content="2025-05-25T15:11:48&#43;00:00" />
  <meta property="article:modified_time" content="2025-05-25T15:11:48&#43;00:00" />
  
  
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:image" content="/" />
  
  
  
  
  




<link rel="shortcut icon" href="https://nothingtosay0031.github.io/favicon.ico">








  
 <link rel="stylesheet" href="https://nothingtosay0031.github.io/css/main.min.4e3ed4ec96a449612baa01e942ad2e62fab14c5e1e8f6b3eeb13d1cbc2e0dc67.css" />





  <link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css"
    onload="this.onload=null;this.rel='stylesheet'"
  />






  <link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/katex@0.16.9/dist/katex.min.css"
    onload="this.onload=null;this.rel='stylesheet'"
  />








  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js"
    
    
    
    
    integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"
  ></script>





  


  <link rel="stylesheet" href="https://npm.webcache.cn/@reimujs/aos@0.1.0/dist/aos.css" />




  </head>
  <body>
    
  <div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        
          <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
            <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="#ff5252" />
            <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z 
          M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95z" fill="#ff5252" />
          </svg>
        
      </div>
      <div class="loading-word">少女祈祷中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>


<div id="copy-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
</div>


    <div id="container">
      <div id="wrap">
        
<div id="header-nav">
  <nav id="main-nav">
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/">Home</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/archives">Archives</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/about">About</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/friend">Friend</a>
      </span>
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
    
  </nav>
</div>
<header id="header">
  
    <img fetchpriority="high" src="https://nothingtosay0031.github.io/images/banner.webp" alt="Realtime Ray Tracing with Vulkan">
  

  <div id="header-outer">
    <div id="header-title">
      
        
        
          
        
  
        
          <a href="https://nothingtosay0031.github.io/" id="logo">
            <h1 data-aos="slide-up">Realtime Ray Tracing with Vulkan</h1>
          </a>
        
      
  
      
        
        
        <h2 id="subtitle-wrap" data-aos="slide-down">
          
        </h2>
      
    </div>
  </div>
</header>
        <main id="content">
          
          <section id="main">
  <article
  class="h-entry article"
  itemprop="blogPost"
  itemscope
  itemtype="https://schema.org/BlogPosting"
>
  <div
    class="article-inner"
    data-aos="fade-up"
  >
    <div class="article-meta">
      <div class="article-date">
  <a
    href="https://nothingtosay0031.github.io/post/vulkanrtx/"
    class="article-date-link"
    data-aos="zoom-in"
  >
    <time datetime="2025-05-25 15:11:48 &#43;0000 UTC" itemprop="datePublished"
      >2025-05-25</time
    >
    <time style="display: none;" id="post-update-time"
      >2025-05-25</time
    >
  </a>
</div>

      <div class="article-category">
  
</div>

    </div>
    <div class="hr-line"></div>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
      
        <h1 id="dynamic-diffuse-global-illumination-ddgi">
<a class="header-anchor" href="#dynamic-diffuse-global-illumination-ddgi"></a>
Dynamic Diffuse Global Illumination (DDGI)
</h1><p>动态漫反射全局光照（DDGI）是一种用于实时渲染中模拟间接光照的强大技术。其核心思想是在场景中布置一个规则的探针网格（Probe Grid），并预计算每个探针接收到的来自周围环境的光照。</p>
<h2 id="辐射度采集-gather-radiance">
<a class="header-anchor" href="#%e8%be%90%e5%b0%84%e5%ba%a6%e9%87%87%e9%9b%86-gather-radiance"></a>
辐射度采集 (Gather Radiance)
</h2><p>此阶段的目标是为场景中的每个光照探针（Light Probe）计算其从各个方向接收到的入射光（Radiance）和对应的光线传播距离。这本质上是一个大规模的光线追踪过程，我们从每个探针的位置向半球或全球领域发射大量光线，记录它们击中场景后的光照信息。</p>
<p>最终的输出是一张二维纹理 <code>probe_raytrace_radiance_texture</code>，其尺寸为 <code>[num_rays, num_probes]</code>。纹理中的每一个像素 <code>(x, y)</code> 存储了第 <code>y</code> 个探针沿第 <code>x</code> 个方向发射的光线所采集到的辐射度（RGB）和距离（A）。</p>
<p><img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507201311937.png" alt=""></p>
<h3 id="数据流与gpu调度">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e6%b5%81%e4%b8%8egpu%e8%b0%83%e5%ba%a6"></a>
数据流与GPU调度
</h3><p>在CPU端，我们通过一个光线追踪指令来启动整个GPU计算过程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 准备工作：确保目标纹理处于可写入状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">issue_texture_barrier</span><span class="p">(</span><span class="n">probe_raytrace_radiance_texture</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">RESOURCE_STATE_UNORDERED_ACCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 绑定光线追踪管线和所需的资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">bind_pipeline</span><span class="p">(</span><span class="n">probe_raytrace_pipeline</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">bind_descriptor_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">probe_raytrace_descriptor_set</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 确定需要更新的探针数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="n">u32</span> <span class="n">probe_count</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">offsets_calculations_count</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">get_total_probes</span><span class="p">()</span> <span class="o">:</span> <span class="n">per_frame_probe_updates</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 发射光线：为每个探针（probe_count）发射指定数量（probe_rays）的光线
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">trace_rays</span><span class="p">(</span><span class="n">probe_raytrace_pipeline</span><span class="p">,</span> <span class="n">probe_rays</span><span class="p">,</span> <span class="n">probe_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 计算完成后，再次设置屏障，以便后续阶段可以读取该纹理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">issue_texture_barrier</span><span class="p">(</span><span class="n">probe_raytrace_radiance_texture</span><span class="p">,</span> <span class="n">RESOURCE_STATE_UNORDERED_ACCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></div><p><code>trace_rays</code> 函数是核心。它在GPU上启动一个 <code>probe_rays * probe_count</code> 的二维计算网格。GPU上的每个工作单元（线程）将负责处理一个探针的一条光线。</p>
<h3 id="ray-generation-shader-射线生成着色器">
<a class="header-anchor" href="#ray-generation-shader-%e5%b0%84%e7%ba%bf%e7%94%9f%e6%88%90%e7%9d%80%e8%89%b2%e5%99%a8"></a>
Ray Generation Shader (射线生成着色器)
</h3><p>这是光追管线的入口点。每个线程执行一次，负责生成一条光线的起点、方向，并发起追踪。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// layout(binding = X) uniform accelerationStructureEXT as;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// layout(binding = Y, set = 0, rgba32f) uniform image2D radiance_output_texture;</span>
</span></span><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span> <span class="n">location</span> <span class="o">=</span> <span class="mo">0</span> <span class="p">)</span> <span class="n">rayPayloadEXT</span> <span class="n">RayPayload</span> <span class="n">payload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// gl_LaunchIDEXT 是内置变量，代表当前线程在网格中的二维索引</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// .x 是光线索引, .y 是探针索引</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">ivec2</span> <span class="n">pixel_coord</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">gl_LaunchIDEXT</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">int</span> <span class="n">probe_index</span> <span class="o">=</span> <span class="n">pixel_coord</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">probe_update_offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">int</span> <span class="n">ray_index</span> <span class="o">=</span> <span class="n">pixel_coord</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 省略探针状态检查 ...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 计算光线起点 (Ray Origin)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    将一维的探针索引转换为三维网格坐标，再转换到世界空间位置</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec3</span> <span class="n">probe_grid_indices</span> <span class="o">=</span> <span class="n">probe_index_to_grid_indices</span><span class="p">(</span><span class="n">probe_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">ray_origin</span> <span class="o">=</span> <span class="n">grid_indices_to_world</span><span class="p">(</span><span class="n">probe_grid_indices</span><span class="p">,</span> <span class="n">probe_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 计算光线方向 (Ray Direction)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    使用球斐波那契晶格（Spherical Fibonacci）生成均匀分布在球面上的方向</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    再通过一个随机旋转矩阵来抖动采样，避免时间上的条带瑕疵</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">random_rotation</span><span class="p">)</span> <span class="o">*</span> <span class="n">spherical_fibonacci</span><span class="p">(</span><span class="n">ray_index</span><span class="p">,</span> <span class="n">probe_rays</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 初始化光线负载 (Payload)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    Payload 是用于在着色器之间传递数据的结构体</span>
</span></span><span class="line"><span class="cl">    <span class="n">payload</span><span class="p">.</span><span class="n">radiance</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">payload</span><span class="p">.</span><span class="n">distance</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4. 发射光线</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    调用内置函数，在场景加速结构（as）中追踪光线</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    如果命中，将调用 Closest Hit Shader；否则调用 Miss Shader</span>
</span></span><span class="line"><span class="cl">    <span class="n">traceRayEXT</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">gl_RayFlagsOpaqueEXT</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="n">ray_origin</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 5. 存储结果</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    光线追踪结束后，Payload 中已写入了命中点的辐射度和距离</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    将结果写入输出纹理的对应位置</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">global_images_2d</span><span class="p">[</span><span class="n">radiance_output_index</span><span class="p">],</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">ray_index</span><span class="p">,</span> <span class="n">probe_index</span><span class="p">),</span> <span class="k">vec4</span><span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="n">radiance</span><span class="p">,</span> <span class="n">payload</span><span class="p">.</span><span class="n">distance</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>spherical_fibonacci</code> 函数是实现均匀球面采样的关键。为了用蒙特卡洛方法估算一个点接收到的半球积分（渲染方程），我们需要在半球上生成一系列分布均匀的采样方向。相比于简单的随机采样，斐波那契晶格能以更少的样本数达到更好的分布效果，减少噪点。</p>
<h3 id="closest-hit-shader-最近命中着色器">
<a class="header-anchor" href="#closest-hit-shader-%e6%9c%80%e8%bf%91%e5%91%bd%e4%b8%ad%e7%9d%80%e8%89%b2%e5%99%a8"></a>
Closest Hit Shader (最近命中着色器)
</h3><p>当光线击中场景中的某个几何体时，该着色器被调用。它的核心职责是确定命中点的光照信息。然而，与传统渲染不同，DDGI中的光线是从探针发出的，探针本身可能位于几何体内部或与其表面非常接近。因此，我们必须区分光线是击中了物体的“正面”还是“背面”。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">buffer_reference</span><span class="p">,</span> <span class="n">std430</span><span class="p">,</span> <span class="n">buffer_reference_align</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">buffer</span> <span class="n">int_array_type</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint16_t</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">buffer_reference</span><span class="p">,</span> <span class="n">std430</span><span class="p">,</span> <span class="n">buffer_reference_align</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="n">buffer</span> <span class="n">vec2_array_type</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">buffer_reference</span><span class="p">,</span> <span class="n">std430</span><span class="p">,</span> <span class="n">buffer_reference_align</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="n">buffer</span> <span class="n">float_array_type</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span> <span class="n">location</span> <span class="o">=</span> <span class="mo">0</span> <span class="p">)</span> <span class="n">rayPayloadInEXT</span> <span class="n">RayPayload</span> <span class="n">payload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">hitAttributeEXT</span> <span class="k">vec2</span> <span class="n">barycentric_weights</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化输出变量</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">radiance</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">distance</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 步骤 0: 处理背面命中 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这是一个关键的健壮性处理。如果光线击中三角形的背面，</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 通常意味着探针位于模型内部。我们不计算光照，</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 而是将距离标记为负数，以在后续阶段识别并处理这种情况，防止漏光。</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">gl_HitKindEXT</span> <span class="o">==</span> <span class="n">gl_HitKindBackFacingTriangleEXT</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">distance</span> <span class="o">=</span> <span class="p">(</span><span class="n">gl_RayTminEXT</span> <span class="o">+</span> <span class="n">gl_HitTEXT</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="mf">0.2</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 步骤 1: 获取命中几何体的数据 ---</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 使用光追管线提供的内置变量，定位到具体的模型实例和三角形。</span>
</span></span><span class="line"><span class="cl">        <span class="n">uint</span> <span class="n">mesh_index</span> <span class="o">=</span> <span class="n">mesh_instance_draws</span><span class="p">[</span><span class="n">gl_GeometryIndexEXT</span><span class="p">].</span><span class="n">mesh_draw_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">MeshDraw</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh_draws</span><span class="p">[</span><span class="n">mesh_index</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 从索引缓冲区获取构成该三角形的三个顶点的索引。</span>
</span></span><span class="line"><span class="cl">        <span class="n">int_array_type</span> <span class="n">index_buffer</span> <span class="o">=</span> <span class="n">int_array_type</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">index_buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">int</span> <span class="n">i0</span> <span class="o">=</span> <span class="n">index_buffer</span><span class="p">[</span><span class="n">gl_PrimitiveID</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mo">0</span><span class="p">].</span><span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">index_buffer</span><span class="p">[</span><span class="n">gl_PrimitiveID</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">int</span> <span class="n">i2</span> <span class="o">=</span> <span class="n">index_buffer</span><span class="p">[</span><span class="n">gl_PrimitiveID</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">].</span><span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 步骤 2: 使用重心坐标插值顶点属性 ---</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 硬件会提供命中点在三角形内的精确重心坐标。</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">b</span> <span class="o">=</span> <span class="n">barycentric_weights</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">c</span> <span class="o">=</span> <span class="n">barycentric_weights</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">-</span> <span class="n">b</span> <span class="o">-</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 从顶点缓冲区中获取三个顶点的局部坐标。</span>
</span></span><span class="line"><span class="cl">        <span class="n">float_array_type</span> <span class="n">vertex_buffer</span> <span class="o">=</span> <span class="n">float_array_type</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">position_buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec4</span> <span class="n">p0</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">vertex_buffer</span><span class="p">[</span><span class="n">i0</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mo">0</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">vertex_buffer</span><span class="p">[</span><span class="n">i0</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">vertex_buffer</span><span class="p">[</span><span class="n">i0</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec4</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">vertex_buffer</span><span class="p">[</span><span class="n">i1</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mo">0</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">vertex_buffer</span><span class="p">[</span><span class="n">i1</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">vertex_buffer</span><span class="p">[</span><span class="n">i1</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec4</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">vertex_buffer</span><span class="p">[</span><span class="n">i2</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mo">0</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">vertex_buffer</span><span class="p">[</span><span class="n">i2</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">vertex_buffer</span><span class="p">[</span><span class="n">i2</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 将顶点位置变换到世界空间。</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">mat4</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">mesh_instance_draws</span><span class="p">[</span><span class="n">gl_GeometryIndexEXT</span><span class="p">].</span><span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec4</span> <span class="n">p0_world</span> <span class="o">=</span> <span class="n">transform</span> <span class="o">*</span> <span class="n">p0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec4</span> <span class="n">p1_world</span> <span class="o">=</span> <span class="n">transform</span> <span class="o">*</span> <span class="n">p1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec4</span> <span class="n">p2_world</span> <span class="o">=</span> <span class="n">transform</span> <span class="o">*</span> <span class="n">p2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 插值计算出命中点的精确世界坐标。</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="k">vec3</span> <span class="n">world_position</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">p0_world</span><span class="p">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">p1_world</span><span class="p">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">p2_world</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 同理，插值计算出UV坐标。</span>
</span></span><span class="line"><span class="cl">        <span class="n">vec2_array_type</span> <span class="n">uv_buffer</span> <span class="o">=</span> <span class="n">vec2_array_type</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">uv_buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec2</span> <span class="n">uv0</span> <span class="o">=</span> <span class="n">uv_buffer</span><span class="p">[</span><span class="n">i0</span><span class="p">].</span><span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec2</span> <span class="n">uv1</span> <span class="o">=</span> <span class="n">uv_buffer</span><span class="p">[</span><span class="n">i1</span><span class="p">].</span><span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec2</span> <span class="n">uv2</span> <span class="o">=</span> <span class="n">uv_buffer</span><span class="p">[</span><span class="n">i2</span><span class="p">].</span><span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec2</span> <span class="n">uv</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">uv0</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">uv1</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">uv2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 插值计算出平滑的顶点法线。</span>
</span></span><span class="line"><span class="cl">        <span class="n">float_array_type</span> <span class="n">normals_buffer</span> <span class="o">=</span> <span class="n">float_array_type</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">normals_buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">n0</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="n">normals_buffer</span><span class="p">[</span><span class="n">i0</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mo">0</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">normals_buffer</span><span class="p">[</span><span class="n">i0</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">normals_buffer</span><span class="p">[</span><span class="n">i0</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">].</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">n1</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="n">normals_buffer</span><span class="p">[</span><span class="n">i1</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mo">0</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">normals_buffer</span><span class="p">[</span><span class="n">i1</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">normals_buffer</span><span class="p">[</span><span class="n">i1</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">].</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">n2</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="n">normals_buffer</span><span class="p">[</span><span class="n">i2</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mo">0</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">normals_buffer</span><span class="p">[</span><span class="n">i2</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">normals_buffer</span><span class="p">[</span><span class="n">i2</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">].</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">normal</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">n0</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">n2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 将法线变换到世界空间（注意：法线变换应使用模型矩阵的逆转置矩阵）。</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">mat3</span> <span class="n">normal_transform</span> <span class="o">=</span> <span class="n">mat3</span><span class="p">(</span><span class="n">mesh_instance_draws</span><span class="p">[</span><span class="n">gl_GeometryIndexEXT</span><span class="p">].</span><span class="n">model_inverse</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">normal_transform</span> <span class="o">*</span> <span class="n">normal</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 步骤 3: 获取表面材质属性 ---</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 使用插值得到的UV坐标采样反照率（Albedo）贴图。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 指定一个较低的LOD层级可以提升性能，因为GI的精度要求不高。</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">albedo</span> <span class="o">=</span> <span class="n">textureLod</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">textures</span><span class="p">.</span><span class="n">x</span><span class="p">)],</span> <span class="n">uv</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 步骤 4: 计算直接光照 ---</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 这里实现了一个简单的 Lambertian 光照模型。</span>
</span></span><span class="line"><span class="cl">        <span class="n">Light</span> <span class="n">light</span> <span class="o">=</span> <span class="n">lights</span><span class="p">[</span><span class="mo">0</span><span class="p">];</span> <span class="c1">// 假设场景中至少有一个光源。</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="k">vec3</span> <span class="n">position_to_light</span> <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">world_position</span> <span class="o">-</span> <span class="n">world_position</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="k">vec3</span> <span class="n">l</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">position_to_light</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="k">float</span> <span class="n">NoL</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 计算光照衰减。</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="n">attenuation_square_falloff</span><span class="p">(</span><span class="n">position_to_light</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">/</span> <span class="n">light</span><span class="p">.</span><span class="n">radius</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 组合光照贡献。</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">light_intensity</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">attenuation</span> <span class="o">&gt;</span> <span class="mf">0.001</span><span class="n">f</span> <span class="o">&amp;&amp;</span> <span class="n">NoL</span> <span class="o">&gt;</span> <span class="mf">0.001</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">light_intensity</span> <span class="o">+=</span> <span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">intensity</span> <span class="o">*</span> <span class="n">attenuation</span> <span class="o">*</span> <span class="n">NoL</span><span class="p">)</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="n">albedo</span> <span class="o">*</span> <span class="n">light_intensity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 步骤 5: (可选) 计算间接光照（多轮反弹） ---</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 这是DDGI实现无限反弹效果的核心。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 通过采样周围的探针数据来近似当前点的间接光照。</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">use_infinite_bounces</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">diffuse</span> <span class="o">+=</span> <span class="n">albedo</span> <span class="o">*</span> <span class="n">sample_irradiance</span><span class="p">(</span><span class="n">world_position</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">camera_position</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">*</span> <span class="n">infinite_bounces_multiplier</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 步骤 6: 为正面命中设置最终输出 ---</span>
</span></span><span class="line"><span class="cl">        <span class="n">radiance</span> <span class="o">=</span> <span class="n">diffuse</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">distance</span> <span class="o">=</span> <span class="n">gl_RayTminEXT</span> <span class="o">+</span> <span class="n">gl_HitTEXT</span><span class="p">;</span> <span class="c1">// 距离是正值。</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 最终步骤: 将结果写回光线负载 (Payload) ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 无论命中正面还是背面，都将计算出的 radiance 和 distance 返回。</span>
</span></span><span class="line"><span class="cl">    <span class="n">payload</span><span class="p">.</span><span class="n">radiance</span> <span class="o">=</span> <span class="n">radiance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">payload</span><span class="p">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="miss-shader-未命中着色器">
<a class="header-anchor" href="#miss-shader-%e6%9c%aa%e5%91%bd%e4%b8%ad%e7%9d%80%e8%89%b2%e5%99%a8"></a>
Miss Shader (未命中着色器)
</h3><p>如果光线没有击中任何场景几何体，则执行此着色器。它通常用于返回一个背景色，例如天空盒的颜色，并将距离设为一个极大值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span> <span class="n">location</span> <span class="o">=</span> <span class="mo">0</span> <span class="p">)</span> <span class="n">rayPayloadInEXT</span> <span class="n">RayPayload</span> <span class="n">payload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 返回天空颜色作为辐射度</span>
</span></span><span class="line"><span class="cl">    <span class="n">payload</span><span class="p">.</span><span class="n">radiance</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">0.529</span><span class="p">,</span> <span class="mf">0.807</span><span class="p">,</span> <span class="mf">0.921</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置一个非常大的距离值，表示光线射向了无穷远</span>
</span></span><span class="line"><span class="cl">    <span class="n">payload</span><span class="p">.</span><span class="n">distance</span> <span class="o">=</span> <span class="mf">1000.0</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="核心辅助函数-core-helper-functions">
<a class="header-anchor" href="#%e6%a0%b8%e5%bf%83%e8%be%85%e5%8a%a9%e5%87%bd%e6%95%b0-core-helper-functions"></a>
核心辅助函数 (Core Helper Functions)
</h2><p>这些辅助函数是DDGI（动态漫反射全局光照）系统的基石，负责处理从采样方向生成、矢量编码到坐标系转换等各种关键任务。理解这些函数有助于深入掌握DDGI的内部工作机制。</p>
<h3 id="球面斐波那契采样-spherical-fibonacci-sampling">
<a class="header-anchor" href="#%e7%90%83%e9%9d%a2%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e9%87%87%e6%a0%b7-spherical-fibonacci-sampling"></a>
球面斐波那契采样 (Spherical Fibonacci Sampling)
</h3><p>在为每个探针采集光照信息时，我们需要从探针位置向周围发射大量光线。为了用最少的光线数量高效地覆盖所有方向，我们需要一个能在球面上生成均匀分布点的算法。球面斐波那契（或称黄金螺旋）就是一种优秀的解决方案。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 使用球面斐波那契算法在单位球面上生成一个均匀分布的3D方向向量。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param i 当前样本的索引，范围 [0, n-1]。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param n 总样本数。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 一个标准化的3D方向向量。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">vec3</span> <span class="n">spherical_fibonacci</span><span class="p">(</span><span class="k">float</span> <span class="n">i</span><span class="p">,</span> <span class="k">float</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 黄金比例常数，是构造斐波那契晶格的核心。</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">float</span> <span class="n">PHI</span> <span class="o">=</span> <span class="mf">1.61803398875</span><span class="n">f</span><span class="p">;</span> <span class="c1">// (sqrt(5.0) + 1.0) / 2.0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算垂直分量（z轴），确保点在z轴上均匀分布。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// (2.0 * i + 1.0) / n 会生成从 1/n 到 (2n-1)/n 的序列。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1.0 - ... 将其映射到 [-1 + 1/n, 1 - 1/n] 的范围。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">cos_theta</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">-</span> <span class="p">(</span><span class="mf">2.0</span><span class="n">f</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">sin_theta</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">clamp</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span> <span class="o">-</span> <span class="n">cos_theta</span> <span class="o">*</span> <span class="n">cos_theta</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算水平角度 phi，使用黄金比例的小数部分来确保每个点的旋转角度都有最大程度的无理性和不重复性，</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 从而避免产生摩尔纹或排列成线的瑕疵。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">phi</span> <span class="o">=</span> <span class="mf">2.0</span><span class="n">f</span> <span class="o">*</span> <span class="n">PI</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">PHI</span> <span class="o">-</span> <span class="n">floor</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">PHI</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 从球坐标转换为笛卡尔坐标。</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">vec3</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin_theta</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin_theta</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="n">cos_theta</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>该函数是蒙特卡洛积分在渲染中应用的一个实例。与简单的随机采样或经纬度采样（会在两极产生点堆积）相比，球面斐波那契采样是一种<strong>低差异序列</strong>，它能以确定性的方式生成分布极为均匀的样本点，从而在相同的样本数下获得更平滑、噪点更少的积分结果。</p>
<h3 id="八面体映射-octahedral-mapping">
<a class="header-anchor" href="#%e5%85%ab%e9%9d%a2%e4%bd%93%e6%98%a0%e5%b0%84-octahedral-mapping"></a>
八面体映射 (Octahedral Mapping)
</h3><p>为了将探针采集到的360度环境光信息存储到一张2D纹理中，我们需要一种高效的映射方法，将3D单位方向向量编码（Encode）为2D坐标，然后再解码（Decode）回来。八面体映射就是一种在性能和精度之间取得优秀平衡的常用技术。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// 编码：将3D单位向量投影到一个八面体上，然后展开成一个2D正方形([-1,1])。</span>
</span></span><span class="line"><span class="cl"><span class="k">vec2</span> <span class="n">oct_encode</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将向量投影到z=0的平面，通过L1范数进行归一化。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">l1norm</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">result</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">l1norm</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果向量在下半球 (v.z &lt; 0)，则需要进行一次“翻折”操作，</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将下半球的八面体表面映射到2D正方形的外部区域。</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">z</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">abs</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">yx</span><span class="p">))</span> <span class="o">*</span> <span class="n">sign_not_zero</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 解码：将2D八面体坐标转换回3D单位向量。</span>
</span></span><span class="line"><span class="cl"><span class="k">vec3</span> <span class="n">oct_decode</span><span class="p">(</span><span class="k">vec2</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 首先重构出上半球的向量。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">v</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">abs</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">abs</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果z分量为负，说明原始向量来自下半球，需要执行与编码相反的翻折操作。</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">z</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">v</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">yx</span><span class="p">))</span> <span class="o">*</span> <span class="n">sign_not_zero</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 最后，将向量归一化以确保它是单位长度。</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">normalize</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 辅助函数：返回一个数的符号，但0被视为正。</span>
</span></span><span class="line"><span class="cl"><span class="k">float</span> <span class="n">sign_not_zero</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">?</span> <span class="mf">1.0</span> <span class="o">:</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>八面体映射通过将单位球体投影到一个紧密包围它的八面体上，再将八面体展开成一个2D正方形来实现。相比于立方体贴图（Cubemap），它没有接缝问题，且所有数据都存储在一张连续的2D纹理中，有利于利用硬件的双线性插值和Mipmapping。这种编码方式在存储方向性数据（如法线、光照方向等）时非常高效。</p>
<h3 id="3-探针网格与世界空间变换">
<a class="header-anchor" href="#3-%e6%8e%a2%e9%92%88%e7%bd%91%e6%a0%bc%e4%b8%8e%e4%b8%96%e7%95%8c%e7%a9%ba%e9%97%b4%e5%8f%98%e6%8d%a2"></a>
3. 探针网格与世界空间变换
</h3><p>DDGI的核心是在3D空间中维护一个规则的探针网格。因此，我们需要一系列函数来在这几种坐标系之间进行转换：</p>
<ul>
<li><strong>1D 探针索引</strong>: 在缓冲区或循环中使用的线性索引。</li>
<li><strong>3D 网格坐标</strong>: 探针在网格中的整数坐标 <code>(x, y, z)</code>。</li>
<li><strong>3D 世界坐标</strong>: 探针在游戏世界中的实际浮点数位置。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 将一维的探针线性索引转换为三维的网格坐标。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">ivec3</span> <span class="n">probe_index_to_grid_indices</span><span class="p">(</span><span class="k">int</span> <span class="n">probe_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">int</span> <span class="n">probe_x</span> <span class="o">=</span> <span class="n">probe_index</span> <span class="o">%</span> <span class="n">probe_counts</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">int</span> <span class="n">probe_counts_xy</span> <span class="o">=</span> <span class="n">probe_counts</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">probe_counts</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">int</span> <span class="n">probe_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">probe_index</span> <span class="o">%</span> <span class="n">probe_counts_xy</span><span class="p">)</span> <span class="o">/</span> <span class="n">probe_counts</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">int</span> <span class="n">probe_z</span> <span class="o">=</span> <span class="n">probe_index</span> <span class="o">/</span> <span class="n">probe_counts_xy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">ivec3</span><span class="p">(</span><span class="n">probe_x</span><span class="p">,</span> <span class="n">probe_y</span><span class="p">,</span> <span class="n">probe_z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 将三维的网格坐标转换回一维的线性索引。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">int</span> <span class="n">probe_indices_to_index</span><span class="p">(</span><span class="k">in</span> <span class="k">ivec3</span> <span class="n">probe_coords</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">int</span><span class="p">(</span><span class="n">probe_coords</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">probe_coords</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">probe_counts</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">probe_coords</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">probe_counts</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">probe_counts</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 将三维的网格坐标转换为世界坐标，可选地应用一个偏移量。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 这个偏移量是DDGI的一个重要特性，允许探针从其规则的网格位置移动，以更好地贴合场景几何体，减少漏光。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">vec3</span> <span class="n">grid_indices_to_world</span><span class="p">(</span><span class="k">ivec3</span> <span class="n">grid_indices</span><span class="p">,</span> <span class="k">int</span> <span class="n">probe_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算基础的世界坐标</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">base_world_pos</span> <span class="o">=</span> <span class="n">grid_indices</span> <span class="o">*</span> <span class="n">probe_spacing</span> <span class="o">+</span> <span class="n">probe_grid_position</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 从纹理中获取预计算的探针偏移量</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">probe_offset</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">use_probe_offsetting</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="k">int</span> <span class="n">probe_counts_xy</span> <span class="o">=</span> <span class="n">probe_counts</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">probe_counts</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">ivec2</span> <span class="n">offset_coord</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">probe_index</span> <span class="o">%</span> <span class="n">probe_counts_xy</span><span class="p">,</span> <span class="n">probe_index</span> <span class="o">/</span> <span class="n">probe_counts_xy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">probe_offset</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">probe_offset_texture_index</span><span class="p">)],</span> <span class="n">offset_coord</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">base_world_pos</span> <span class="o">+</span> <span class="n">probe_offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 将世界坐标转换为其所在的探针网格的三维坐标。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">ivec3</span> <span class="n">world_to_grid_indices</span><span class="p">(</span><span class="k">vec3</span> <span class="n">world_position</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">grid_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">world_position</span> <span class="o">-</span> <span class="n">probe_grid_position</span><span class="p">)</span> <span class="o">*</span> <span class="n">reciprocal_probe_spacing</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">clamp</span><span class="p">(</span><span class="k">ivec3</span><span class="p">(</span><span class="n">grid_pos</span><span class="p">),</span> <span class="k">ivec3</span><span class="p">(</span><span class="mo">0</span><span class="p">),</span> <span class="n">probe_counts</span> <span class="o">-</span> <span class="k">ivec3</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="4-探针图集坐标计算-probe-atlas-coordinates">
<a class="header-anchor" href="#4-%e6%8e%a2%e9%92%88%e5%9b%be%e9%9b%86%e5%9d%90%e6%a0%87%e8%ae%a1%e7%ae%97-probe-atlas-coordinates"></a>
4. 探针图集坐标计算 (Probe Atlas Coordinates)
</h3><p>为了高效渲染，所有探针的环境光数据（通常是经过八面体编码的2D图像）都被存储在一张巨大的 <strong>纹理图集（Texture Atlas）</strong> 中。每个探针占据图集中的一小块正方形区域，周围通常有1像素的边界（Border）以防止在纹理采样时发生数据“渗漏”。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 根据3D方向和探针索引，计算出在整个探针图集纹理中对应的UV坐标。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">vec2</span> <span class="n">get_probe_uv</span><span class="p">(</span><span class="k">vec3</span> <span class="n">direction</span><span class="p">,</span> <span class="k">int</span> <span class="n">probe_index</span><span class="p">,</span> <span class="k">int</span> <span class="n">full_texture_width</span><span class="p">,</span> <span class="k">int</span> <span class="n">full_texture_height</span><span class="p">,</span> <span class="k">int</span> <span class="n">probe_side_length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 将3D方向编码为[-1, 1]范围的2D八面体坐标。</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">vec2</span> <span class="n">octahedral_coordinates</span> <span class="o">=</span> <span class="n">oct_encode</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">direction</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">float</span> <span class="n">probe_with_border_side</span> <span class="o">=</span> <span class="k">float</span><span class="p">(</span><span class="n">probe_side_length</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.0</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">int</span> <span class="n">probes_per_row</span> <span class="o">=</span> <span class="n">full_texture_width</span> <span class="o">/</span> <span class="k">int</span><span class="p">(</span><span class="n">probe_with_border_side</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 计算当前探针在图集中的网格索引 (0,0), (1,0), ...</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec2</span> <span class="n">probe_indices</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">probe_index</span> <span class="o">%</span> <span class="n">probes_per_row</span><span class="p">,</span> <span class="n">probe_index</span> <span class="o">/</span> <span class="n">probes_per_row</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 计算该探针区域左上角的像素坐标。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">atlas_texels</span> <span class="o">=</span> <span class="k">vec2</span><span class="p">(</span><span class="n">probe_indices</span><span class="p">)</span> <span class="o">*</span> <span class="n">probe_with_border_side</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 4. 加上1像素的边界，进入探针的有效数据区域。</span>
</span></span><span class="line"><span class="cl">    <span class="n">atlas_texels</span> <span class="o">+=</span> <span class="k">vec2</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 5. 移动到探针区域的中心。</span>
</span></span><span class="line"><span class="cl">    <span class="n">atlas_texels</span> <span class="o">+=</span> <span class="k">vec2</span><span class="p">(</span><span class="n">probe_side_length</span> <span class="o">*</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 6. 使用八面体坐标在探针区域内部进行偏移。</span>
</span></span><span class="line"><span class="cl">    <span class="n">atlas_texels</span> <span class="o">+=</span> <span class="n">octahedral_coordinates</span> <span class="o">*</span> <span class="p">(</span><span class="n">probe_side_length</span> <span class="o">*</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 7. 将最终的像素坐标归一化为[0, 1]范围的UV坐标。</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">atlas_texels</span> <span class="o">/</span> <span class="k">vec2</span><span class="p">(</span><span class="k">float</span><span class="p">(</span><span class="n">full_texture_width</span><span class="p">),</span> <span class="k">float</span><span class="p">(</span><span class="n">full_texture_height</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="更新辐照度与可见性-update-irradiance-and-visibility">
<a class="header-anchor" href="#%e6%9b%b4%e6%96%b0%e8%be%90%e7%85%a7%e5%ba%a6%e4%b8%8e%e5%8f%af%e8%a7%81%e6%80%a7-update-irradiance-and-visibility"></a>
更新辐照度与可见性 (Update Irradiance and Visibility)
</h2><p>在“辐射度采集”阶段之后，我们得到了每个探针从数百个方向射出的光线的原始数据（颜色和距离）。这个原始数据是离散且充满噪声的。本阶段的目标就是将这些离散的射线数据，通过滤波和积分，转换成两张最终可供场景采样、平滑且稳定的<strong>探针图集（Probe Atlas）</strong>：</p>
<ol>
<li>
<p><strong>辐照度图集 (Irradiance Atlas)</strong>: 存储每个探针从各个方向接收到的颜色信息。
<img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507201311676.png" alt=""></p>
</li>
<li>
<p><strong>可见性图集 (Visibility Atlas)</strong>: 存储每个探针在各个方向上的平均距离和距离的平方，用于后续计算柔和阴影。
<img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507201312903.png" alt=""></p>
</li>
</ol>
<h3 id="cpu端调度">
<a class="header-anchor" href="#cpu%e7%ab%af%e8%b0%83%e5%ba%a6"></a>
CPU端调度
</h3><p>在CPU侧，我们分别调用两个独立的计算管线，它们使用相同的输入数据但执行不同的计算，最终写入各自的目标图集纹理。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">i32</span> <span class="n">irradiance_probe_size</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">i32</span> <span class="n">octahedral_irradiance_size</span> <span class="o">=</span> <span class="n">irradiance_probe_size</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">irradiance_atlas_width</span> <span class="o">=</span> <span class="p">(</span><span class="n">octahedral_irradiance_size</span> <span class="o">*</span> <span class="n">probe_count_x</span> <span class="o">*</span> <span class="n">probe_count_y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">irradiance_atlas_height</span> <span class="o">=</span> <span class="p">(</span><span class="n">octahedral_irradiance_size</span> <span class="o">*</span> <span class="n">probe_count_z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// --- 1. 更新辐照度图集 ---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ... 绑定计算管线和资源 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">dispatch</span><span class="p">(</span><span class="n">hydra</span><span class="o">::</span><span class="n">ceilu32</span><span class="p">(</span><span class="n">irradiance_atlas_width</span> <span class="o">/</span> <span class="mf">8.f</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                       <span class="n">hydra</span><span class="o">::</span><span class="n">ceilu32</span><span class="p">(</span><span class="n">irradiance_atlas_height</span> <span class="o">/</span> <span class="mf">8.f</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// --- 2. 更新可见性图集 ---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ... 绑定计算管线和资源 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 启动计算着色器，覆盖整个可见性图集纹理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">dispatch</span><span class="p">(</span><span class="n">hydra</span><span class="o">::</span><span class="n">ceilu32</span><span class="p">(</span><span class="n">visibility_atlas_width</span> <span class="o">/</span> <span class="mf">8.f</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                       <span class="n">hydra</span><span class="o">::</span><span class="n">ceilu32</span><span class="p">(</span><span class="n">visibility_atlas_height</span> <span class="o">/</span> <span class="mf">8.f</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></div><h3 id="计算着色器详解">
<a class="header-anchor" href="#%e8%ae%a1%e7%ae%97%e7%9d%80%e8%89%b2%e5%99%a8%e8%af%a6%e8%a7%a3"></a>
计算着色器详解
</h3><p>以下是核心的计算着色器代码。它通过预处理器宏 (<code>#if defined</code>) 来区分是计算辐照度还是可见性，但核心逻辑是共享的。代码主要分为两个部分：<strong>核心计算</strong>（针对探针内部像素）和<strong>边界处理</strong>（针对探针边缘像素）。</p>
<h4 id="1-核心计算探针内部像素">
<a class="header-anchor" href="#1-%e6%a0%b8%e5%bf%83%e8%ae%a1%e7%ae%97%e6%8e%a2%e9%92%88%e5%86%85%e9%83%a8%e5%83%8f%e7%b4%a0"></a>
1. 核心计算（探针内部像素）
</h4><p>这部分代码对探针图集内每个有效的像素进行计算。每个像素代表探针所看到的一个特定方向。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// 该着色器在一个 8x8 的线程组中执行</span>
</span></span><span class="line"><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec3</span> <span class="n">coords</span> <span class="o">=</span> <span class="k">ivec3</span><span class="p">(</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 省略变量初始化和边界检查 ...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 通过像素坐标反算出当前线程正在为哪个探针工作</span>
</span></span><span class="line"><span class="cl">    <span class="k">int</span> <span class="n">probe_index</span> <span class="o">=</span> <span class="n">get_probe_index_from_pixels</span><span class="p">(</span><span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="p">...);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 步骤1: 区分内部像素与边界像素 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 探针在图集中有1像素的边界，边界像素有特殊处理。</span>
</span></span><span class="line"><span class="cl">    <span class="k">bool</span> <span class="n">border_pixel</span> <span class="o">=</span> <span class="p">((</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">x</span> <span class="o">%</span> <span class="n">probe_with_border_side</span><span class="p">)</span> <span class="o">==</span> <span class="mo">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">...</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">border_pixel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 步骤2: 对所有射线进行加权积分 ---</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec4</span> <span class="n">result</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">uint</span> <span class="n">backfaces</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="c1">// 用于统计击中背面的射线数量</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 循环遍历该探针在上一阶段发射的所有射线</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">ray_index</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="n">ray_index</span> <span class="o">&lt;</span> <span class="n">probe_rays</span><span class="p">;</span> <span class="o">++</span><span class="n">ray_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 获取原始射线数据（辐射度和距离）</span>
</span></span><span class="line"><span class="cl">            <span class="k">ivec2</span> <span class="n">sample_position</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">ray_index</span><span class="p">,</span> <span class="n">probe_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec4</span> <span class="n">raw_data</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">radiance_output_index</span><span class="p">)],</span> <span class="n">sample_position</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// a. 处理背面击中：如果距离为负，说明探针可能在几何体内，跳过此射线。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//    如果背面射线过多，则认为此探针完全被遮挡，提前退出，结果为黑色。</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">raw_data</span><span class="p">.</span><span class="n">w</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="n">f</span> <span class="o">&amp;&amp;</span> <span class="n">use_backfacing_blending</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">backfaces</span> <span class="o">&gt;=</span> <span class="n">uint</span><span class="p">(</span><span class="n">probe_rays</span> <span class="o">*</span> <span class="mf">0.1</span><span class="n">f</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// b. 计算权重：这是积分的核心。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//    - texel_direction: 当前像素所代表的出射方向。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//    - ray_direction:   当前循环中处理的原始射线的方向。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//    - weight:          二者点积，即两个方向夹角的余弦值。</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">ray_direction</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">random_rotation</span><span class="p">)</span> <span class="o">*</span> <span class="n">spherical_fibonacci</span><span class="p">(</span><span class="n">ray_index</span><span class="p">,</span> <span class="n">probe_rays</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">texel_direction</span> <span class="o">=</span> <span class="n">oct_decode</span><span class="p">(</span><span class="n">normalized_oct_coord</span><span class="p">(</span><span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">probe_side_length</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">texel_direction</span><span class="p">,</span> <span class="n">ray_direction</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">weight</span> <span class="o">&lt;</span> <span class="mf">0.0001</span><span class="n">f</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// c. 根据模式（辐照度/可见性）累加加权值</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if defined(COMPUTE_PROBE_UPDATE_IRRADIANCE)</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 模式1: 辐照度。累加 (颜色 * 权重)，并将权重本身存入w分量。</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">radiance</span> <span class="o">=</span> <span class="n">raw_data</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="mf">0.95</span><span class="p">;</span> <span class="c1">// 能量守恒</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span> <span class="o">+=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">radiance</span> <span class="o">*</span> <span class="n">weight</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 模式2: 可见性。累加 (距离, 距离^2, 0) * 权重。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 这是为方差阴影贴图(VSM)准备的矩(Moments)。</span>
</span></span><span class="line"><span class="cl">            <span class="n">weight</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="mf">2.5</span><span class="n">f</span><span class="p">);</span> <span class="c1">// 权重锐化，使深度更清晰</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">raw_data</span><span class="p">.</span><span class="n">w</span><span class="p">),</span> <span class="n">probe_max_ray_distance</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">value</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">distance</span> <span class="o">*</span> <span class="n">distance</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span> <span class="o">+=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">value</span> <span class="o">*</span> <span class="n">weight</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 步骤3: 归一化和时间混合 ---</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// a. 归一化：将累加结果除以总权重，得到加权平均值。</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">w</span> <span class="o">&gt;</span> <span class="mf">0.0001</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span><span class="p">.</span><span class="n">xyz</span> <span class="o">/=</span> <span class="n">result</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// b. 时间滤波：与上一帧的结果进行混合（滞后滤波），以消除闪烁。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//    hysteresis 是一个 [0, 1] 范围的混合因子。</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if defined(COMPUTE_PROBE_UPDATE_IRRADIANCE)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 是否启用感知编码。</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">use_perceptual_encoding</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 对 result.rgb（一个线性的HDR颜色值）执行伽马编码。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// pow(value, exponent) 是一个幂函数。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 这里的指数是 vec3(1.0f / 5.0f)，即对R, G, B三个分量都取0.2次幂。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 这等同于应用一个 gamma = 5.0 的伽马校正。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 其目的是将线性的光照强度非线性地映射到更符合人类视觉感知的空间，</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 以便在低精度（如RGBA8）纹理中存储时，能更有效地利用数据位，</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 减少在暗部区域的色带瑕疵。</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span> <span class="o">/</span> <span class="mf">5.0</span><span class="n">f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec4</span> <span class="n">previous_value</span> <span class="o">=</span> <span class="n">imageLoad</span><span class="p">(</span><span class="n">irradiance_image</span><span class="p">,</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span> <span class="o">=</span> <span class="n">mix</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">previous_value</span><span class="p">,</span> <span class="n">hysteresis</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">imageStore</span><span class="p">(</span><span class="n">irradiance_image</span><span class="p">,</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec2</span> <span class="n">previous_value</span> <span class="o">=</span> <span class="n">imageLoad</span><span class="p">(</span><span class="n">visibility_image</span><span class="p">,</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">rg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span><span class="p">.</span><span class="n">rg</span> <span class="o">=</span> <span class="n">mix</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">rg</span><span class="p">,</span> <span class="n">previous_value</span><span class="p">,</span> <span class="n">hysteresis</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">imageStore</span><span class="p">(</span><span class="n">visibility_image</span><span class="p">,</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="k">vec4</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">rg</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span> <span class="c1">// 内部像素计算完成</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 边界像素处理 ...</span>
</span></span></code></pre></div><ul>
<li><strong>余弦加权积分 (Cosine-Weighted Integration)</strong>: 核心计算是在估算渲染方程中的半球积分。对于一个给定的出射方向（<code>texel_direction</code>），它接收到的光照是所有入射光线（<code>ray_direction</code>）贡献的总和，且每条光线的贡献由其与出射方向夹角的余弦值（<code>dot(...)</code>）进行加权。此过程在物理上模拟了 Lambertian 表面的漫反射。</li>
<li><strong>方差阴影贴图 (Variance Shadow Mapping, VSM)</strong>: 在计算可见性时，我们存储了距离 <code>d</code> 和距离的平方 <code>d^2</code>。通过这两个<strong>矩（Moments）</strong>，可以在后续的光照计算中，快速估算一个像素点是否处于阴影中，并且能以很小的代价实现具有可变半影的柔和阴影效果。</li>
</ul>
<h4 id="2-边界处理探针边缘像素">
<a class="header-anchor" href="#2-%e8%be%b9%e7%95%8c%e5%a4%84%e7%90%86%e6%8e%a2%e9%92%88%e8%be%b9%e7%bc%98%e5%83%8f%e7%b4%a0"></a>
2. 边界处理（探针边缘像素）
</h4><p>这部分代码处理图集中每个探针周围的1像素边界。其目的是为了让硬件在对图集进行双线性插值采样时，能够无缝地“环绕”读取数据。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl">    <span class="c1">// ... 内部像素计算之后 ...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 步骤4: 同步线程并处理边界像素 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// a. 内存屏障：确保所有内部像素都已计算并写入内存后，</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    才开始进行边界像素的拷贝操作，避免读取到旧数据或未定义数据。</span>
</span></span><span class="line"><span class="cl">    <span class="n">groupMemoryBarrier</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">barrier</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// b. 计算源像素坐标：根据当前边界像素的位置，计算出它应该从探针区域</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    内部的哪个像素拷贝数据（通常是相对的另一侧）。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    例如，顶部边界拷贝底部内容，左侧边界拷贝右侧内容。</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec2</span> <span class="n">source_pixel_coordinate</span> <span class="o">=</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">corner_pixel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 角落像素的拷贝逻辑</span>
</span></span><span class="line"><span class="cl">        <span class="n">source_pixel_coordinate</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="p">(</span><span class="n">probe_pixel_x</span> <span class="o">==</span> <span class="mo">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">probe_side_length</span> <span class="o">:</span> <span class="o">-</span><span class="n">probe_side_length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">source_pixel_coordinate</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="p">(</span><span class="n">probe_pixel_y</span> <span class="o">==</span> <span class="mo">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">probe_side_length</span> <span class="o">:</span> <span class="o">-</span><span class="n">probe_side_length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">row_pixel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 水平边界像素的拷贝逻辑</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 垂直边界像素的拷贝逻辑</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// c. 拷贝并写入数据</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if defined(COMPUTE_PROBE_UPDATE_IRRADIANCE)</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">copied_data</span> <span class="o">=</span> <span class="n">imageLoad</span><span class="p">(</span><span class="n">irradiance_image</span><span class="p">,</span> <span class="n">source_pixel_coordinate</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">irradiance_image</span><span class="p">,</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">copied_data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">copied_data</span> <span class="o">=</span> <span class="n">imageLoad</span><span class="p">(</span><span class="n">visibility_image</span><span class="p">,</span> <span class="n">source_pixel_coordinate</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">visibility_image</span><span class="p">,</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">copied_data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li><strong>纹理环绕 (Texture Wrapping)</strong>: 这是处理存储在图集中的球面/八面体贴图的标准做法。通过在数据周围填充一圈“环绕”的边界，可以欺骗GPU的纹理采样器，使其在采样数据边缘时，能够正确地插值到“对面”的像素，从而避免在八面体贴图的<code>[-1, 1]</code>边界处产生接缝或瑕疵。</li>
<li><strong>线程组同步 (Workgroup Synchronization)</strong>: <code>groupMemoryBarrier()</code> 和 <code>barrier()</code> 是在计算着色器中进行线程同步的关键指令。它确保了在一个线程组（Workgroup）内，写操作和读操作的先后顺序，是实现这种“先计算，后拷贝”逻辑的必要条件。</li>
</ul>
<h2 id="采样-irradiance-probes">
<a class="header-anchor" href="#%e9%87%87%e6%a0%b7-irradiance-probes"></a>
采样 Irradiance Probes
</h2><p>这部分代码负责设置渲染管线状态并启动计算着色器。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">sampleIrradianceProbes</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置资源屏障：告诉GPU，我们将要以“无序访问”（写入）的方式使用 indirect_texture
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">issue_texture_barrier</span><span class="p">(</span><span class="n">indirect_texture</span><span class="p">,</span> <span class="n">RESOURCE_STATE_UNORDERED_ACCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 绑定用于采样Irradiance的计算管线
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">bind_pipeline</span><span class="p">(</span><span class="n">sample_irradiance_pipeline</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 绑定描述符集，其中包含了所有需要的纹理资源（深度图、法线图、探针数据等）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">bind_descriptor_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sample_irradiance_descriptor_set</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 通过Push Constants向Shader传递一个标记，告诉它是否启用半分辨率模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">u32</span> <span class="n">half_resolution</span> <span class="o">=</span> <span class="n">render_scene</span><span class="o">-&gt;</span><span class="n">gi_use_half_resolution</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">push_constants</span><span class="p">(</span><span class="n">sample_irradiance_pipeline</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">half_resolution</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算需要启动的线程组数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果启用半分辨率，宽高都减半
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="n">f32</span> <span class="n">resolution_divider</span> <span class="o">=</span> <span class="n">render_scene</span><span class="o">-&gt;</span><span class="n">gi_use_half_resolution</span> <span class="o">?</span> <span class="mf">0.5f</span> <span class="o">:</span> <span class="mf">1.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">u32</span> <span class="n">group_dim_x</span> <span class="o">=</span> <span class="n">hydra</span><span class="o">::</span><span class="n">ceilu32</span><span class="p">(</span><span class="n">renderer</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">*</span> <span class="n">resolution_divider</span> <span class="o">/</span> <span class="mf">8.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">u32</span> <span class="n">group_dim_y</span> <span class="o">=</span> <span class="n">hydra</span><span class="o">::</span><span class="n">ceilu32</span><span class="p">(</span><span class="n">renderer</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">*</span> <span class="n">resolution_divider</span> <span class="o">/</span> <span class="mf">8.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 派发计算任务！这将启动 group_dim_x * group_dim_y * 1 个线程组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 每个线程组包含 8x8x1 = 64 个线程，对应着色器中的 local_size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">dispatch</span><span class="p">(</span><span class="n">group_dim_x</span><span class="p">,</span> <span class="n">group_dim_y</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 再次设置资源屏障：告诉GPU，计算已完成，indirect_texture 现在将作为“像素着色器资源”（读取）使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">issue_texture_barrier</span><span class="p">(</span><span class="n">indirect_texture</span><span class="p">,</span> <span class="n">RESOURCE_STATE_PIXEL_SHADER_RESOURCE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>计算着色器的主要任务是从探针网格中采样间接光照（Irradiance），并将结果存储在一个纹理中。它通过对每个探针周围的多个方向进行采样，来近似计算该点的间接光照。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// =========================================================================</span>
</span></span><span class="line"><span class="cl"><span class="c1">//                       </span>
</span></span><span class="line"><span class="cl"><span class="c1">// 为给定的世界坐标点，通过采样周围的光照探针来计算其间接光照。</span>
</span></span><span class="line"><span class="cl"><span class="c1">//</span>
</span></span><span class="line"><span class="cl"><span class="c1">// @param world_position:    当前像素/着色点的世界坐标</span>
</span></span><span class="line"><span class="cl"><span class="c1">// @param normal:            该点的法线向量</span>
</span></span><span class="line"><span class="cl"><span class="c1">// @param camera_position:   摄像机的世界坐标</span>
</span></span><span class="line"><span class="cl"><span class="c1">// @return:                  计算出的间接光 irradiance</span>
</span></span><span class="line"><span class="cl"><span class="c1">// =========================================================================</span>
</span></span><span class="line"><span class="cl"><span class="k">vec3</span> <span class="n">sample_irradiance</span><span class="p">(</span><span class="k">vec3</span> <span class="n">world_position</span><span class="p">,</span> <span class="k">vec3</span> <span class="n">normal</span><span class="p">,</span> <span class="k">vec3</span> <span class="n">camera_position</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Wo 是从着色点指向摄像机的向量</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">vec3</span> <span class="n">Wo</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">camera_position</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">world_position</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 【关键点1: 表面偏置】</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 为了防止“自阴影”或光照泄漏，将采样点沿着法线和视线方向稍微偏移。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这可以避免在物体表面上直接采样，从而提高稳定性。</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">float</span> <span class="n">minimum_distance_between_probes</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">;</span> <span class="c1">// 探针间的最小距离，用于缩放偏移量</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">bias_vector</span> <span class="o">=</span> <span class="p">(</span><span class="n">normal</span> <span class="o">*</span> <span class="mf">0.2</span><span class="n">f</span> <span class="o">+</span> <span class="n">Wo</span> <span class="o">*</span> <span class="mf">0.8</span><span class="n">f</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.75</span><span class="n">f</span> <span class="o">*</span> <span class="n">minimum_distance_between_probes</span><span class="p">)</span> <span class="o">*</span> <span class="n">self_shadow_bias</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">biased_world_position</span> <span class="o">=</span> <span class="n">world_position</span> <span class="o">+</span> <span class="n">bias_vector</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 探针网格定位与插值准备 ---</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 根据偏移后的世界坐标，找到其所在的探针网格单元的基准索引（单元的最小角）</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec3</span> <span class="n">base_grid_indices</span> <span class="o">=</span> <span class="n">world_to_grid_indices</span><span class="p">(</span><span class="n">biased_world_position</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取该基准探针的世界坐标</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">base_probe_world_position</span> <span class="o">=</span> <span class="n">grid_indices_to_world_no_offsets</span><span class="p">(</span><span class="n">base_grid_indices</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// alpha: 计算采样点在探针网格单元内的相对位置 [0, 1]，用于后续的三线性插值</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">((</span><span class="n">biased_world_position</span> <span class="o">-</span> <span class="n">base_probe_world_position</span><span class="p">),</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">),</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span>  <span class="n">sum_irradiance</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">);</span> <span class="c1">// 加权辐照度总和</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">sum_weight</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>           <span class="c1">// 权重总和</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历环绕采样点的8个探针（形成一个立方体“笼子”）</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 计算当前探针的偏移量 (0或1)，i的二进制位分别代表x,y,z轴的偏移</span>
</span></span><span class="line"><span class="cl">        <span class="k">ivec3</span> <span class="n">offset</span> <span class="o">=</span> <span class="k">ivec3</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="k">ivec3</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 计算探针的网格坐标，并确保它在有效范围内</span>
</span></span><span class="line"><span class="cl">        <span class="k">ivec3</span> <span class="n">probe_grid_coord</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">base_grid_indices</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="k">ivec3</span><span class="p">(</span><span class="mo">0</span><span class="p">),</span> <span class="n">probe_counts</span> <span class="o">-</span> <span class="k">ivec3</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将网格坐标转换为一维索引</span>
</span></span><span class="line"><span class="cl">        <span class="k">int</span> <span class="n">probe_index</span> <span class="o">=</span> <span class="n">probe_indices_to_index</span><span class="p">(</span><span class="n">probe_grid_coord</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取探针的实际世界坐标</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">probe_pos</span> <span class="o">=</span> <span class="n">grid_indices_to_world</span><span class="p">(</span><span class="n">probe_grid_coord</span><span class="p">,</span> <span class="n">probe_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 计算各项权重 ---</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 【关键点2: 背面剔除权重】</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 为了防止光线从墙后“泄漏”过来，需要降低位于表面背后的探针的权重。</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">use_smooth_backface</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">direction_to_probe</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">probe_pos</span> <span class="o">-</span> <span class="n">world_position</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 使用 &#34;wrap shading&#34; 的思想，将 dot(dir, n) 从 [-1, 1] 映射到 [0, 1]</span>
</span></span><span class="line"><span class="cl">            <span class="k">const</span> <span class="k">float</span> <span class="n">dir_dot_n</span> <span class="o">=</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">direction_to_probe</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 通过平方和平滑因子，实现一个柔和的权重衰减，避免硬边</span>
</span></span><span class="line"><span class="cl">            <span class="n">weight</span> <span class="o">*=</span> <span class="p">(</span><span class="n">dir_dot_n</span> <span class="o">*</span> <span class="n">dir_dot_n</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 【关键点3: 可见性权重 (VSM + Chebyshev)】</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 检查探针和着色点之间是否存在遮挡物。</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">probe_to_biased_point_direction</span> <span class="o">=</span> <span class="n">biased_world_position</span> <span class="o">-</span> <span class="n">probe_pos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">distance_to_biased_point</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">probe_to_biased_point_direction</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">probe_to_biased_point_direction</span> <span class="o">/=</span> <span class="n">distance_to_biased_point</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">use_visibility</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 从可见性纹理（一个存储深度的纹理图集）中采样</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec2</span> <span class="n">uv</span> <span class="o">=</span> <span class="n">get_probe_uv</span><span class="p">(</span><span class="n">probe_to_biased_point_direction</span><span class="p">,</span> <span class="n">probe_index</span><span class="p">,</span> <span class="n">visibility_texture_width</span><span class="p">,</span> <span class="n">visibility_texture_height</span><span class="p">,</span> <span class="n">visibility_side_length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// .rg 通道存储了深度的均值(E[d])和平方均值(E[d^2])</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec2</span> <span class="n">visibility</span> <span class="o">=</span> <span class="n">textureLod</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">grid_visibility_texture_index</span><span class="p">)],</span> <span class="n">uv</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">rg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">mean_distance_to_occluder</span> <span class="o">=</span> <span class="n">visibility</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="c1">// 均值 μ</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">chebyshev_weight</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span> <span class="c1">// 默认完全可见</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果着色点比平均遮挡物更远，则可能被遮挡</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">distance_to_biased_point</span> <span class="o">&gt;</span> <span class="n">mean_distance_to_occluder</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 计算方差 σ^2 = E[d^2] - (E[d])^2</span>
</span></span><span class="line"><span class="cl">                <span class="k">float</span> <span class="n">variance</span> <span class="o">=</span> <span class="n">abs</span><span class="p">((</span><span class="n">visibility</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">visibility</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">visibility</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">const</span> <span class="k">float</span> <span class="n">distance_diff</span> <span class="o">=</span> <span class="n">distance_to_biased_point</span> <span class="o">-</span> <span class="n">mean_distance_to_occluder</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 应用切比雪夫不等式计算光照透过率（即权重）</span>
</span></span><span class="line"><span class="cl">                <span class="n">chebyshev_weight</span> <span class="o">=</span> <span class="n">variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">variance</span> <span class="o">+</span> <span class="p">(</span><span class="n">distance_diff</span> <span class="o">*</span> <span class="n">distance_diff</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 增强对比度，使阴影更明显</span>
</span></span><span class="line"><span class="cl">                <span class="n">chebyshev_weight</span> <span class="o">=</span> <span class="n">max</span><span class="p">((</span><span class="n">chebyshev_weight</span> <span class="o">*</span> <span class="n">chebyshev_weight</span> <span class="o">*</span> <span class="n">chebyshev_weight</span><span class="p">),</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 保证权重不完全为0，避免在全黑区域出现问题</span>
</span></span><span class="line"><span class="cl">            <span class="n">weight</span> <span class="o">*=</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.05</span><span class="n">f</span><span class="p">,</span> <span class="n">chebyshev_weight</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 采样与混合 ---</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 【关键点4: 三线性插值权重】</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 根据之前计算的alpha值，计算当前探针的三线性插值权重。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// mix(1-a, a, offset) 是一个简洁的实现方式。</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">trilinear</span> <span class="o">=</span> <span class="n">mix</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="k">vec3</span><span class="p">(</span><span class="n">offset</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">weight</span> <span class="o">*=</span> <span class="n">trilinear</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">trilinear</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">trilinear</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="mf">0.001</span><span class="n">f</span><span class="p">;</span> <span class="c1">// +0.001f 避免权重为0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 采样预计算好的Irradiance纹理图集</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec2</span> <span class="n">uv</span> <span class="o">=</span> <span class="n">get_probe_uv</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">probe_index</span><span class="p">,</span> <span class="n">irradiance_texture_width</span><span class="p">,</span> <span class="n">irradiance_texture_height</span><span class="p">,</span> <span class="n">irradiance_side_length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">probe_irradiance</span> <span class="o">=</span> <span class="n">textureLod</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">grid_irradiance_output_index</span><span class="p">)],</span> <span class="n">uv</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果使用了感知编码，需要解码</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">use_perceptual_encoding</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">probe_irradiance</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">probe_irradiance</span><span class="p">,</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">0.5</span><span class="n">f</span> <span class="o">*</span> <span class="mf">5.0</span><span class="n">f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 累加加权后的irradiance和总权重</span>
</span></span><span class="line"><span class="cl">        <span class="n">sum_irradiance</span> <span class="o">+=</span> <span class="n">weight</span> <span class="o">*</span> <span class="n">probe_irradiance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">sum_weight</span> <span class="o">+=</span> <span class="n">weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- Finalize ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 通过总权重进行归一化，得到最终混合后的irradiance</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">net_irradiance</span> <span class="o">=</span> <span class="n">sum_irradiance</span> <span class="o">/</span> <span class="n">sum_weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果使用了感知编码，需要重新编码</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">use_perceptual_encoding</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">net_irradiance</span> <span class="o">=</span> <span class="n">net_irradiance</span> <span class="o">*</span> <span class="n">net_irradiance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 最后乘以 PI 和一个缩放因子，这是漫反射BRDF积分的一部分</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">irradiance</span> <span class="o">=</span> <span class="mf">0.5</span><span class="n">f</span> <span class="o">*</span> <span class="n">PI</span> <span class="o">*</span> <span class="n">net_irradiance</span> <span class="o">*</span> <span class="mf">0.95</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">irradiance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取当前线程处理的像素坐标</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec3</span> <span class="n">coords</span> <span class="o">=</span> <span class="k">ivec3</span><span class="p">(</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 半分辨率优化处理 ---</span>
</span></span><span class="line"><span class="cl">    <span class="k">int</span> <span class="n">resolution_divider</span> <span class="o">=</span> <span class="n">output_resolution_half</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">screen_uv</span> <span class="o">=</span> <span class="n">uv_nearest</span><span class="p">(</span><span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">resolution</span> <span class="o">/</span> <span class="n">resolution_divider</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">raw_depth</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">int</span> <span class="n">chosen_hiresolution_sample_index</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果启用半分辨率模式，从高分辨率深度图中采样4个点，选择最靠近摄像机的那个</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这是为了在升采样时，保留边缘（深度不连续处）的正确信息</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">output_resolution_half</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">ivec2</span> <span class="n">pixel_offsets</span><span class="p">[]</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">[](</span><span class="k">ivec2</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span><span class="mo">0</span><span class="p">),</span> <span class="k">ivec2</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="k">ivec2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mo">0</span><span class="p">),</span> <span class="k">ivec2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">closer_depth</span> <span class="o">=</span> <span class="mf">0.</span><span class="n">f</span><span class="p">;</span> <span class="c1">// 线性深度，所以0是最近的</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">depth_fullscreen_texture_index</span><span class="p">)],</span> <span class="p">(</span><span class="n">coords</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">pixel_offsets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mo">0</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">closer_depth</span> <span class="o">&lt;</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">closer_depth</span> <span class="o">=</span> <span class="n">depth</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">chosen_hiresolution_sample_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">raw_depth</span> <span class="o">=</span> <span class="n">closer_depth</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 全分辨率模式，直接采样</span>
</span></span><span class="line"><span class="cl">        <span class="n">raw_depth</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">depth_fullscreen_texture_index</span><span class="p">)],</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果深度为1.0，说明是天空盒，直接输出黑色</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">raw_depth</span> <span class="o">==</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">imageStore</span><span class="p">(</span><span class="n">global_images_2d</span><span class="p">[</span><span class="n">indirect_output_index</span><span class="p">],</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="k">vec4</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 重建表面属性 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 根据深度值重建世界坐标</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">vec3</span> <span class="n">pixel_world_position</span> <span class="o">=</span> <span class="n">world_position_from_depth</span><span class="p">(</span><span class="n">screen_uv</span><span class="p">,</span> <span class="n">raw_depth</span><span class="p">,</span> <span class="n">inverse_view_projection</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取对应像素的法线</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">normal</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">output_resolution_half</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 半分辨率模式下，使用之前选定的高分辨率样本的法线</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec2</span> <span class="n">encoded_normal</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">normal_texture_index</span><span class="p">)],</span> <span class="p">(</span><span class="n">coords</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">pixel_offsets</span><span class="p">[</span><span class="n">chosen_hiresolution_sample_index</span><span class="p">],</span> <span class="mo">0</span><span class="p">).</span><span class="n">rg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">octahedral_decode</span><span class="p">(</span><span class="n">encoded_normal</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec2</span> <span class="n">encoded_normal</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">normal_texture_index</span><span class="p">)],</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">rg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">normal</span> <span class="o">=</span> <span class="n">octahedral_decode</span><span class="p">(</span><span class="n">encoded_normal</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 调用核心函数计算并输出 ---</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">irradiance</span> <span class="o">=</span> <span class="n">sample_irradiance</span><span class="p">(</span><span class="n">pixel_world_position</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">camera_position</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">global_images_2d</span><span class="p">[</span><span class="n">indirect_output_index</span><span class="p">],</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="k">vec4</span><span class="p">(</span><span class="n">irradiance</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>动态漫反射全局光照（DDGI） 的核心思想是在场景中放置一个规则的探针网格（Probe Grid）。每个探针会预先计算并存储两样东西：</p>
<ol>
<li>环境光照（Irradiance）: 从各个方向到达该点的光照总量，通常存为一个低阶球谐函数或直接存为八面体贴图（Octahedral Map）。</li>
<li>可见性/深度（Visibility/Depth）: 从探针位置向周围发射光线，记录遇到的第一个物体的平均距离和距离的方差。这本质上是为每个探针生成一张360度的深度图。</li>
</ol>
<p>本代码片段执行的是渲染循环中的采样阶段：屏幕上的每个像素根据自己的位置，智能地混合周围探针预计算好的信息，来得到最终的间接光照。</p>
<h3 id="三线性插值-trilinear-interpolation">
<a class="header-anchor" href="#%e4%b8%89%e7%ba%bf%e6%80%a7%e6%8f%92%e5%80%bc-trilinear-interpolation"></a>
三线性插值 (Trilinear Interpolation)
</h3><p>当一个着色点位于8个探针组成的立方体单元内部时，为了实现平滑的过渡，而不是在跨越探针边界时发生光照跳变，我们使用三线性插值。</p>
<ul>
<li><strong>原理</strong>: 它是在三维空间中的线性插值。可以看作先在X轴上对4对点进行线性插值，得到4个点；再在Y轴上对这4个点产生的2对点进行线性插值，得到2个点；最后在Z轴上对这2个点进行线性插值，得到最终结果。</li>
<li><strong>代码实现</strong>: 代码中的 <code>vec3 alpha</code> 代表着色点在单元格内沿X, Y, Z轴的相对位置（0到1）。通过 <code>mix(1.0 - alpha, alpha, offset)</code> 和 <code>trilinear.x * trilinear.y * trilinear.z</code> 的组合，巧妙地计算了8个角点（探针）各自的权重。</li>
</ul>
<h3 id="方差阴影贴图-variance-shadow-mapping---vsm">
<a class="header-anchor" href="#%e6%96%b9%e5%b7%ae%e9%98%b4%e5%bd%b1%e8%b4%b4%e5%9b%be-variance-shadow-mapping---vsm"></a>
方差阴影贴图 (Variance Shadow Mapping - VSM)
</h3><p>这是用于实现柔和、高质量阴影的经典技术，这里被用于判断探针与像素点的可见性。</p>
<ul>
<li><strong>原理</strong>: 传统阴影贴图只存储深度值 $d$，比较时会产生硬边和锯齿。VSM 不仅存储深度均值 $E[d] = \mu$ (代码中的 <code>visibility.x</code>)，还存储深度的平方均值 $E[d^2]$ (代码中的 <code>visibility.y</code>)。</li>
<li><strong>优势</strong>: 有了这两个值（称为“矩”，Moments），就可以计算出深度的<strong>方差</strong> $\sigma^2 = E[d^2] - (E[d])^2$。方差描述了深度值的分布情况。如果方差很大，说明在这个方向上遮挡物的深度变化剧烈，阴影就应该更柔和。</li>
</ul>
<h3 id="切比雪夫不等式-chebyshevs-inequality">
<a class="header-anchor" href="#%e5%88%87%e6%af%94%e9%9b%aa%e5%a4%ab%e4%b8%8d%e7%ad%89%e5%bc%8f-chebyshevs-inequality"></a>
切比雪夫不等式 (Chebyshev&rsquo;s Inequality)
</h3><p>这是VSM能够工作的数学基石，它利用均值和方差来估算概率。</p>
<ul>
<li>
$$P(X \ge t) \le \frac{\sigma^2}{\sigma^2 + (t - \mu)^2}$$<p>
其中 $\mu$ 是均值, $\sigma^2$ 是方差。这个公式给出了变量 $X$ 的值大于或等于某个值 $t$ 的概率上限。</p>
</li>
<li>
<p><strong>在代码中的应用</strong>:</p>
<ul>
<li>$t$ 是 <strong>探针到当前着色点的距离</strong> (<code>distance_to_biased_point</code>)。</li>
<li>$\mu$ 是 <strong>探针在该方向上到平均遮挡物的距离</strong> (<code>mean_distance_to_occluder</code>)。</li>
<li>当 $t > \mu$ 时，我们怀疑点可能被遮挡了。</li>
<li>代码 <code>variance / (variance + (distance_diff * distance_diff))</code> 正是这个不等式的直接应用。它计算出一个介于 [0, 1] 之间的“遮挡概率”或“光线透过率”，作为可见性权重。</li>
</ul>
</li>
</ul>
<h2 id="计算探针的偏移和状态">
<a class="header-anchor" href="#%e8%ae%a1%e7%ae%97%e6%8e%a2%e9%92%88%e7%9a%84%e5%81%8f%e7%a7%bb%e5%92%8c%e7%8a%b6%e6%80%81"></a>
计算探针的偏移和状态
</h2><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">updateProbeOffsetsAndStatus</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 探针偏移计算 ---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这是一个渐进式更新过程，只在需要时（gi_recalculate_offsets为true）启动，并持续数帧（24帧）以达到稳定。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">static</span> <span class="n">i32</span> <span class="n">offsets_calculations_count</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">render_scene</span><span class="o">-&gt;</span><span class="n">gi_recalculate_offsets</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">offsets_calculations_count</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span> <span class="c1">// 重新开始24帧的计算周期
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果仍在计算周期内，则执行偏移计算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">offsets_calculations_count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">--</span><span class="n">offsets_calculations_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 绑定管线和资源，准备写入探针偏移纹理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 向Shader传递一个标记，告知是否为本轮计算的第一帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">u32</span> <span class="n">first_frame</span> <span class="o">=</span> <span class="p">(</span><span class="n">offsets_calculations_count</span> <span class="o">==</span> <span class="mi">23</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">push_constants</span><span class="p">(</span><span class="n">calculate_probe_offset_pipeline</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first_frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 为每个探针启动一个线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">dispatch</span><span class="p">(</span><span class="n">hydra</span><span class="o">::</span><span class="n">ceilu32</span><span class="p">(</span><span class="n">probe_count</span> <span class="o">/</span> <span class="mf">32.f</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 探针状态计算 ---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这个过程通常每帧都运行，以快速响应场景变化。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 绑定管线和资源，准备更新探针状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 为每个探针启动一个线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">dispatch</span><span class="p">(</span><span class="n">hydra</span><span class="o">::</span><span class="n">ceilu32</span><span class="p">(</span><span class="n">probe_count</span> <span class="o">/</span> <span class="mf">32.f</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="更新探针偏移">
<a class="header-anchor" href="#%e6%9b%b4%e6%96%b0%e6%8e%a2%e9%92%88%e5%81%8f%e7%a7%bb"></a>
更新探针偏移
</h3><p>这个Shader的核心目标是：如果探针位置不佳（例如在墙内或离表面太近），就计算一个偏移量将它移动到更好的位置。</p>
<p>Offset纹理的大小为 <code>probe_count_x * probe_count_y, probe_count_z</code>。</p>
<p><img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507201312076.png" alt=""></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// 每个线程负责一个光照探针</span>
</span></span><span class="line"><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">int</span> <span class="n">probe_index</span> <span class="o">=</span> <span class="k">int</span><span class="p">(</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">probe_index</span> <span class="o">&gt;=</span> <span class="n">total_probes</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="c1">// 越界检查</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 1. 分析光线追踪结果 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历该探针的所有预追踪光线，分析命中信息</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 命中信息来自一个前置的光追Pass，其.w分量存储了距离。约定：w &gt; 0 为正面，w &lt; 0 为背面。</span>
</span></span><span class="line"><span class="cl">    <span class="k">int</span> <span class="n">closest_backface_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>      <span class="c1">// 最近的背面光线索引</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">closest_backface_distance</span> <span class="o">=</span> <span class="mf">100000000.</span><span class="n">f</span><span class="p">;</span> <span class="c1">// 最近的背面距离</span>
</span></span><span class="line"><span class="cl">    <span class="k">int</span> <span class="n">closest_frontface_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>     <span class="c1">// 最近的正面光线索引</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">closest_frontface_distance</span> <span class="o">=</span> <span class="mf">100000000.</span><span class="n">f</span><span class="p">;</span> <span class="c1">// 最近的正面距离</span>
</span></span><span class="line"><span class="cl">    <span class="k">int</span> <span class="n">farthest_frontface_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>    <span class="c1">// 最远的正面光线索引</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">farthest_frontface_distance</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="c1">// 最远的正面距离</span>
</span></span><span class="line"><span class="cl">    <span class="k">int</span> <span class="n">backfaces_count</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span>              <span class="c1">// 背面命中总数</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">ray_index</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="n">ray_index</span> <span class="o">&lt;</span> <span class="n">probe_rays</span><span class="p">;</span> <span class="o">++</span><span class="n">ray_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">ivec2</span> <span class="n">ray_tex_coord</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">ray_index</span><span class="p">,</span> <span class="n">probe_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">ray_distance</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">radiance_output_index</span><span class="p">)],</span> <span class="n">ray_tex_coord</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">ray_distance</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 命中背面</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">backfaces_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="o">-</span><span class="n">ray_distance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">closest_backface_distance</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">closest_backface_distance</span> <span class="o">=</span> <span class="n">dist</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">closest_backface_index</span> <span class="o">=</span> <span class="n">ray_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 命中正面</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">ray_distance</span> <span class="o">&lt;</span> <span class="n">closest_frontface_distance</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">closest_frontface_distance</span> <span class="o">=</span> <span class="n">ray_distance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">closest_frontface_index</span> <span class="o">=</span> <span class="n">ray_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">ray_distance</span> <span class="o">&gt;</span> <span class="n">farthest_frontface_distance</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 注意这里是 if 不是 else if</span>
</span></span><span class="line"><span class="cl">                <span class="n">farthest_frontface_distance</span> <span class="o">=</span> <span class="n">ray_distance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">farthest_frontface_index</span> <span class="o">=</span> <span class="n">ray_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 2. 基于启发式规则计算新偏移 ---</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">full_offset</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">10000.</span><span class="n">f</span><span class="p">);</span> <span class="c1">// 初始设为无效值</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">cell_offset_limit</span> <span class="o">=</span> <span class="n">max_probe_offset</span> <span class="o">*</span> <span class="n">probe_spacing</span><span class="p">;</span> <span class="c1">// 偏移不能超出探针单元格太多</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 读取上一帧的偏移量，实现渐进式更新</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">current_offset</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">first_frame</span> <span class="o">==</span> <span class="mo">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ... (从纹理中读取 current_offset.rgb)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 【启发式规则 1: 探针在墙内】</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果超过1/4的光线击中背面，我们认为探针在几何体内。</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">bool</span> <span class="n">inside_geometry</span> <span class="o">=</span> <span class="p">(</span><span class="k">float</span><span class="p">(</span><span class="n">backfaces_count</span><span class="p">)</span> <span class="o">/</span> <span class="k">float</span><span class="p">(</span><span class="n">probe_rays</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">0.25</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">inside_geometry</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">closest_backface_index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 目标：将探针沿“最近的背面”的反方向推出。</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="k">vec3</span> <span class="n">closest_backface_direction</span> <span class="o">=</span> <span class="n">closest_backface_distance</span> <span class="o">*</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">random_rotation</span><span class="p">)</span> <span class="o">*</span> <span class="n">spherical_fibonacci</span><span class="p">(</span><span class="n">closest_backface_index</span><span class="p">,</span> <span class="n">probe_rays</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ... (计算推出的距离因子 direction_scale_factor)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 新偏移 = 当前偏移 - 推出的向量 (减号代表反方向)</span>
</span></span><span class="line"><span class="cl">        <span class="n">full_offset</span> <span class="o">=</span> <span class="n">current_offset</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">closest_backface_direction</span> <span class="o">*</span> <span class="n">direction_scale_factor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 【启发式规则 2: 探针离墙太近】</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">closest_frontface_distance</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 目标：将探针沿“最远的视线方向”移动，即推向更开阔的空间。</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="k">vec3</span> <span class="n">farthest_direction</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mf">0.2</span><span class="n">f</span><span class="p">,</span> <span class="n">farthest_frontface_distance</span><span class="p">)</span> <span class="o">*</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">random_rotation</span><span class="p">)</span> <span class="o">*</span> <span class="n">spherical_fibonacci</span><span class="p">(</span><span class="n">farthest_frontface_index</span><span class="p">,</span> <span class="n">probe_rays</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="k">vec3</span> <span class="n">closest_direction</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">random_rotation</span><span class="p">)</span> <span class="o">*</span> <span class="n">spherical_fibonacci</span><span class="p">(</span><span class="n">closest_frontface_index</span><span class="p">,</span> <span class="n">probe_rays</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果最远和最近方向大致相反（点积小），才进行移动，避免在角落里抖动</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">farthest_direction</span><span class="p">,</span> <span class="n">closest_direction</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">full_offset</span> <span class="o">=</span> <span class="n">current_offset</span><span class="p">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="n">farthest_direction</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 3. 应用并写回新偏移 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 只有当计算出的新偏移在合理范围内时，才更新它</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">all</span><span class="p">(</span><span class="n">lessThan</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">full_offset</span><span class="p">),</span> <span class="n">cell_offset_limit</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">current_offset</span><span class="p">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">full_offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将最终偏移写回纹理</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">global_images_2d</span><span class="p">[</span><span class="n">probe_offset_texture_index</span><span class="p">],</span> <span class="cm">/* ... coords ... */</span><span class="p">,</span> <span class="n">current_offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="更新探针状态">
<a class="header-anchor" href="#%e6%9b%b4%e6%96%b0%e6%8e%a2%e9%92%88%e7%8a%b6%e6%80%81"></a>
更新探针状态
</h3><p>这个Shader的目标是判断每个探针应该是激活状态（参与光照计算）还是关闭状态（在空旷区域或墙内，可以跳过）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// 每个线程负责一个光照探针</span>
</span></span><span class="line"><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">int</span> <span class="n">probe_index</span> <span class="o">=</span> <span class="k">int</span><span class="p">(</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... (越界检查)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 1. 分析光线追踪结果 (与上一个Shader类似) ---</span>
</span></span><span class="line"><span class="cl">    <span class="k">int</span> <span class="n">backfaces_count</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">closest_frontface_distance</span> <span class="o">=</span> <span class="mf">100000000.</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... (省略类似的循环和变量来查找背面命中数和最近正面距离)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">ray_index</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="n">ray_index</span> <span class="o">&lt;</span> <span class="n">probe_rays</span><span class="p">;</span> <span class="o">++</span><span class="n">ray_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 2. 基于启发式规则判断状态 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 读取上一帧的状态</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">probe_status</span><span class="p">[</span><span class="n">probe_index</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 定义一个有效着色范围，如果命中点在此范围内，探针就应该激活</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">outerBounds</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">probe_spacing</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">probe_spacing</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mf">2.0</span><span class="n">f</span> <span class="o">*</span> <span class="n">self_shadow_bias</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 重新检查所有正面命中</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">ray_index</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="n">ray_index</span> <span class="o">&lt;</span> <span class="n">probe_rays</span><span class="p">;</span> <span class="o">++</span><span class="n">ray_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">d_front</span> <span class="o">=</span> <span class="cm">/* ... texelFetch ... */</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">d_front</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">frontFaceDirection</span> <span class="o">=</span> <span class="n">d_front</span> <span class="o">*</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">random_rotation</span><span class="p">)</span> <span class="o">*</span> <span class="n">spherical_fibonacci</span><span class="p">(</span><span class="n">ray_index</span><span class="p">,</span> <span class="n">probe_rays</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 【规则1: 激活】如果任何一个命中点在有效范围内，说明此探针能影响附近表面，激活它。</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">all</span><span class="p">(</span><span class="n">lessThan</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">frontFaceDirection</span><span class="p">),</span> <span class="n">outerBounds</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">flag</span> <span class="o">=</span> <span class="n">PROBE_STATUS_ACTIVE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 【规则2: 关闭】如果探针在墙内，关闭它。</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">closest_backface_index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="k">float</span><span class="p">(</span><span class="n">backfaces_count</span><span class="p">)</span> <span class="o">/</span> <span class="k">float</span><span class="p">(</span><span class="n">probe_rays</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">0.25</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">flag</span> <span class="o">=</span> <span class="n">PROBE_STATUS_OFF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 【规则3: 关闭】如果探针什么正面都没看到（例如在天空或空旷区域），关闭它。</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">closest_frontface_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">flag</span> <span class="o">=</span> <span class="n">PROBE_STATUS_OFF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 【规则4: 激活】如果探针离某个表面非常近，激活它。</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">closest_frontface_distance</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">flag</span> <span class="o">=</span> <span class="n">PROBE_STATUS_ACTIVE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 3. 写回新状态 ---</span>
</span></span><span class="line"><span class="cl">    <span class="n">probe_status</span><span class="p">[</span><span class="n">probe_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">flag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>整个决策过程并非精确的物理模拟，而是基于一套高效的<strong>启发式规则（经验法则）</strong>。这些规则是通过观察和实验总结出来的，能在保证速度的同时达到很好的效果。</p>
<ul>
<li><code>&quot;backfaces_count / probe_rays &gt; 0.25f&quot;</code> 就是一个典型的启发式规则，它简单快速地判断出“探针大概率在几何体内”。</li>
<li>“沿最远视线方向移动”也是一个聪明的做法，它能引导探针自动寻找并移动到局部空间的中心位置。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      

      

      

      

      

      

      
      <ul class="article-tag-list" itemprop="keywords">
  
</ul>

    </footer>
  </div>
  
    
  <nav
    id="article-nav"
    data-aos="fade-up"
  >
    
      <div class="article-nav-link-wrap article-nav-link-left">
        
          
          
            <img
              data-src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202412220910158.jpg"
              data-sizes="auto"
              alt="Temporal Anti-Aliasing稳定性探究"
              class="lazyload"
            />
          
        
        <a href="https://nothingtosay0031.github.io/post/taa/"></a>
        <div class="article-nav-caption">Newer</div>
        <h3 class="article-nav-title">
          
            Temporal Anti-Aliasing稳定性探究
          
        </h3>
      </div>
    

    
      <div class="article-nav-link-wrap article-nav-link-right">
        
          
          
            <img
              data-src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202412220910158.jpg"
              data-sizes="auto"
              alt="Unreal Engine 与着色器卡顿：PSO 预缓存解决方案"
              class="lazyload"
            />
          
        
        <a href="https://nothingtosay0031.github.io/post/ue_pso/"></a>
        <div class="article-nav-caption">Older</div>
        <h3 class="article-nav-title">
          
            Unreal Engine 与着色器卡顿：PSO 预缓存解决方案
          
        </h3>
      </div>
    
  </nav>


  
</article>










</section>
          
            <aside id="sidebar">
  <div class="sidebar-wrapper wrap-sticky">
    <div
      class="sidebar-wrap"
      data-aos="fade-up"
    >
      
        <div class="sidebar-toc-sidebar">
          <div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#dynamic-diffuse-global-illumination-ddgi">Dynamic Diffuse Global Illumination (DDGI)</a>
      <ul>
        <li><a href="#辐射度采集-gather-radiance">辐射度采集 (Gather Radiance)</a>
          <ul>
            <li><a href="#数据流与gpu调度">数据流与GPU调度</a></li>
            <li><a href="#ray-generation-shader-射线生成着色器">Ray Generation Shader (射线生成着色器)</a></li>
            <li><a href="#closest-hit-shader-最近命中着色器">Closest Hit Shader (最近命中着色器)</a></li>
            <li><a href="#miss-shader-未命中着色器">Miss Shader (未命中着色器)</a></li>
          </ul>
        </li>
        <li><a href="#核心辅助函数-core-helper-functions">核心辅助函数 (Core Helper Functions)</a>
          <ul>
            <li><a href="#球面斐波那契采样-spherical-fibonacci-sampling">球面斐波那契采样 (Spherical Fibonacci Sampling)</a></li>
            <li><a href="#八面体映射-octahedral-mapping">八面体映射 (Octahedral Mapping)</a></li>
            <li><a href="#3-探针网格与世界空间变换">3. 探针网格与世界空间变换</a></li>
            <li><a href="#4-探针图集坐标计算-probe-atlas-coordinates">4. 探针图集坐标计算 (Probe Atlas Coordinates)</a></li>
          </ul>
        </li>
        <li><a href="#更新辐照度与可见性-update-irradiance-and-visibility">更新辐照度与可见性 (Update Irradiance and Visibility)</a>
          <ul>
            <li><a href="#cpu端调度">CPU端调度</a></li>
            <li><a href="#计算着色器详解">计算着色器详解</a>
              <ul>
                <li><a href="#1-核心计算探针内部像素">1. 核心计算（探针内部像素）</a></li>
                <li><a href="#2-边界处理探针边缘像素">2. 边界处理（探针边缘像素）</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#采样-irradiance-probes">采样 Irradiance Probes</a>
          <ul>
            <li><a href="#三线性插值-trilinear-interpolation">三线性插值 (Trilinear Interpolation)</a></li>
            <li><a href="#方差阴影贴图-variance-shadow-mapping---vsm">方差阴影贴图 (Variance Shadow Mapping - VSM)</a></li>
            <li><a href="#切比雪夫不等式-chebyshevs-inequality">切比雪夫不等式 (Chebyshev&rsquo;s Inequality)</a></li>
          </ul>
        </li>
        <li><a href="#计算探针的偏移和状态">计算探针的偏移和状态</a>
          <ul>
            <li><a href="#更新探针偏移">更新探针偏移</a></li>
            <li><a href="#更新探针状态">更新探针状态</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
        </div>
        <div class="sidebar-common-sidebar hidden">
          
<div class="sidebar-author">
  <img
    data-src="https://nothingtosay0031.github.io/avatar/../avatar.webp"
    data-sizes="auto"
    alt="NothingToSay0031"
    class="lazyload"
  />
  <div class="sidebar-author-name">NothingToSay0031</div>
  <div class="sidebar-description">又是一个做水果蛋糕的好天气啊！</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div>
    
    <div class="sidebar-state-number">24</div>
  </div>
  <div class="sidebar-state-category">
    <div>Categories</div>
    <div class="sidebar-state-number">
      0
    </div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tags</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-email sidebar-social-icon">
      <a
        href="mailto:jhwzju@gmail.com"
        itemprop="url"
        target="_blank"
        aria-label="email"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-github sidebar-social-icon">
      <a
        href="https://github.com/NothingToSay0031"
        itemprop="url"
        target="_blank"
        aria-label="github"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-linkedin sidebar-social-icon">
      <a
        href="https://www.linkedin.com/in/hongweiji"
        itemprop="url"
        target="_blank"
        aria-label="linkedin"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/"
        aria-label="Home"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Home</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/archives"
        aria-label="Archives"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Archives</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/about"
        aria-label="About"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">About</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/friend"
        aria-label="Friend"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Friend</div>
    </div>
  
</div>

        </div>
      

      
        <div class="sidebar-btn-wrapper" style="position:static">
          <div class="sidebar-toc-btn current"></div>
          <div class="sidebar-common-btn"></div>
        </div>
      
    </div>
  </div>

  
</aside>

          
        </main>
        



  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  



<footer id="footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div id="footer-info">
    <div>
      <span class="icon-copyright"></span>
      2021 -
      2025
      <span class="footer-info-sep rotate"></span>
      NothingToSay0031
    </div>
    
      <div>
        Powered by&nbsp;<a
          href="https://gohugo.io/"
          target="_blank"
          >Hugo</a
        >&nbsp; Theme.<a
          href="https://github.com/D-Sketon/hugo-theme-reimu"
          target="_blank"
          >Reimu</a
        >
      </div>
    
    
      <div>
        <span class="icon-brush"
          >&nbsp;
            60.6k
          </span
        >
        &nbsp;|&nbsp;
        <span class="icon-coffee">&nbsp;
          
          

          04:58
        </span>
      </div>
    
    
    
    
      <div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv"
          >Number of visits&nbsp;<span
            id="busuanzi_value_site_pv"
          ></span
        ></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv"
          >Number of visitors&nbsp;<span
            id="busuanzi_value_site_uv"
          ></span
        ></span>
      </div>
    
  </div>
</footer>

        
          <div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div>
        
        <div id="mask" class="hide"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar">
        <div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#dynamic-diffuse-global-illumination-ddgi">Dynamic Diffuse Global Illumination (DDGI)</a>
      <ul>
        <li><a href="#辐射度采集-gather-radiance">辐射度采集 (Gather Radiance)</a>
          <ul>
            <li><a href="#数据流与gpu调度">数据流与GPU调度</a></li>
            <li><a href="#ray-generation-shader-射线生成着色器">Ray Generation Shader (射线生成着色器)</a></li>
            <li><a href="#closest-hit-shader-最近命中着色器">Closest Hit Shader (最近命中着色器)</a></li>
            <li><a href="#miss-shader-未命中着色器">Miss Shader (未命中着色器)</a></li>
          </ul>
        </li>
        <li><a href="#核心辅助函数-core-helper-functions">核心辅助函数 (Core Helper Functions)</a>
          <ul>
            <li><a href="#球面斐波那契采样-spherical-fibonacci-sampling">球面斐波那契采样 (Spherical Fibonacci Sampling)</a></li>
            <li><a href="#八面体映射-octahedral-mapping">八面体映射 (Octahedral Mapping)</a></li>
            <li><a href="#3-探针网格与世界空间变换">3. 探针网格与世界空间变换</a></li>
            <li><a href="#4-探针图集坐标计算-probe-atlas-coordinates">4. 探针图集坐标计算 (Probe Atlas Coordinates)</a></li>
          </ul>
        </li>
        <li><a href="#更新辐照度与可见性-update-irradiance-and-visibility">更新辐照度与可见性 (Update Irradiance and Visibility)</a>
          <ul>
            <li><a href="#cpu端调度">CPU端调度</a></li>
            <li><a href="#计算着色器详解">计算着色器详解</a>
              <ul>
                <li><a href="#1-核心计算探针内部像素">1. 核心计算（探针内部像素）</a></li>
                <li><a href="#2-边界处理探针边缘像素">2. 边界处理（探针边缘像素）</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#采样-irradiance-probes">采样 Irradiance Probes</a>
          <ul>
            <li><a href="#三线性插值-trilinear-interpolation">三线性插值 (Trilinear Interpolation)</a></li>
            <li><a href="#方差阴影贴图-variance-shadow-mapping---vsm">方差阴影贴图 (Variance Shadow Mapping - VSM)</a></li>
            <li><a href="#切比雪夫不等式-chebyshevs-inequality">切比雪夫不等式 (Chebyshev&rsquo;s Inequality)</a></li>
          </ul>
        </li>
        <li><a href="#计算探针的偏移和状态">计算探针的偏移和状态</a>
          <ul>
            <li><a href="#更新探针偏移">更新探针偏移</a></li>
            <li><a href="#更新探针状态">更新探针状态</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
      </div>
      <div class="sidebar-common-sidebar hidden">
        
<div class="sidebar-author">
  <img
    data-src="https://nothingtosay0031.github.io/avatar/../avatar.webp"
    data-sizes="auto"
    alt="NothingToSay0031"
    class="lazyload"
  />
  <div class="sidebar-author-name">NothingToSay0031</div>
  <div class="sidebar-description">又是一个做水果蛋糕的好天气啊！</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div>
    
    <div class="sidebar-state-number">24</div>
  </div>
  <div class="sidebar-state-category">
    <div>Categories</div>
    <div class="sidebar-state-number">
      0
    </div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tags</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-email sidebar-social-icon">
      <a
        href="mailto:jhwzju@gmail.com"
        itemprop="url"
        target="_blank"
        aria-label="email"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-github sidebar-social-icon">
      <a
        href="https://github.com/NothingToSay0031"
        itemprop="url"
        target="_blank"
        aria-label="github"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-linkedin sidebar-social-icon">
      <a
        href="https://www.linkedin.com/in/hongweiji"
        itemprop="url"
        target="_blank"
        aria-label="linkedin"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/"
        aria-label="Home"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Home</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/archives"
        aria-label="Archives"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Archives</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/about"
        aria-label="About"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">About</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/friend"
        aria-label="Friend"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Friend</div>
    </div>
  
</div>

      </div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    
    






  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js"
    
    
    
    
    integrity="sha384-3gT/vsepWkfz/ff7PpWNUeMzeWoH3cDhm/A8jM7ouoAK0/fP/9bcHHR5kHq2nf&#43;e" crossorigin="anonymous"
  ></script>




  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js"
    
    
    
    
    integrity="sha384-J08i8An/QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"
  ></script>









  
      
      <script src="https://nothingtosay0031.github.io/js/main.js" integrity="" crossorigin="anonymous" ></script>
      



  





  
      
      <script src="https://nothingtosay0031.github.io/js/aos.js" integrity="" crossorigin="anonymous" ></script>
      

  <script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", aosInit);
    } else {
      aosInit();
    }
  </script>








  
      
      <script src="https://nothingtosay0031.github.io/js/pjax_main.js" integrity="" crossorigin="anonymous" data-pjax></script>
      





  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/mouse-firework@0.0.6/dist/index.umd.js"
    
    
    
    
    integrity="sha384-vkGvf25gm1C1PbcoD5dNfc137HzNL/hr1RKA5HniJOaawtvUmH5lTVFgFAruE9Ge" crossorigin="anonymous"
  ></script>


<script>
  if (window.firework) {
    const options = JSON.parse("{\"excludeelements\":[\"a\",\"button\"],\"particles\":[{\"colors\":[\"#ff5252\",\"#ff7c7c\",\"#ffafaf\",\"#ffd0d0\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"emit\"],\"number\":20,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.3,0.5],\"radius\":[16,32]}},{\"colors\":[\"#ff0000\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"diffuse\"],\"number\":1,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.2,0.5],\"lineWidth\":6,\"radius\":20}}]}");
    options.excludeElements = options.excludeelements;
    delete options.excludeelements;
    window.firework(options);
  }
</script>








<div id="lazy-script">
  <div>
    
    
      





  
      
      <script src="https://nothingtosay0031.github.io/js/insert_highlight.js" integrity="" crossorigin="anonymous" data-pjax></script>
      

      
      
      
      
      <script type="module" data-pjax>
        const PhotoSwipeLightbox = (await safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe-lightbox.esm.min.js", "sha384-DiL6M\/gG\u002bwmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF\/N6lrZi\/")).default;

        const pswp = () => {
          if (_$$('.article-entry a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-entry',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")
            }).init();
          }
          if(_$$('.article-gallery a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-gallery',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")
            }).init();
          }
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script>
      












    
    
      
        

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/katex@0.16.9/dist/katex.min.js"
    
    
    data-pjax
    
    integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8" crossorigin="anonymous"
  ></script>


        

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/katex@0.16.9/dist/contrib/auto-render.min.js"
    
    
    data-pjax
    
    integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05" crossorigin="anonymous"
  ></script>


        <script data-pjax>
          var renderMath = () => {
            if (!window.renderMathInElement) return;
            window.renderMathInElement(document.body, {
              delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "\\[", right: "\\]", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
              ],
            });
          };
          if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", renderMath, { once: true });
          } else {
            renderMath();
          }
        </script>
      
      
    
  </div>
</div>




  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js"
    
    async
    
    
    integrity="sha384-0M75wtSkhjIInv4coYlaJU83&#43;OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id&#43;S" crossorigin="anonymous"
  ></script>





  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then((registrations) => {
        for (let registration of registrations) {
          registration.unregister();
        }
      });
    }
  </script>


<script>
  const reimuCopyright = String.raw`
   ______     ______     __     __    __     __  __    
  /\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
  \ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
   \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
    \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                    
  `;
  console.log(String.raw`%c ${reimuCopyright}`, "color: #ff5252;");
  console.log(
    "%c Theme.Reimu" + " %c https://github.com/D-Sketon/hugo-theme-reimu ",
    "color: white; background: #ff5252; padding:5px 0;",
    "padding:4px;border:1px solid #ff5252;",
  );
</script>

  </body>
</html>
