<!doctype html>
<html
  lang="en-us"
  
>
  <head>
    <meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, shrink-to-fit=no"
/>







  

<title>
  Realtime Ray Tracing with Vulkan | NothingToSay0031
</title>
<meta
  name="description"
  content="DDGI, Raytraced Shadows, Raytraced Reflections, and TAA."
/>










<script>
  window.siteConfig = JSON.parse("{\"anchor_icon\":null,\"clipboard\":{\"copyright\":{\"content\":\"本文版权：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！\",\"count\":50,\"enable\":false},\"fail\":\"复制失败 (ﾟ⊿ﾟ)ﾂ\",\"success\":\"复制成功(*^▽^*)\"},\"code_block\":{\"expand\":true},\"icon_font\":\"4552607_tq6stt6tcg\",\"outdate\":{\"daysago\":180,\"enable\":false,\"message\":\"本文最后更新于 {time}，请注意文中内容可能已经发生变化。\"}}");
</script>











  
  
  
    
  

  
  
  
    
  

  
    

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  rel="preload"
  as="style"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
/>
<link
  rel="stylesheet"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
  media="print"
  onload="this.media='all'"
/>






  <link
    rel="preload"
    href="//at.alicdn.com/t/c/font_4552607_tq6stt6tcg.woff2"
    as="font"
    type="font/woff2"
    crossorigin="anonymous"
  />



  







  
 <link rel="stylesheet" href="https://nothingtosay0031.github.io/css/loader.min.2ad0e9bbffb534e893c0ecefc44787a277cf851387e8ad9dccfbc3a5f0886dbe.css" />




  <meta property="og:type" content="website" />
  <meta property="og:title" content="Realtime Ray Tracing with Vulkan | NothingToSay0031" />
  <meta
    property="og:description"
    content="DDGI, Raytraced Shadows, Raytraced Reflections, and TAA."
  />
  <meta property="og:url" content="https://nothingtosay0031.github.io/post/vulkanrtx/" />
  <meta
    property="og:site_name"
    content="NothingToSay0031"
  />
  <meta
    property="og:image"
    content="/"
  />
  <meta property="article:author" content="NothingToSay0031" />
  <meta property="article:published_time" content="2025-05-25T15:11:48&#43;00:00" />
  <meta property="article:modified_time" content="2025-05-25T15:11:48&#43;00:00" />
  
  
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:image" content="/" />
  
  
  
  
  




<link rel="shortcut icon" href="https://nothingtosay0031.github.io/favicon.ico">








  
 <link rel="stylesheet" href="https://nothingtosay0031.github.io/css/main.min.4e3ed4ec96a449612baa01e942ad2e62fab14c5e1e8f6b3eeb13d1cbc2e0dc67.css" />





  <link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css"
    onload="this.onload=null;this.rel='stylesheet'"
  />






  <link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/katex@0.16.9/dist/katex.min.css"
    onload="this.onload=null;this.rel='stylesheet'"
  />








  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js"
    
    
    
    
    integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"
  ></script>





  


  <link rel="stylesheet" href="https://npm.webcache.cn/@reimujs/aos@0.1.0/dist/aos.css" />




  </head>
  <body>
    
  <div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        
          <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
            <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="#ff5252" />
            <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z 
          M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95z" fill="#ff5252" />
          </svg>
        
      </div>
      <div class="loading-word">少女祈祷中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>


<div id="copy-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
</div>


    <div id="container">
      <div id="wrap">
        
<div id="header-nav">
  <nav id="main-nav">
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/">Home</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/archives">Archives</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/about">About</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/friend">Friend</a>
      </span>
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
    
  </nav>
</div>
<header id="header">
  
    <img fetchpriority="high" src="https://nothingtosay0031.github.io/images/banner.webp" alt="Realtime Ray Tracing with Vulkan">
  

  <div id="header-outer">
    <div id="header-title">
      
        
        
          
        
  
        
          <a href="https://nothingtosay0031.github.io/" id="logo">
            <h1 data-aos="slide-up">Realtime Ray Tracing with Vulkan</h1>
          </a>
        
      
  
      
        
        
        <h2 id="subtitle-wrap" data-aos="slide-down">
          
        </h2>
      
    </div>
  </div>
</header>
        <main id="content">
          
          <section id="main">
  <article
  class="h-entry article"
  itemprop="blogPost"
  itemscope
  itemtype="https://schema.org/BlogPosting"
>
  <div
    class="article-inner"
    data-aos="fade-up"
  >
    <div class="article-meta">
      <div class="article-date">
  <a
    href="https://nothingtosay0031.github.io/post/vulkanrtx/"
    class="article-date-link"
    data-aos="zoom-in"
  >
    <time datetime="2025-05-25 15:11:48 &#43;0000 UTC" itemprop="datePublished"
      >2025-05-25</time
    >
    <time style="display: none;" id="post-update-time"
      >2025-05-25</time
    >
  </a>
</div>

      <div class="article-category">
  
</div>

    </div>
    <div class="hr-line"></div>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
      
        <h1 id="dynamic-diffuse-global-illumination-ddgi">
<a class="header-anchor" href="#dynamic-diffuse-global-illumination-ddgi"></a>
Dynamic Diffuse Global Illumination (DDGI)
</h1><p>动态漫反射全局光照（<a href="https://www.jcgt.org/published/0008/02/01/paper-lowres.pdf">DDGI</a>）是一种用于实时渲染中模拟间接光照的强大技术。其核心思想是在场景中布置一个规则的探针网格（Probe Grid），并预计算每个探针接收到的来自周围环境的光照。</p>
<h2 id="工作流程">
<a class="header-anchor" href="#%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b"></a>
工作流程
</h2><ol>
<li><strong>辐射度采集 (Gather Radiance)</strong>: 从每个探针位置向周围发射光线，采集光照信息。</li>
<li><strong>辐照度更新 (Update Irradiance)</strong>: 使用采集到的光照信息更新探针的辐照度数据。</li>
<li><strong>可见性更新 (Update Visibility)</strong>: 更新探针的可见性数据，用于后续的阴影计算。</li>
<li><strong>（可选）探针偏移更新 (Probe Offset Update)</strong>: 根据光线追踪的距离调整每个探针的位置偏移，以更好地适应场景几何体。</li>
<li><strong>间接光照计算 (Indirect Lighting Calculation)</strong>: 使用更新后的辐照度和可见性数据计算场景的间接光照。</li>
</ol>
<h2 id="辐射度采集-gather-radiance">
<a class="header-anchor" href="#%e8%be%90%e5%b0%84%e5%ba%a6%e9%87%87%e9%9b%86-gather-radiance"></a>
辐射度采集 (Gather Radiance)
</h2><p>此阶段的目标是为场景中的每个光照探针（Light Probe）计算其从各个方向接收到的入射光（Radiance）和对应的光线传播距离。这本质上是一个大规模的光线追踪过程，我们从每个探针的位置向半球或全球领域发射大量光线，记录它们击中场景后的光照信息。</p>
<p>最终的输出是一张二维纹理 <code>probe_raytrace_radiance_texture</code>，其尺寸为 <code>[num_rays, num_probes]</code>。纹理中的每一个像素 <code>(x, y)</code> 存储了第 <code>y</code> 个探针沿第 <code>x</code> 个方向发射的光线所采集到的辐射度（RGB）和距离（A）。</p>
<p><img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507201311937.png" alt=""></p>
<h3 id="数据流与gpu调度">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e6%b5%81%e4%b8%8egpu%e8%b0%83%e5%ba%a6"></a>
数据流与GPU调度
</h3><p>在CPU端，我们通过一个光线追踪指令来启动整个GPU计算过程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 准备工作：确保目标纹理处于可写入状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">issue_texture_barrier</span><span class="p">(</span><span class="n">probe_raytrace_radiance_texture</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">RESOURCE_STATE_UNORDERED_ACCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 绑定光线追踪管线和所需的资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">bind_pipeline</span><span class="p">(</span><span class="n">probe_raytrace_pipeline</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">bind_descriptor_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">probe_raytrace_descriptor_set</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 确定需要更新的探针数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="n">u32</span> <span class="n">probe_count</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">offsets_calculations_count</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">get_total_probes</span><span class="p">()</span> <span class="o">:</span> <span class="n">per_frame_probe_updates</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 发射光线：为每个探针（probe_count）发射指定数量（probe_rays）的光线
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">trace_rays</span><span class="p">(</span><span class="n">probe_raytrace_pipeline</span><span class="p">,</span> <span class="n">probe_rays</span><span class="p">,</span> <span class="n">probe_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 计算完成后，再次设置屏障，以便后续阶段可以读取该纹理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">issue_texture_barrier</span><span class="p">(</span><span class="n">probe_raytrace_radiance_texture</span><span class="p">,</span> <span class="n">RESOURCE_STATE_UNORDERED_ACCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></div><p><code>trace_rays</code> 函数是核心。它在GPU上启动一个 <code>probe_rays * probe_count</code> 的二维计算网格。GPU上的每个工作单元（线程）将负责处理一个探针的一条光线。</p>
<h3 id="ray-generation-shader-射线生成着色器">
<a class="header-anchor" href="#ray-generation-shader-%e5%b0%84%e7%ba%bf%e7%94%9f%e6%88%90%e7%9d%80%e8%89%b2%e5%99%a8"></a>
Ray Generation Shader (射线生成着色器)
</h3><p>这是光追管线的入口点。每个线程执行一次，负责生成一条光线的起点、方向，并发起追踪。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// layout(binding = X) uniform accelerationStructureEXT as;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// layout(binding = Y, set = 0, rgba32f) uniform image2D radiance_output_texture;</span>
</span></span><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span> <span class="n">location</span> <span class="o">=</span> <span class="mo">0</span> <span class="p">)</span> <span class="n">rayPayloadEXT</span> <span class="n">RayPayload</span> <span class="n">payload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// gl_LaunchIDEXT 是内置变量，代表当前线程在网格中的二维索引</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// .x 是光线索引, .y 是探针索引</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">ivec2</span> <span class="n">pixel_coord</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">gl_LaunchIDEXT</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">int</span> <span class="n">probe_index</span> <span class="o">=</span> <span class="n">pixel_coord</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">probe_update_offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">int</span> <span class="n">ray_index</span> <span class="o">=</span> <span class="n">pixel_coord</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 省略探针状态检查 ...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 计算光线起点 (Ray Origin)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    将一维的探针索引转换为三维网格坐标，再转换到世界空间位置</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec3</span> <span class="n">probe_grid_indices</span> <span class="o">=</span> <span class="n">probe_index_to_grid_indices</span><span class="p">(</span><span class="n">probe_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">ray_origin</span> <span class="o">=</span> <span class="n">grid_indices_to_world</span><span class="p">(</span><span class="n">probe_grid_indices</span><span class="p">,</span> <span class="n">probe_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 计算光线方向 (Ray Direction)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    使用球斐波那契晶格（Spherical Fibonacci）生成均匀分布在球面上的方向</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    再通过一个随机旋转矩阵来抖动采样，避免时间上的条带瑕疵</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">random_rotation</span><span class="p">)</span> <span class="o">*</span> <span class="n">spherical_fibonacci</span><span class="p">(</span><span class="n">ray_index</span><span class="p">,</span> <span class="n">probe_rays</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 初始化光线负载 (Payload)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    Payload 是用于在着色器之间传递数据的结构体</span>
</span></span><span class="line"><span class="cl">    <span class="n">payload</span><span class="p">.</span><span class="n">radiance</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">payload</span><span class="p">.</span><span class="n">distance</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4. 发射光线</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    调用内置函数，在场景加速结构（as）中追踪光线</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    如果命中，将调用 Closest Hit Shader；否则调用 Miss Shader</span>
</span></span><span class="line"><span class="cl">    <span class="n">traceRayEXT</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">gl_RayFlagsOpaqueEXT</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="n">ray_origin</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 5. 存储结果</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    光线追踪结束后，Payload 中已写入了命中点的辐射度和距离</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    将结果写入输出纹理的对应位置</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">global_images_2d</span><span class="p">[</span><span class="n">radiance_output_index</span><span class="p">],</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">ray_index</span><span class="p">,</span> <span class="n">probe_index</span><span class="p">),</span> <span class="k">vec4</span><span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="n">radiance</span><span class="p">,</span> <span class="n">payload</span><span class="p">.</span><span class="n">distance</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>spherical_fibonacci</code> 函数是实现均匀球面采样的关键。为了用蒙特卡洛方法估算一个点接收到的半球积分（渲染方程），我们需要在半球上生成一系列分布均匀的采样方向。相比于简单的随机采样，斐波那契晶格能以更少的样本数达到更好的分布效果，减少噪点。</p>
<h3 id="closest-hit-shader-最近命中着色器">
<a class="header-anchor" href="#closest-hit-shader-%e6%9c%80%e8%bf%91%e5%91%bd%e4%b8%ad%e7%9d%80%e8%89%b2%e5%99%a8"></a>
Closest Hit Shader (最近命中着色器)
</h3><p>当光线击中场景中的某个几何体时，该着色器被调用。它的核心职责是确定命中点的光照信息。然而，与传统渲染不同，DDGI中的光线是从探针发出的，探针本身可能位于几何体内部或与其表面非常接近。因此，我们必须区分光线是击中了物体的“正面”还是“背面”。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">buffer_reference</span><span class="p">,</span> <span class="n">std430</span><span class="p">,</span> <span class="n">buffer_reference_align</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">buffer</span> <span class="n">int_array_type</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint16_t</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">buffer_reference</span><span class="p">,</span> <span class="n">std430</span><span class="p">,</span> <span class="n">buffer_reference_align</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="n">buffer</span> <span class="n">vec2_array_type</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">buffer_reference</span><span class="p">,</span> <span class="n">std430</span><span class="p">,</span> <span class="n">buffer_reference_align</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="n">buffer</span> <span class="n">float_array_type</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span> <span class="n">location</span> <span class="o">=</span> <span class="mo">0</span> <span class="p">)</span> <span class="n">rayPayloadInEXT</span> <span class="n">RayPayload</span> <span class="n">payload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">hitAttributeEXT</span> <span class="k">vec2</span> <span class="n">barycentric_weights</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化输出变量</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">radiance</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">distance</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 步骤 0: 处理背面命中 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这是一个关键的健壮性处理。如果光线击中三角形的背面，</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 通常意味着探针位于模型内部。我们不计算光照，</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 而是将距离标记为负数，以在后续阶段识别并处理这种情况，防止漏光。</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">gl_HitKindEXT</span> <span class="o">==</span> <span class="n">gl_HitKindBackFacingTriangleEXT</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">distance</span> <span class="o">=</span> <span class="p">(</span><span class="n">gl_RayTminEXT</span> <span class="o">+</span> <span class="n">gl_HitTEXT</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="mf">0.2</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 步骤 1: 获取命中几何体的数据 ---</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 使用光追管线提供的内置变量，定位到具体的模型实例和三角形。</span>
</span></span><span class="line"><span class="cl">        <span class="n">uint</span> <span class="n">mesh_index</span> <span class="o">=</span> <span class="n">mesh_instance_draws</span><span class="p">[</span><span class="n">gl_GeometryIndexEXT</span><span class="p">].</span><span class="n">mesh_draw_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">MeshDraw</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh_draws</span><span class="p">[</span><span class="n">mesh_index</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 从索引缓冲区获取构成该三角形的三个顶点的索引。</span>
</span></span><span class="line"><span class="cl">        <span class="n">int_array_type</span> <span class="n">index_buffer</span> <span class="o">=</span> <span class="n">int_array_type</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">index_buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">int</span> <span class="n">i0</span> <span class="o">=</span> <span class="n">index_buffer</span><span class="p">[</span><span class="n">gl_PrimitiveID</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mo">0</span><span class="p">].</span><span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">index_buffer</span><span class="p">[</span><span class="n">gl_PrimitiveID</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">int</span> <span class="n">i2</span> <span class="o">=</span> <span class="n">index_buffer</span><span class="p">[</span><span class="n">gl_PrimitiveID</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">].</span><span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 步骤 2: 使用重心坐标插值顶点属性 ---</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 硬件会提供命中点在三角形内的精确重心坐标。</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">b</span> <span class="o">=</span> <span class="n">barycentric_weights</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">c</span> <span class="o">=</span> <span class="n">barycentric_weights</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">-</span> <span class="n">b</span> <span class="o">-</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 从顶点缓冲区中获取三个顶点的局部坐标。</span>
</span></span><span class="line"><span class="cl">        <span class="n">float_array_type</span> <span class="n">vertex_buffer</span> <span class="o">=</span> <span class="n">float_array_type</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">position_buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec4</span> <span class="n">p0</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">vertex_buffer</span><span class="p">[</span><span class="n">i0</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mo">0</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">vertex_buffer</span><span class="p">[</span><span class="n">i0</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">vertex_buffer</span><span class="p">[</span><span class="n">i0</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec4</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">vertex_buffer</span><span class="p">[</span><span class="n">i1</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mo">0</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">vertex_buffer</span><span class="p">[</span><span class="n">i1</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">vertex_buffer</span><span class="p">[</span><span class="n">i1</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec4</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">vertex_buffer</span><span class="p">[</span><span class="n">i2</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mo">0</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">vertex_buffer</span><span class="p">[</span><span class="n">i2</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">vertex_buffer</span><span class="p">[</span><span class="n">i2</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 将顶点位置变换到世界空间。</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">mat4</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">mesh_instance_draws</span><span class="p">[</span><span class="n">gl_GeometryIndexEXT</span><span class="p">].</span><span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec4</span> <span class="n">p0_world</span> <span class="o">=</span> <span class="n">transform</span> <span class="o">*</span> <span class="n">p0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec4</span> <span class="n">p1_world</span> <span class="o">=</span> <span class="n">transform</span> <span class="o">*</span> <span class="n">p1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec4</span> <span class="n">p2_world</span> <span class="o">=</span> <span class="n">transform</span> <span class="o">*</span> <span class="n">p2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 插值计算出命中点的精确世界坐标。</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="k">vec3</span> <span class="n">world_position</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">p0_world</span><span class="p">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">p1_world</span><span class="p">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">p2_world</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 同理，插值计算出UV坐标。</span>
</span></span><span class="line"><span class="cl">        <span class="n">vec2_array_type</span> <span class="n">uv_buffer</span> <span class="o">=</span> <span class="n">vec2_array_type</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">uv_buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec2</span> <span class="n">uv0</span> <span class="o">=</span> <span class="n">uv_buffer</span><span class="p">[</span><span class="n">i0</span><span class="p">].</span><span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec2</span> <span class="n">uv1</span> <span class="o">=</span> <span class="n">uv_buffer</span><span class="p">[</span><span class="n">i1</span><span class="p">].</span><span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec2</span> <span class="n">uv2</span> <span class="o">=</span> <span class="n">uv_buffer</span><span class="p">[</span><span class="n">i2</span><span class="p">].</span><span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec2</span> <span class="n">uv</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">uv0</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">uv1</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">uv2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 插值计算出平滑的顶点法线。</span>
</span></span><span class="line"><span class="cl">        <span class="n">float_array_type</span> <span class="n">normals_buffer</span> <span class="o">=</span> <span class="n">float_array_type</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">normals_buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">n0</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="n">normals_buffer</span><span class="p">[</span><span class="n">i0</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mo">0</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">normals_buffer</span><span class="p">[</span><span class="n">i0</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">normals_buffer</span><span class="p">[</span><span class="n">i0</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">].</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">n1</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="n">normals_buffer</span><span class="p">[</span><span class="n">i1</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mo">0</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">normals_buffer</span><span class="p">[</span><span class="n">i1</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">normals_buffer</span><span class="p">[</span><span class="n">i1</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">].</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">n2</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="n">normals_buffer</span><span class="p">[</span><span class="n">i2</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mo">0</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">normals_buffer</span><span class="p">[</span><span class="n">i2</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">normals_buffer</span><span class="p">[</span><span class="n">i2</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">].</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">normal</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">n0</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">n2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 将法线变换到世界空间（注意：法线变换应使用模型矩阵的逆转置矩阵）。</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">mat3</span> <span class="n">normal_transform</span> <span class="o">=</span> <span class="n">mat3</span><span class="p">(</span><span class="n">mesh_instance_draws</span><span class="p">[</span><span class="n">gl_GeometryIndexEXT</span><span class="p">].</span><span class="n">model_inverse</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">normal_transform</span> <span class="o">*</span> <span class="n">normal</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 步骤 3: 获取表面材质属性 ---</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 使用插值得到的UV坐标采样反照率（Albedo）贴图。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 指定一个较低的LOD层级可以提升性能，因为GI的精度要求不高。</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">albedo</span> <span class="o">=</span> <span class="n">textureLod</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">textures</span><span class="p">.</span><span class="n">x</span><span class="p">)],</span> <span class="n">uv</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 步骤 4: 计算直接光照 ---</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 这里实现了一个简单的 Lambertian 光照模型。</span>
</span></span><span class="line"><span class="cl">        <span class="n">Light</span> <span class="n">light</span> <span class="o">=</span> <span class="n">lights</span><span class="p">[</span><span class="mo">0</span><span class="p">];</span> <span class="c1">// 假设场景中至少有一个光源。</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="k">vec3</span> <span class="n">position_to_light</span> <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">world_position</span> <span class="o">-</span> <span class="n">world_position</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="k">vec3</span> <span class="n">l</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">position_to_light</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="k">float</span> <span class="n">NoL</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 计算光照衰减。</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="n">attenuation_square_falloff</span><span class="p">(</span><span class="n">position_to_light</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">/</span> <span class="n">light</span><span class="p">.</span><span class="n">radius</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 组合光照贡献。</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">light_intensity</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">attenuation</span> <span class="o">&gt;</span> <span class="mf">0.001</span><span class="n">f</span> <span class="o">&amp;&amp;</span> <span class="n">NoL</span> <span class="o">&gt;</span> <span class="mf">0.001</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">light_intensity</span> <span class="o">+=</span> <span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">intensity</span> <span class="o">*</span> <span class="n">attenuation</span> <span class="o">*</span> <span class="n">NoL</span><span class="p">)</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="n">albedo</span> <span class="o">*</span> <span class="n">light_intensity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 步骤 5: (可选) 计算间接光照（多轮反弹） ---</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 这是DDGI实现无限反弹效果的核心。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 通过采样周围的探针数据来近似当前点的间接光照。</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">use_infinite_bounces</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">diffuse</span> <span class="o">+=</span> <span class="n">albedo</span> <span class="o">*</span> <span class="n">sample_irradiance</span><span class="p">(</span><span class="n">world_position</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">camera_position</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">*</span> <span class="n">infinite_bounces_multiplier</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 步骤 6: 为正面命中设置最终输出 ---</span>
</span></span><span class="line"><span class="cl">        <span class="n">radiance</span> <span class="o">=</span> <span class="n">diffuse</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">distance</span> <span class="o">=</span> <span class="n">gl_RayTminEXT</span> <span class="o">+</span> <span class="n">gl_HitTEXT</span><span class="p">;</span> <span class="c1">// 距离是正值。</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 最终步骤: 将结果写回光线负载 (Payload) ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 无论命中正面还是背面，都将计算出的 radiance 和 distance 返回。</span>
</span></span><span class="line"><span class="cl">    <span class="n">payload</span><span class="p">.</span><span class="n">radiance</span> <span class="o">=</span> <span class="n">radiance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">payload</span><span class="p">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="miss-shader-未命中着色器">
<a class="header-anchor" href="#miss-shader-%e6%9c%aa%e5%91%bd%e4%b8%ad%e7%9d%80%e8%89%b2%e5%99%a8"></a>
Miss Shader (未命中着色器)
</h3><p>如果光线没有击中任何场景几何体，则执行此着色器。它通常用于返回一个背景色，例如天空盒的颜色，并将距离设为一个极大值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span> <span class="n">location</span> <span class="o">=</span> <span class="mo">0</span> <span class="p">)</span> <span class="n">rayPayloadInEXT</span> <span class="n">RayPayload</span> <span class="n">payload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 返回天空颜色作为辐射度</span>
</span></span><span class="line"><span class="cl">    <span class="n">payload</span><span class="p">.</span><span class="n">radiance</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">0.529</span><span class="p">,</span> <span class="mf">0.807</span><span class="p">,</span> <span class="mf">0.921</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置一个非常大的距离值，表示光线射向了无穷远</span>
</span></span><span class="line"><span class="cl">    <span class="n">payload</span><span class="p">.</span><span class="n">distance</span> <span class="o">=</span> <span class="mf">1000.0</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="核心辅助函数-core-helper-functions">
<a class="header-anchor" href="#%e6%a0%b8%e5%bf%83%e8%be%85%e5%8a%a9%e5%87%bd%e6%95%b0-core-helper-functions"></a>
核心辅助函数 (Core Helper Functions)
</h2><p>这些辅助函数是DDGI（动态漫反射全局光照）系统的基石，负责处理从采样方向生成、矢量编码到坐标系转换等各种关键任务。理解这些函数有助于深入掌握DDGI的内部工作机制。</p>
<h3 id="球面斐波那契采样-spherical-fibonacci-sampling">
<a class="header-anchor" href="#%e7%90%83%e9%9d%a2%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e9%87%87%e6%a0%b7-spherical-fibonacci-sampling"></a>
球面斐波那契采样 (Spherical Fibonacci Sampling)
</h3><p>在为每个探针采集光照信息时，我们需要从探针位置向周围发射大量光线。为了用最少的光线数量高效地覆盖所有方向，我们需要一个能在球面上生成均匀分布点的算法。球面斐波那契（或称黄金螺旋）就是一种优秀的解决方案。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 使用球面斐波那契算法在单位球面上生成一个均匀分布的3D方向向量。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param i 当前样本的索引，范围 [0, n-1]。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param n 总样本数。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 一个标准化的3D方向向量。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">vec3</span> <span class="n">spherical_fibonacci</span><span class="p">(</span><span class="k">float</span> <span class="n">i</span><span class="p">,</span> <span class="k">float</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 黄金比例常数，是构造斐波那契晶格的核心。</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">float</span> <span class="n">PHI</span> <span class="o">=</span> <span class="mf">1.61803398875</span><span class="n">f</span><span class="p">;</span> <span class="c1">// (sqrt(5.0) + 1.0) / 2.0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算垂直分量（z轴），确保点在z轴上均匀分布。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// (2.0 * i + 1.0) / n 会生成从 1/n 到 (2n-1)/n 的序列。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1.0 - ... 将其映射到 [-1 + 1/n, 1 - 1/n] 的范围。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">cos_theta</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">-</span> <span class="p">(</span><span class="mf">2.0</span><span class="n">f</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">sin_theta</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">clamp</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span> <span class="o">-</span> <span class="n">cos_theta</span> <span class="o">*</span> <span class="n">cos_theta</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算水平角度 phi，使用黄金比例的小数部分来确保每个点的旋转角度都有最大程度的无理性和不重复性，</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 从而避免产生摩尔纹或排列成线的瑕疵。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">phi</span> <span class="o">=</span> <span class="mf">2.0</span><span class="n">f</span> <span class="o">*</span> <span class="n">PI</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">PHI</span> <span class="o">-</span> <span class="n">floor</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">PHI</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 从球坐标转换为笛卡尔坐标。</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">vec3</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin_theta</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin_theta</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="n">cos_theta</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>该函数是蒙特卡洛积分在渲染中应用的一个实例。与简单的随机采样或经纬度采样（会在两极产生点堆积）相比，球面斐波那契采样是一种<strong>低差异序列</strong>，它能以确定性的方式生成分布极为均匀的样本点，从而在相同的样本数下获得更平滑、噪点更少的积分结果。</p>
<h3 id="八面体映射-octahedral-mapping">
<a class="header-anchor" href="#%e5%85%ab%e9%9d%a2%e4%bd%93%e6%98%a0%e5%b0%84-octahedral-mapping"></a>
八面体映射 (Octahedral Mapping)
</h3><p>为了将探针采集到的360度环境光信息存储到一张2D纹理中，我们需要一种高效的映射方法，将3D单位方向向量编码（Encode）为2D坐标，然后再解码（Decode）回来。八面体映射就是一种在性能和精度之间取得优秀平衡的常用技术。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// 编码：将3D单位向量投影到一个八面体上，然后展开成一个2D正方形([-1,1])。</span>
</span></span><span class="line"><span class="cl"><span class="k">vec2</span> <span class="n">oct_encode</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将向量投影到z=0的平面，通过L1范数进行归一化。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">l1norm</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">result</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">l1norm</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果向量在下半球 (v.z &lt; 0)，则需要进行一次“翻折”操作，</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将下半球的八面体表面映射到2D正方形的外部区域。</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">z</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">abs</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">yx</span><span class="p">))</span> <span class="o">*</span> <span class="n">sign_not_zero</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 解码：将2D八面体坐标转换回3D单位向量。</span>
</span></span><span class="line"><span class="cl"><span class="k">vec3</span> <span class="n">oct_decode</span><span class="p">(</span><span class="k">vec2</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 首先重构出上半球的向量。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">v</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">abs</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">abs</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果z分量为负，说明原始向量来自下半球，需要执行与编码相反的翻折操作。</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">z</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">v</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">yx</span><span class="p">))</span> <span class="o">*</span> <span class="n">sign_not_zero</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 最后，将向量归一化以确保它是单位长度。</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">normalize</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 辅助函数：返回一个数的符号，但0被视为正。</span>
</span></span><span class="line"><span class="cl"><span class="k">float</span> <span class="n">sign_not_zero</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">?</span> <span class="mf">1.0</span> <span class="o">:</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>八面体映射通过将单位球体投影到一个紧密包围它的八面体上，再将八面体展开成一个2D正方形来实现。相比于立方体贴图（Cubemap），它没有接缝问题，且所有数据都存储在一张连续的2D纹理中，有利于利用硬件的双线性插值和Mipmapping。这种编码方式在存储方向性数据（如法线、光照方向等）时非常高效。</p>
<h3 id="探针网格与世界空间变换">
<a class="header-anchor" href="#%e6%8e%a2%e9%92%88%e7%bd%91%e6%a0%bc%e4%b8%8e%e4%b8%96%e7%95%8c%e7%a9%ba%e9%97%b4%e5%8f%98%e6%8d%a2"></a>
探针网格与世界空间变换
</h3><p>DDGI的核心是在3D空间中维护一个规则的探针网格。因此，我们需要一系列函数来在这几种坐标系之间进行转换：</p>
<ul>
<li><strong>1D 探针索引</strong>: 在缓冲区或循环中使用的线性索引。</li>
<li><strong>3D 网格坐标</strong>: 探针在网格中的整数坐标 <code>(x, y, z)</code>。</li>
<li><strong>3D 世界坐标</strong>: 探针在游戏世界中的实际浮点数位置。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 将一维的探针线性索引转换为三维的网格坐标。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">ivec3</span> <span class="n">probe_index_to_grid_indices</span><span class="p">(</span><span class="k">int</span> <span class="n">probe_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">int</span> <span class="n">probe_x</span> <span class="o">=</span> <span class="n">probe_index</span> <span class="o">%</span> <span class="n">probe_counts</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">int</span> <span class="n">probe_counts_xy</span> <span class="o">=</span> <span class="n">probe_counts</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">probe_counts</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">int</span> <span class="n">probe_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">probe_index</span> <span class="o">%</span> <span class="n">probe_counts_xy</span><span class="p">)</span> <span class="o">/</span> <span class="n">probe_counts</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">int</span> <span class="n">probe_z</span> <span class="o">=</span> <span class="n">probe_index</span> <span class="o">/</span> <span class="n">probe_counts_xy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">ivec3</span><span class="p">(</span><span class="n">probe_x</span><span class="p">,</span> <span class="n">probe_y</span><span class="p">,</span> <span class="n">probe_z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 将三维的网格坐标转换回一维的线性索引。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">int</span> <span class="n">probe_indices_to_index</span><span class="p">(</span><span class="k">in</span> <span class="k">ivec3</span> <span class="n">probe_coords</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">int</span><span class="p">(</span><span class="n">probe_coords</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">probe_coords</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">probe_counts</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">probe_coords</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">probe_counts</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">probe_counts</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 将三维的网格坐标转换为世界坐标，可选地应用一个偏移量。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 这个偏移量是DDGI的一个重要特性，允许探针从其规则的网格位置移动，以更好地贴合场景几何体，减少漏光。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">vec3</span> <span class="n">grid_indices_to_world</span><span class="p">(</span><span class="k">ivec3</span> <span class="n">grid_indices</span><span class="p">,</span> <span class="k">int</span> <span class="n">probe_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算基础的世界坐标</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">base_world_pos</span> <span class="o">=</span> <span class="n">grid_indices</span> <span class="o">*</span> <span class="n">probe_spacing</span> <span class="o">+</span> <span class="n">probe_grid_position</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 从纹理中获取预计算的探针偏移量</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">probe_offset</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">use_probe_offsetting</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="k">int</span> <span class="n">probe_counts_xy</span> <span class="o">=</span> <span class="n">probe_counts</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">probe_counts</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">ivec2</span> <span class="n">offset_coord</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">probe_index</span> <span class="o">%</span> <span class="n">probe_counts_xy</span><span class="p">,</span> <span class="n">probe_index</span> <span class="o">/</span> <span class="n">probe_counts_xy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">probe_offset</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">probe_offset_texture_index</span><span class="p">)],</span> <span class="n">offset_coord</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">base_world_pos</span> <span class="o">+</span> <span class="n">probe_offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 将世界坐标转换为其所在的探针网格的三维坐标。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">ivec3</span> <span class="n">world_to_grid_indices</span><span class="p">(</span><span class="k">vec3</span> <span class="n">world_position</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">grid_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">world_position</span> <span class="o">-</span> <span class="n">probe_grid_position</span><span class="p">)</span> <span class="o">*</span> <span class="n">reciprocal_probe_spacing</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">clamp</span><span class="p">(</span><span class="k">ivec3</span><span class="p">(</span><span class="n">grid_pos</span><span class="p">),</span> <span class="k">ivec3</span><span class="p">(</span><span class="mo">0</span><span class="p">),</span> <span class="n">probe_counts</span> <span class="o">-</span> <span class="k">ivec3</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="探针图集坐标计算-probe-atlas-coordinates">
<a class="header-anchor" href="#%e6%8e%a2%e9%92%88%e5%9b%be%e9%9b%86%e5%9d%90%e6%a0%87%e8%ae%a1%e7%ae%97-probe-atlas-coordinates"></a>
探针图集坐标计算 (Probe Atlas Coordinates)
</h3><p>为了高效渲染，所有探针的环境光数据（通常是经过八面体编码的2D图像）都被存储在一张巨大的 <strong>纹理图集（Texture Atlas）</strong> 中。每个探针占据图集中的一小块正方形区域，周围通常有1像素的边界（Border）以防止在纹理采样时发生数据“渗漏”。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 根据3D方向和探针索引，计算出在整个探针图集纹理中对应的UV坐标。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">vec2</span> <span class="n">get_probe_uv</span><span class="p">(</span><span class="k">vec3</span> <span class="n">direction</span><span class="p">,</span> <span class="k">int</span> <span class="n">probe_index</span><span class="p">,</span> <span class="k">int</span> <span class="n">full_texture_width</span><span class="p">,</span> <span class="k">int</span> <span class="n">full_texture_height</span><span class="p">,</span> <span class="k">int</span> <span class="n">probe_side_length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 将3D方向编码为[-1, 1]范围的2D八面体坐标。</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">vec2</span> <span class="n">octahedral_coordinates</span> <span class="o">=</span> <span class="n">oct_encode</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">direction</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">float</span> <span class="n">probe_with_border_side</span> <span class="o">=</span> <span class="k">float</span><span class="p">(</span><span class="n">probe_side_length</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.0</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">int</span> <span class="n">probes_per_row</span> <span class="o">=</span> <span class="n">full_texture_width</span> <span class="o">/</span> <span class="k">int</span><span class="p">(</span><span class="n">probe_with_border_side</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 计算当前探针在图集中的网格索引 (0,0), (1,0), ...</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec2</span> <span class="n">probe_indices</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">probe_index</span> <span class="o">%</span> <span class="n">probes_per_row</span><span class="p">,</span> <span class="n">probe_index</span> <span class="o">/</span> <span class="n">probes_per_row</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 计算该探针区域左上角的像素坐标。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">atlas_texels</span> <span class="o">=</span> <span class="k">vec2</span><span class="p">(</span><span class="n">probe_indices</span><span class="p">)</span> <span class="o">*</span> <span class="n">probe_with_border_side</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 4. 加上1像素的边界，进入探针的有效数据区域。</span>
</span></span><span class="line"><span class="cl">    <span class="n">atlas_texels</span> <span class="o">+=</span> <span class="k">vec2</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 5. 移动到探针区域的中心。</span>
</span></span><span class="line"><span class="cl">    <span class="n">atlas_texels</span> <span class="o">+=</span> <span class="k">vec2</span><span class="p">(</span><span class="n">probe_side_length</span> <span class="o">*</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 6. 使用八面体坐标在探针区域内部进行偏移。</span>
</span></span><span class="line"><span class="cl">    <span class="n">atlas_texels</span> <span class="o">+=</span> <span class="n">octahedral_coordinates</span> <span class="o">*</span> <span class="p">(</span><span class="n">probe_side_length</span> <span class="o">*</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 7. 将最终的像素坐标归一化为[0, 1]范围的UV坐标。</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">atlas_texels</span> <span class="o">/</span> <span class="k">vec2</span><span class="p">(</span><span class="k">float</span><span class="p">(</span><span class="n">full_texture_width</span><span class="p">),</span> <span class="k">float</span><span class="p">(</span><span class="n">full_texture_height</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="更新辐照度与可见性-update-irradiance-and-visibility">
<a class="header-anchor" href="#%e6%9b%b4%e6%96%b0%e8%be%90%e7%85%a7%e5%ba%a6%e4%b8%8e%e5%8f%af%e8%a7%81%e6%80%a7-update-irradiance-and-visibility"></a>
更新辐照度与可见性 (Update Irradiance and Visibility)
</h2><p>在“辐射度采集”阶段之后，我们得到了每个探针从数百个方向射出的光线的原始数据（颜色和距离）。这个原始数据是离散且充满噪声的。本阶段的目标就是将这些离散的射线数据，通过滤波和积分，转换成两张最终可供场景采样、平滑且稳定的<strong>探针图集（Probe Atlas）</strong>：</p>
<ol>
<li>
<p><strong>辐照度图集 (Irradiance Atlas)</strong>: 存储每个探针从各个方向接收到的颜色信息。
<img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507201311676.png" alt=""></p>
</li>
<li>
<p><strong>可见性图集 (Visibility Atlas)</strong>: 存储每个探针在各个方向上的平均距离和距离的平方，用于后续计算柔和阴影。
<img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507201312903.png" alt=""></p>
</li>
</ol>
<h3 id="cpu端调度">
<a class="header-anchor" href="#cpu%e7%ab%af%e8%b0%83%e5%ba%a6"></a>
CPU端调度
</h3><p>在CPU侧，我们分别调用两个独立的计算管线，它们使用相同的输入数据但执行不同的计算，最终写入各自的目标图集纹理。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">i32</span> <span class="n">irradiance_probe_size</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">i32</span> <span class="n">octahedral_irradiance_size</span> <span class="o">=</span> <span class="n">irradiance_probe_size</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">irradiance_atlas_width</span> <span class="o">=</span> <span class="p">(</span><span class="n">octahedral_irradiance_size</span> <span class="o">*</span> <span class="n">probe_count_x</span> <span class="o">*</span> <span class="n">probe_count_y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">irradiance_atlas_height</span> <span class="o">=</span> <span class="p">(</span><span class="n">octahedral_irradiance_size</span> <span class="o">*</span> <span class="n">probe_count_z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// --- 1. 更新辐照度图集 ---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ... 绑定计算管线和资源 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">dispatch</span><span class="p">(</span><span class="n">hydra</span><span class="o">::</span><span class="n">ceilu32</span><span class="p">(</span><span class="n">irradiance_atlas_width</span> <span class="o">/</span> <span class="mf">8.f</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                       <span class="n">hydra</span><span class="o">::</span><span class="n">ceilu32</span><span class="p">(</span><span class="n">irradiance_atlas_height</span> <span class="o">/</span> <span class="mf">8.f</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// --- 2. 更新可见性图集 ---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ... 绑定计算管线和资源 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 启动计算着色器，覆盖整个可见性图集纹理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">dispatch</span><span class="p">(</span><span class="n">hydra</span><span class="o">::</span><span class="n">ceilu32</span><span class="p">(</span><span class="n">visibility_atlas_width</span> <span class="o">/</span> <span class="mf">8.f</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                       <span class="n">hydra</span><span class="o">::</span><span class="n">ceilu32</span><span class="p">(</span><span class="n">visibility_atlas_height</span> <span class="o">/</span> <span class="mf">8.f</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></div><h3 id="计算着色器详解">
<a class="header-anchor" href="#%e8%ae%a1%e7%ae%97%e7%9d%80%e8%89%b2%e5%99%a8%e8%af%a6%e8%a7%a3"></a>
计算着色器详解
</h3><p>以下是核心的计算着色器代码。它通过预处理器宏 (<code>#if defined</code>) 来区分是计算辐照度还是可见性，但核心逻辑是共享的。代码主要分为两个部分：<strong>核心计算</strong>（针对探针内部像素）和<strong>边界处理</strong>（针对探针边缘像素）。</p>
<h4 id="核心计算探针内部像素">
<a class="header-anchor" href="#%e6%a0%b8%e5%bf%83%e8%ae%a1%e7%ae%97%e6%8e%a2%e9%92%88%e5%86%85%e9%83%a8%e5%83%8f%e7%b4%a0"></a>
核心计算（探针内部像素）
</h4><p>这部分代码对探针图集内每个有效的像素进行计算。每个像素代表探针所看到的一个特定方向。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// 该着色器在一个 8x8 的线程组中执行</span>
</span></span><span class="line"><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec3</span> <span class="n">coords</span> <span class="o">=</span> <span class="k">ivec3</span><span class="p">(</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 省略变量初始化和边界检查 ...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 通过像素坐标反算出当前线程正在为哪个探针工作</span>
</span></span><span class="line"><span class="cl">    <span class="k">int</span> <span class="n">probe_index</span> <span class="o">=</span> <span class="n">get_probe_index_from_pixels</span><span class="p">(</span><span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="p">...);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 步骤1: 区分内部像素与边界像素 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 探针在图集中有1像素的边界，边界像素有特殊处理。</span>
</span></span><span class="line"><span class="cl">    <span class="k">bool</span> <span class="n">border_pixel</span> <span class="o">=</span> <span class="p">((</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">x</span> <span class="o">%</span> <span class="n">probe_with_border_side</span><span class="p">)</span> <span class="o">==</span> <span class="mo">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">...</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">border_pixel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 步骤2: 对所有射线进行加权积分 ---</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec4</span> <span class="n">result</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">uint</span> <span class="n">backfaces</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="c1">// 用于统计击中背面的射线数量</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 循环遍历该探针在上一阶段发射的所有射线</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">ray_index</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="n">ray_index</span> <span class="o">&lt;</span> <span class="n">probe_rays</span><span class="p">;</span> <span class="o">++</span><span class="n">ray_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 获取原始射线数据（辐射度和距离）</span>
</span></span><span class="line"><span class="cl">            <span class="k">ivec2</span> <span class="n">sample_position</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">ray_index</span><span class="p">,</span> <span class="n">probe_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec4</span> <span class="n">raw_data</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">radiance_output_index</span><span class="p">)],</span> <span class="n">sample_position</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// a. 处理背面击中：如果距离为负，说明探针可能在几何体内，跳过此射线。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//    如果背面射线过多，则认为此探针完全被遮挡，提前退出，结果为黑色。</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">raw_data</span><span class="p">.</span><span class="n">w</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="n">f</span> <span class="o">&amp;&amp;</span> <span class="n">use_backfacing_blending</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">backfaces</span> <span class="o">&gt;=</span> <span class="n">max_backfaces</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// b. 计算权重：这是积分的核心。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//    - texel_direction: 当前像素所代表的出射方向。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//    - ray_direction:   当前循环中处理的原始射线的方向。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//    - weight:          二者点积，即两个方向夹角的余弦值。</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">ray_direction</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">random_rotation</span><span class="p">)</span> <span class="o">*</span> <span class="n">spherical_fibonacci</span><span class="p">(</span><span class="n">ray_index</span><span class="p">,</span> <span class="n">probe_rays</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">texel_direction</span> <span class="o">=</span> <span class="n">oct_decode</span><span class="p">(</span><span class="n">normalized_oct_coord</span><span class="p">(</span><span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">probe_side_length</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">texel_direction</span><span class="p">,</span> <span class="n">ray_direction</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">weight</span> <span class="o">&lt;</span> <span class="mf">0.0001</span><span class="n">f</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// c. 根据模式（辐照度/可见性）累加加权值</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if defined(COMPUTE_PROBE_UPDATE_IRRADIANCE)</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 模式1: 辐照度。累加 (颜色 * 权重)，并将权重本身存入w分量。</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">radiance</span> <span class="o">=</span> <span class="n">raw_data</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="mf">0.95</span><span class="p">;</span> <span class="c1">// 能量守恒</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span> <span class="o">+=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">radiance</span> <span class="o">*</span> <span class="n">weight</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 模式2: 可见性。累加 (距离, 距离^2, 0) * 权重。</span>
</span></span><span class="line"><span class="cl">            <span class="n">weight</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="mf">2.5</span><span class="n">f</span><span class="p">);</span> <span class="c1">// 权重调整</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">raw_data</span><span class="p">.</span><span class="n">w</span><span class="p">),</span> <span class="n">probe_max_ray_distance</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">value</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">distance</span> <span class="o">*</span> <span class="n">distance</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span> <span class="o">+=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">value</span> <span class="o">*</span> <span class="n">weight</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 步骤3: 归一化和时间混合 ---</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// a. 归一化：将累加结果除以总权重，得到加权平均值。</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">w</span> <span class="o">&gt;</span> <span class="mf">0.0001</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span><span class="p">.</span><span class="n">xyz</span> <span class="o">/=</span> <span class="n">result</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// b. 时间滤波：与上一帧的结果进行混合（滞后滤波），以消除闪烁。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//    hysteresis 是一个 [0, 1] 范围的混合因子。</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if defined(COMPUTE_PROBE_UPDATE_IRRADIANCE)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 是否启用感知编码。</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">use_perceptual_encoding</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 对 result.rgb（一个线性的HDR颜色值）执行伽马编码。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// pow(value, exponent) 是一个幂函数。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 这里的指数是 vec3(1.0f / 5.0f)，即对R, G, B三个分量都取0.2次幂。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 这等同于应用一个 gamma = 5.0 的伽马校正。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 其目的是将线性的光照强度非线性地映射到更符合人类视觉感知的空间，</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 以便在低精度（如RGBA8）纹理中存储时，能更有效地利用数据位，</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 减少在暗部区域的色带瑕疵。</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span> <span class="o">/</span> <span class="mf">5.0</span><span class="n">f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec4</span> <span class="n">previous_value</span> <span class="o">=</span> <span class="n">imageLoad</span><span class="p">(</span><span class="n">irradiance_image</span><span class="p">,</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span> <span class="o">=</span> <span class="n">mix</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">previous_value</span><span class="p">,</span> <span class="n">hysteresis</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">imageStore</span><span class="p">(</span><span class="n">irradiance_image</span><span class="p">,</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec2</span> <span class="n">previous_value</span> <span class="o">=</span> <span class="n">imageLoad</span><span class="p">(</span><span class="n">visibility_image</span><span class="p">,</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">rg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span><span class="p">.</span><span class="n">rg</span> <span class="o">=</span> <span class="n">mix</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">rg</span><span class="p">,</span> <span class="n">previous_value</span><span class="p">,</span> <span class="n">hysteresis</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">imageStore</span><span class="p">(</span><span class="n">visibility_image</span><span class="p">,</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="k">vec4</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">rg</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span> <span class="c1">// 内部像素计算完成</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 边界像素处理 ...</span>
</span></span></code></pre></div><ul>
<li><strong>余弦加权积分 (Cosine-Weighted Integration)</strong>: 核心计算是在估算渲染方程中的半球积分。对于一个给定的出射方向（<code>texel_direction</code>），它接收到的光照是所有入射光线（<code>ray_direction</code>）贡献的总和，且每条光线的贡献由其与出射方向夹角的余弦值（<code>dot(...)</code>）进行加权。此过程在物理上模拟了 Lambertian 表面的漫反射。</li>
<li><strong>方差阴影贴图 (Variance Shadow Mapping, VSM)</strong>: 在计算可见性时，我们存储了距离 <code>d</code> 和距离的平方 <code>d^2</code>。通过这两个<strong>矩（Moments）</strong>，可以在后续的光照计算中，快速估算一个像素点是否处于阴影中，并且能以很小的代价实现具有可变半影的柔和阴影效果。</li>
</ul>
<h4 id="边界处理探针边缘像素">
<a class="header-anchor" href="#%e8%be%b9%e7%95%8c%e5%a4%84%e7%90%86%e6%8e%a2%e9%92%88%e8%be%b9%e7%bc%98%e5%83%8f%e7%b4%a0"></a>
边界处理（探针边缘像素）
</h4><p>这部分代码处理图集中每个探针周围的1像素边界。其目的是为了让硬件在对图集进行双线性插值采样时，能够无缝地“环绕”读取数据。</p>
<p><img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507221634938.png" alt="环绕规则"></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl">    <span class="c1">// ... 内部像素计算之后 ...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 步骤4: 同步线程并处理边界像素 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// a. 内存屏障：确保所有内部像素都已计算并写入内存后，</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    才开始进行边界像素的拷贝操作，避免读取到旧数据或未定义数据。</span>
</span></span><span class="line"><span class="cl">    <span class="n">groupMemoryBarrier</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">barrier</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// b. 计算源像素坐标：根据当前边界像素的位置，计算出它应该从探针区域</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    内部的哪个像素拷贝数据（通常是相对的另一侧）。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    例如，顶部边界拷贝底部内容，左侧边界拷贝右侧内容。</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec2</span> <span class="n">source_pixel_coordinate</span> <span class="o">=</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// const int k_read_table[6] = {5, 3, 1, -1, -3, -5};</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">corner_pixel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 角落像素的拷贝逻辑</span>
</span></span><span class="line"><span class="cl">        <span class="n">source_pixel_coordinate</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="p">(</span><span class="n">probe_pixel_x</span> <span class="o">==</span> <span class="mo">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">probe_side_length</span> <span class="o">:</span> <span class="o">-</span><span class="n">probe_side_length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">source_pixel_coordinate</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="p">(</span><span class="n">probe_pixel_y</span> <span class="o">==</span> <span class="mo">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">probe_side_length</span> <span class="o">:</span> <span class="o">-</span><span class="n">probe_side_length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">row_pixel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 水平边界像素的拷贝逻辑</span>
</span></span><span class="line"><span class="cl">        <span class="n">source_pixel_coordinate</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">k_read_table</span><span class="p">[</span><span class="n">probe_pixel_x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">source_pixel_coordinate</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="p">(</span><span class="n">probe_pixel_y</span> <span class="o">&gt;</span> <span class="mo">0</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 垂直边界像素的拷贝逻辑</span>
</span></span><span class="line"><span class="cl">        <span class="n">source_pixel_coordinate</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="p">(</span><span class="n">probe_pixel_x</span> <span class="o">&gt;</span> <span class="mo">0</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">source_pixel_coordinate</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">k_read_table</span><span class="p">[</span><span class="n">probe_pixel_y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// c. 拷贝并写入数据</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if defined(COMPUTE_PROBE_UPDATE_IRRADIANCE)</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">copied_data</span> <span class="o">=</span> <span class="n">imageLoad</span><span class="p">(</span><span class="n">irradiance_image</span><span class="p">,</span> <span class="n">source_pixel_coordinate</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">irradiance_image</span><span class="p">,</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">copied_data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">copied_data</span> <span class="o">=</span> <span class="n">imageLoad</span><span class="p">(</span><span class="n">visibility_image</span><span class="p">,</span> <span class="n">source_pixel_coordinate</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">visibility_image</span><span class="p">,</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">copied_data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li><strong>纹理环绕 (Texture Wrapping)</strong>: 这是处理存储在图集中的球面/八面体贴图的标准做法。通过在数据周围填充一圈“环绕”的边界，可以欺骗GPU的纹理采样器，使其在采样数据边缘时，能够正确地插值到“对面”的像素，从而避免在八面体贴图的<code>[-1, 1]</code>边界处产生接缝或瑕疵。</li>
<li><strong>线程组同步 (Workgroup Synchronization)</strong>: <code>groupMemoryBarrier()</code> 和 <code>barrier()</code> 是在计算着色器中进行线程同步的关键指令。它确保了在一个线程组（Workgroup）内，写操作和读操作的先后顺序，是实现这种“先计算，后拷贝”逻辑的必要条件。</li>
</ul>
<h2 id="采样-irradiance-probes">
<a class="header-anchor" href="#%e9%87%87%e6%a0%b7-irradiance-probes"></a>
采样 Irradiance Probes
</h2><p>这部分代码负责设置渲染管线状态并启动计算着色器。</p>
<p><img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507201712787.png" alt=""></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">sampleIrradianceProbes</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置资源屏障：告诉GPU，我们将要以“无序访问”（写入）的方式使用 indirect_texture
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">issue_texture_barrier</span><span class="p">(</span><span class="n">indirect_texture</span><span class="p">,</span> <span class="n">RESOURCE_STATE_UNORDERED_ACCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 绑定用于采样Irradiance的计算管线
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">bind_pipeline</span><span class="p">(</span><span class="n">sample_irradiance_pipeline</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 绑定描述符集，其中包含了所有需要的纹理资源（深度图、法线图、探针数据等）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">bind_descriptor_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sample_irradiance_descriptor_set</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 通过Push Constants向Shader传递一个标记，告诉它是否启用半分辨率模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">u32</span> <span class="n">half_resolution</span> <span class="o">=</span> <span class="n">render_scene</span><span class="o">-&gt;</span><span class="n">gi_use_half_resolution</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">push_constants</span><span class="p">(</span><span class="n">sample_irradiance_pipeline</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">half_resolution</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算需要启动的线程组数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果启用半分辨率，宽高都减半
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="n">f32</span> <span class="n">resolution_divider</span> <span class="o">=</span> <span class="n">render_scene</span><span class="o">-&gt;</span><span class="n">gi_use_half_resolution</span> <span class="o">?</span> <span class="mf">0.5f</span> <span class="o">:</span> <span class="mf">1.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">u32</span> <span class="n">group_dim_x</span> <span class="o">=</span> <span class="n">hydra</span><span class="o">::</span><span class="n">ceilu32</span><span class="p">(</span><span class="n">renderer</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">*</span> <span class="n">resolution_divider</span> <span class="o">/</span> <span class="mf">8.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">u32</span> <span class="n">group_dim_y</span> <span class="o">=</span> <span class="n">hydra</span><span class="o">::</span><span class="n">ceilu32</span><span class="p">(</span><span class="n">renderer</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">*</span> <span class="n">resolution_divider</span> <span class="o">/</span> <span class="mf">8.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 派发计算任务！这将启动 group_dim_x * group_dim_y * 1 个线程组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 每个线程组包含 8x8x1 = 64 个线程，对应着色器中的 local_size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">dispatch</span><span class="p">(</span><span class="n">group_dim_x</span><span class="p">,</span> <span class="n">group_dim_y</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 再次设置资源屏障：告诉GPU，计算已完成，indirect_texture 现在将作为“像素着色器资源”（读取）使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">issue_texture_barrier</span><span class="p">(</span><span class="n">indirect_texture</span><span class="p">,</span> <span class="n">RESOURCE_STATE_PIXEL_SHADER_RESOURCE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>计算着色器的主要任务是从探针网格中采样间接光照（Irradiance），并将结果存储在一个纹理中。它通过对每个探针周围的多个方向进行采样，来近似计算该点的间接光照。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// =========================================================================</span>
</span></span><span class="line"><span class="cl"><span class="c1">//                       </span>
</span></span><span class="line"><span class="cl"><span class="c1">// 为给定的世界坐标点，通过采样周围的光照探针来计算其间接光照。</span>
</span></span><span class="line"><span class="cl"><span class="c1">//</span>
</span></span><span class="line"><span class="cl"><span class="c1">// @param world_position:    当前像素/着色点的世界坐标</span>
</span></span><span class="line"><span class="cl"><span class="c1">// @param normal:            该点的法线向量</span>
</span></span><span class="line"><span class="cl"><span class="c1">// @param camera_position:   摄像机的世界坐标</span>
</span></span><span class="line"><span class="cl"><span class="c1">// @return:                  计算出的间接光 irradiance</span>
</span></span><span class="line"><span class="cl"><span class="c1">// =========================================================================</span>
</span></span><span class="line"><span class="cl"><span class="k">vec3</span> <span class="n">sample_irradiance</span><span class="p">(</span><span class="k">vec3</span> <span class="n">world_position</span><span class="p">,</span> <span class="k">vec3</span> <span class="n">normal</span><span class="p">,</span> <span class="k">vec3</span> <span class="n">camera_position</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Wo 是从着色点指向摄像机的向量</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">vec3</span> <span class="n">Wo</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">camera_position</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">world_position</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 【关键点1: 表面偏置】</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 为了防止“自阴影”或光照泄漏，将采样点沿着法线和视线方向稍微偏移。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这可以避免在物体表面上直接采样，从而提高稳定性。</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">float</span> <span class="n">minimum_distance_between_probes</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">;</span> <span class="c1">// 探针间的最小距离，用于缩放偏移量</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">bias_vector</span> <span class="o">=</span> <span class="p">(</span><span class="n">normal</span> <span class="o">*</span> <span class="mf">0.2</span><span class="n">f</span> <span class="o">+</span> <span class="n">Wo</span> <span class="o">*</span> <span class="mf">0.8</span><span class="n">f</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.75</span><span class="n">f</span> <span class="o">*</span> <span class="n">minimum_distance_between_probes</span><span class="p">)</span> <span class="o">*</span> <span class="n">self_shadow_bias</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">biased_world_position</span> <span class="o">=</span> <span class="n">world_position</span> <span class="o">+</span> <span class="n">bias_vector</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 探针网格定位与插值准备 ---</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 根据偏移后的世界坐标，找到其所在的探针网格单元的基准索引（单元的最小角）</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec3</span> <span class="n">base_grid_indices</span> <span class="o">=</span> <span class="n">world_to_grid_indices</span><span class="p">(</span><span class="n">biased_world_position</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取该基准探针的世界坐标</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">base_probe_world_position</span> <span class="o">=</span> <span class="n">grid_indices_to_world_no_offsets</span><span class="p">(</span><span class="n">base_grid_indices</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// alpha: 计算采样点在探针网格单元内的相对位置 [0, 1]，用于后续的三线性插值</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">((</span><span class="n">biased_world_position</span> <span class="o">-</span> <span class="n">base_probe_world_position</span><span class="p">),</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">),</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span>  <span class="n">sum_irradiance</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">);</span> <span class="c1">// 加权辐照度总和</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">sum_weight</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>           <span class="c1">// 权重总和</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历环绕采样点的8个探针（形成一个立方体“笼子”）</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 计算当前探针的偏移量 (0或1)，i的二进制位分别代表x,y,z轴的偏移</span>
</span></span><span class="line"><span class="cl">        <span class="k">ivec3</span> <span class="n">offset</span> <span class="o">=</span> <span class="k">ivec3</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="k">ivec3</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 计算探针的网格坐标，并确保它在有效范围内</span>
</span></span><span class="line"><span class="cl">        <span class="k">ivec3</span> <span class="n">probe_grid_coord</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">base_grid_indices</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="k">ivec3</span><span class="p">(</span><span class="mo">0</span><span class="p">),</span> <span class="n">probe_counts</span> <span class="o">-</span> <span class="k">ivec3</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将网格坐标转换为一维索引</span>
</span></span><span class="line"><span class="cl">        <span class="k">int</span> <span class="n">probe_index</span> <span class="o">=</span> <span class="n">probe_indices_to_index</span><span class="p">(</span><span class="n">probe_grid_coord</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取探针的实际世界坐标</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">probe_pos</span> <span class="o">=</span> <span class="n">grid_indices_to_world</span><span class="p">(</span><span class="n">probe_grid_coord</span><span class="p">,</span> <span class="n">probe_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 计算各项权重 ---</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 【关键点2: 方向系数】</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 我们只是使用探针进行插值，因此背面的探针也会考虑。</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">use_smooth_backface</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">direction_to_probe</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">probe_pos</span> <span class="o">-</span> <span class="n">world_position</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 使用 &#34;wrap shading&#34; 的思想，将 dot(dir, n) 从 [-1, 1] 映射到 [0, 1]</span>
</span></span><span class="line"><span class="cl">            <span class="k">const</span> <span class="k">float</span> <span class="n">dir_dot_n</span> <span class="o">=</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">direction_to_probe</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 通过平方和平滑因子，实现一个柔和的权重衰减，避免硬边</span>
</span></span><span class="line"><span class="cl">            <span class="n">weight</span> <span class="o">*=</span> <span class="p">(</span><span class="n">dir_dot_n</span> <span class="o">*</span> <span class="n">dir_dot_n</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 【关键点3: 可见性权重 (VSM + Chebyshev)】</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 检查探针和着色点之间是否存在遮挡物。</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">probe_to_biased_point_direction</span> <span class="o">=</span> <span class="n">biased_world_position</span> <span class="o">-</span> <span class="n">probe_pos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">distance_to_biased_point</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">probe_to_biased_point_direction</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">probe_to_biased_point_direction</span> <span class="o">/=</span> <span class="n">distance_to_biased_point</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">use_visibility</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 从可见性纹理（一个存储深度的纹理图集）中采样</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec2</span> <span class="n">uv</span> <span class="o">=</span> <span class="n">get_probe_uv</span><span class="p">(</span><span class="n">probe_to_biased_point_direction</span><span class="p">,</span> <span class="n">probe_index</span><span class="p">,</span> <span class="n">visibility_texture_width</span><span class="p">,</span> <span class="n">visibility_texture_height</span><span class="p">,</span> <span class="n">visibility_side_length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// .rg 通道存储了深度的均值(E[d])和平方均值(E[d^2])</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec2</span> <span class="n">visibility</span> <span class="o">=</span> <span class="n">textureLod</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">grid_visibility_texture_index</span><span class="p">)],</span> <span class="n">uv</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">rg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">mean_distance_to_occluder</span> <span class="o">=</span> <span class="n">visibility</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="c1">// 均值 μ</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">chebyshev_weight</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span> <span class="c1">// 默认完全可见</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果着色点比平均遮挡物更远，则可能被遮挡</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">distance_to_biased_point</span> <span class="o">&gt;</span> <span class="n">mean_distance_to_occluder</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 计算方差 σ^2 = E[d^2] - (E[d])^2</span>
</span></span><span class="line"><span class="cl">                <span class="k">float</span> <span class="n">variance</span> <span class="o">=</span> <span class="n">abs</span><span class="p">((</span><span class="n">visibility</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">visibility</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">visibility</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">const</span> <span class="k">float</span> <span class="n">distance_diff</span> <span class="o">=</span> <span class="n">distance_to_biased_point</span> <span class="o">-</span> <span class="n">mean_distance_to_occluder</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 应用切比雪夫不等式计算光照透过率（即权重）</span>
</span></span><span class="line"><span class="cl">                <span class="n">chebyshev_weight</span> <span class="o">=</span> <span class="n">variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">variance</span> <span class="o">+</span> <span class="p">(</span><span class="n">distance_diff</span> <span class="o">*</span> <span class="n">distance_diff</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 增强对比度，使阴影更明显</span>
</span></span><span class="line"><span class="cl">                <span class="n">chebyshev_weight</span> <span class="o">=</span> <span class="n">max</span><span class="p">((</span><span class="n">chebyshev_weight</span> <span class="o">*</span> <span class="n">chebyshev_weight</span> <span class="o">*</span> <span class="n">chebyshev_weight</span><span class="p">),</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 保证权重不完全为0，避免在全黑区域出现问题</span>
</span></span><span class="line"><span class="cl">            <span class="n">weight</span> <span class="o">*=</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.05</span><span class="n">f</span><span class="p">,</span> <span class="n">chebyshev_weight</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 采样与混合 ---</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 【关键点4: 三线性插值权重】</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 根据之前计算的alpha值，计算当前探针的三线性插值权重。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// mix(1-a, a, offset) 是一个简洁的实现方式。</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">trilinear</span> <span class="o">=</span> <span class="n">mix</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="k">vec3</span><span class="p">(</span><span class="n">offset</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">weight</span> <span class="o">*=</span> <span class="n">trilinear</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">trilinear</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">trilinear</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="mf">0.001</span><span class="n">f</span><span class="p">;</span> <span class="c1">// +0.001f 避免权重为0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 采样预计算好的Irradiance纹理图集</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec2</span> <span class="n">uv</span> <span class="o">=</span> <span class="n">get_probe_uv</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">probe_index</span><span class="p">,</span> <span class="n">irradiance_texture_width</span><span class="p">,</span> <span class="n">irradiance_texture_height</span><span class="p">,</span> <span class="n">irradiance_side_length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">probe_irradiance</span> <span class="o">=</span> <span class="n">textureLod</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">grid_irradiance_output_index</span><span class="p">)],</span> <span class="n">uv</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果使用了感知编码，需要解码</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">use_perceptual_encoding</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">probe_irradiance</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">probe_irradiance</span><span class="p">,</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">0.5</span><span class="n">f</span> <span class="o">*</span> <span class="mf">5.0</span><span class="n">f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 累加加权后的irradiance和总权重</span>
</span></span><span class="line"><span class="cl">        <span class="n">sum_irradiance</span> <span class="o">+=</span> <span class="n">weight</span> <span class="o">*</span> <span class="n">probe_irradiance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">sum_weight</span> <span class="o">+=</span> <span class="n">weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- Finalize ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 通过总权重进行归一化，得到最终混合后的irradiance</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">net_irradiance</span> <span class="o">=</span> <span class="n">sum_irradiance</span> <span class="o">/</span> <span class="n">sum_weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果使用了感知编码，需要重新编码</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">use_perceptual_encoding</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">net_irradiance</span> <span class="o">=</span> <span class="n">net_irradiance</span> <span class="o">*</span> <span class="n">net_irradiance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 最后乘以 PI 和一个缩放因子，这是漫反射BRDF积分的一部分</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">irradiance</span> <span class="o">=</span> <span class="mf">0.5</span><span class="n">f</span> <span class="o">*</span> <span class="n">PI</span> <span class="o">*</span> <span class="n">net_irradiance</span> <span class="o">*</span> <span class="mf">0.95</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">irradiance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取当前线程处理的像素坐标</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec3</span> <span class="n">coords</span> <span class="o">=</span> <span class="k">ivec3</span><span class="p">(</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 半分辨率优化处理 ---</span>
</span></span><span class="line"><span class="cl">    <span class="k">int</span> <span class="n">resolution_divider</span> <span class="o">=</span> <span class="n">output_resolution_half</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">screen_uv</span> <span class="o">=</span> <span class="n">uv_nearest</span><span class="p">(</span><span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">resolution</span> <span class="o">/</span> <span class="n">resolution_divider</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">raw_depth</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">int</span> <span class="n">chosen_hiresolution_sample_index</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果启用半分辨率模式，从高分辨率深度图中采样4个点，选择最靠近摄像机的那个</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这是为了在升采样时，保留边缘（深度不连续处）的正确信息</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">output_resolution_half</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">ivec2</span> <span class="n">pixel_offsets</span><span class="p">[]</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">[](</span><span class="k">ivec2</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span><span class="mo">0</span><span class="p">),</span> <span class="k">ivec2</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="k">ivec2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mo">0</span><span class="p">),</span> <span class="k">ivec2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">closer_depth</span> <span class="o">=</span> <span class="mf">1.</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">depth_fullscreen_texture_index</span><span class="p">)],</span> <span class="p">(</span><span class="n">coords</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">pixel_offsets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mo">0</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">closer_depth</span> <span class="o">&gt;</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">closer_depth</span> <span class="o">=</span> <span class="n">depth</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">chosen_hiresolution_sample_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">raw_depth</span> <span class="o">=</span> <span class="n">closer_depth</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 全分辨率模式，直接采样</span>
</span></span><span class="line"><span class="cl">        <span class="n">raw_depth</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">depth_fullscreen_texture_index</span><span class="p">)],</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果深度为1.0，说明是天空盒，直接输出黑色</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">raw_depth</span> <span class="o">==</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">imageStore</span><span class="p">(</span><span class="n">global_images_2d</span><span class="p">[</span><span class="n">indirect_output_index</span><span class="p">],</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="k">vec4</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 重建表面属性 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 根据深度值重建世界坐标</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">vec3</span> <span class="n">pixel_world_position</span> <span class="o">=</span> <span class="n">world_position_from_depth</span><span class="p">(</span><span class="n">screen_uv</span><span class="p">,</span> <span class="n">raw_depth</span><span class="p">,</span> <span class="n">inverse_view_projection</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取对应像素的法线</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">normal</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">output_resolution_half</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 半分辨率模式下，使用之前选定的高分辨率样本的法线</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec2</span> <span class="n">encoded_normal</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">normal_texture_index</span><span class="p">)],</span> <span class="p">(</span><span class="n">coords</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">pixel_offsets</span><span class="p">[</span><span class="n">chosen_hiresolution_sample_index</span><span class="p">],</span> <span class="mo">0</span><span class="p">).</span><span class="n">rg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">octahedral_decode</span><span class="p">(</span><span class="n">encoded_normal</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec2</span> <span class="n">encoded_normal</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">normal_texture_index</span><span class="p">)],</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">rg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">normal</span> <span class="o">=</span> <span class="n">octahedral_decode</span><span class="p">(</span><span class="n">encoded_normal</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 调用核心函数计算并输出 ---</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">irradiance</span> <span class="o">=</span> <span class="n">sample_irradiance</span><span class="p">(</span><span class="n">pixel_world_position</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">camera_position</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">global_images_2d</span><span class="p">[</span><span class="n">indirect_output_index</span><span class="p">],</span> <span class="n">coords</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="k">vec4</span><span class="p">(</span><span class="n">irradiance</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>动态漫反射全局光照（DDGI） 的核心思想是在场景中放置一个规则的探针网格（Probe Grid）。每个探针会预先计算并存储两样东西：</p>
<ol>
<li>环境光照（Irradiance）: 从各个方向到达该点的光照总量，通常存为一个低阶球谐函数或直接存为八面体贴图（Octahedral Map）。</li>
<li>可见性/深度（Visibility/Depth）: 从探针位置向周围发射光线，记录遇到的第一个物体的平均距离和距离的方差。这本质上是为每个探针生成一张360度的深度图。</li>
</ol>
<p>本代码片段执行的是渲染循环中的采样阶段：屏幕上的每个像素根据自己的位置，智能地混合周围探针预计算好的信息，来得到最终的间接光照。</p>
<h3 id="三线性插值-trilinear-interpolation">
<a class="header-anchor" href="#%e4%b8%89%e7%ba%bf%e6%80%a7%e6%8f%92%e5%80%bc-trilinear-interpolation"></a>
三线性插值 (Trilinear Interpolation)
</h3><p>当一个着色点位于8个探针组成的立方体单元内部时，为了实现平滑的过渡，而不是在跨越探针边界时发生光照跳变，我们使用三线性插值。</p>
<ul>
<li><strong>原理</strong>: 它是在三维空间中的线性插值。可以看作先在X轴上对4对点进行线性插值，得到4个点；再在Y轴上对这4个点产生的2对点进行线性插值，得到2个点；最后在Z轴上对这2个点进行线性插值，得到最终结果。</li>
<li><strong>代码实现</strong>: 代码中的 <code>vec3 alpha</code> 代表着色点在单元格内沿X, Y, Z轴的相对位置（0到1）。通过 <code>mix(1.0 - alpha, alpha, offset)</code> 和 <code>trilinear.x * trilinear.y * trilinear.z</code> 的组合，巧妙地计算了8个角点（探针）各自的权重。</li>
</ul>
<h3 id="方差阴影贴图-variance-shadow-mapping---vsm">
<a class="header-anchor" href="#%e6%96%b9%e5%b7%ae%e9%98%b4%e5%bd%b1%e8%b4%b4%e5%9b%be-variance-shadow-mapping---vsm"></a>
方差阴影贴图 (Variance Shadow Mapping - VSM)
</h3><p>这是用于实现柔和、高质量阴影的经典技术，这里被用于判断探针与像素点的可见性。</p>
<ul>
<li><strong>原理</strong>: 传统阴影贴图只存储深度值 $d$，比较时会产生硬边和锯齿。VSM 不仅存储深度均值 $E[d] = \mu$ (代码中的 <code>visibility.x</code>)，还存储深度的平方均值 $E[d^2]$ (代码中的 <code>visibility.y</code>)。</li>
<li><strong>优势</strong>: 有了这两个值（称为“矩”，Moments），就可以计算出深度的<strong>方差</strong> $\sigma^2 = E[d^2] - (E[d])^2$。方差描述了深度值的分布情况。如果方差很大，说明在这个方向上遮挡物的深度变化剧烈，阴影就应该更柔和。</li>
</ul>
<h3 id="切比雪夫不等式-chebyshevs-inequality">
<a class="header-anchor" href="#%e5%88%87%e6%af%94%e9%9b%aa%e5%a4%ab%e4%b8%8d%e7%ad%89%e5%bc%8f-chebyshevs-inequality"></a>
切比雪夫不等式 (Chebyshev&rsquo;s Inequality)
</h3><p>这是VSM能够工作的数学基石，它利用均值和方差来估算概率。</p>
$$P(X \ge t) \le \frac{\sigma^2}{\sigma^2 + (t - \mu)^2}$$<p>
其中 $\mu$ 是均值, $\sigma^2$ 是方差。这个公式给出了变量 $X$ 的值大于或等于某个值 $t$ 的概率上限。</p>
<ul>
<li>
<p><strong>在代码中的应用</strong>:</p>
<ul>
<li>$t$ 是 <strong>探针到当前着色点的距离</strong> (<code>distance_to_biased_point</code>)。</li>
<li>$\mu$ 是 <strong>探针在该方向上到平均遮挡物的距离</strong> (<code>mean_distance_to_occluder</code>)。</li>
<li>当 $t > \mu$ 时，我们怀疑点可能被遮挡了。</li>
<li>代码 <code>variance / (variance + (distance_diff * distance_diff))</code> 正是这个不等式的直接应用。它计算出一个介于 [0, 1] 之间的“遮挡概率”或“光线透过率”，作为可见性权重。</li>
</ul>
</li>
</ul>
<h2 id="计算探针的偏移和状态">
<a class="header-anchor" href="#%e8%ae%a1%e7%ae%97%e6%8e%a2%e9%92%88%e7%9a%84%e5%81%8f%e7%a7%bb%e5%92%8c%e7%8a%b6%e6%80%81"></a>
计算探针的偏移和状态
</h2><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">updateProbeOffsetsAndStatus</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 探针偏移计算 ---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这是一个渐进式更新过程，只在需要时（gi_recalculate_offsets为true）启动，并持续数帧（24帧）以达到稳定。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">static</span> <span class="n">i32</span> <span class="n">offsets_calculations_count</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">render_scene</span><span class="o">-&gt;</span><span class="n">gi_recalculate_offsets</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">offsets_calculations_count</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span> <span class="c1">// 重新开始24帧的计算周期
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果仍在计算周期内，则执行偏移计算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">offsets_calculations_count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">--</span><span class="n">offsets_calculations_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 绑定管线和资源，准备写入探针偏移纹理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 向Shader传递一个标记，告知是否为本轮计算的第一帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">u32</span> <span class="n">first_frame</span> <span class="o">=</span> <span class="p">(</span><span class="n">offsets_calculations_count</span> <span class="o">==</span> <span class="mi">23</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">push_constants</span><span class="p">(</span><span class="n">calculate_probe_offset_pipeline</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first_frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 为每个探针启动一个线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">dispatch</span><span class="p">(</span><span class="n">hydra</span><span class="o">::</span><span class="n">ceilu32</span><span class="p">(</span><span class="n">probe_count</span> <span class="o">/</span> <span class="mf">32.f</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 探针状态计算 ---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这个过程通常每帧都运行，以快速响应场景变化。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 绑定管线和资源，准备更新探针状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 为每个探针启动一个线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">dispatch</span><span class="p">(</span><span class="n">hydra</span><span class="o">::</span><span class="n">ceilu32</span><span class="p">(</span><span class="n">probe_count</span> <span class="o">/</span> <span class="mf">32.f</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="更新探针偏移">
<a class="header-anchor" href="#%e6%9b%b4%e6%96%b0%e6%8e%a2%e9%92%88%e5%81%8f%e7%a7%bb"></a>
更新探针偏移
</h3><p>这个Shader的核心目标是：如果探针位置不佳（例如在墙内或离表面太近），就计算一个偏移量将它移动到更好的位置。</p>
<p>Offset纹理的大小为 <code>probe_count_x * probe_count_y, probe_count_z</code>。</p>
<p><img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507201312076.png" alt=""></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// 每个线程负责一个光照探针</span>
</span></span><span class="line"><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">int</span> <span class="n">probe_index</span> <span class="o">=</span> <span class="k">int</span><span class="p">(</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">probe_index</span> <span class="o">&gt;=</span> <span class="n">total_probes</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="c1">// 越界检查</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 1. 分析光线追踪结果 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历该探针的所有预追踪光线，分析命中信息</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 命中信息来自一个前置的光追Pass，其.w分量存储了距离。约定：w &gt; 0 为正面，w &lt; 0 为背面。</span>
</span></span><span class="line"><span class="cl">    <span class="k">int</span> <span class="n">closest_backface_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>      <span class="c1">// 最近的背面光线索引</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">closest_backface_distance</span> <span class="o">=</span> <span class="mf">100000000.</span><span class="n">f</span><span class="p">;</span> <span class="c1">// 最近的背面距离</span>
</span></span><span class="line"><span class="cl">    <span class="k">int</span> <span class="n">closest_frontface_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>     <span class="c1">// 最近的正面光线索引</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">closest_frontface_distance</span> <span class="o">=</span> <span class="mf">100000000.</span><span class="n">f</span><span class="p">;</span> <span class="c1">// 最近的正面距离</span>
</span></span><span class="line"><span class="cl">    <span class="k">int</span> <span class="n">farthest_frontface_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>    <span class="c1">// 最远的正面光线索引</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">farthest_frontface_distance</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="c1">// 最远的正面距离</span>
</span></span><span class="line"><span class="cl">    <span class="k">int</span> <span class="n">backfaces_count</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span>              <span class="c1">// 背面命中总数</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">ray_index</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="n">ray_index</span> <span class="o">&lt;</span> <span class="n">probe_rays</span><span class="p">;</span> <span class="o">++</span><span class="n">ray_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">ivec2</span> <span class="n">ray_tex_coord</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">ray_index</span><span class="p">,</span> <span class="n">probe_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">ray_distance</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">radiance_output_index</span><span class="p">)],</span> <span class="n">ray_tex_coord</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">ray_distance</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 命中背面</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">backfaces_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="o">-</span><span class="n">ray_distance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">closest_backface_distance</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">closest_backface_distance</span> <span class="o">=</span> <span class="n">dist</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">closest_backface_index</span> <span class="o">=</span> <span class="n">ray_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 命中正面</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">ray_distance</span> <span class="o">&lt;</span> <span class="n">closest_frontface_distance</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">closest_frontface_distance</span> <span class="o">=</span> <span class="n">ray_distance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">closest_frontface_index</span> <span class="o">=</span> <span class="n">ray_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">ray_distance</span> <span class="o">&gt;</span> <span class="n">farthest_frontface_distance</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 注意这里是 if 不是 else if</span>
</span></span><span class="line"><span class="cl">                <span class="n">farthest_frontface_distance</span> <span class="o">=</span> <span class="n">ray_distance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">farthest_frontface_index</span> <span class="o">=</span> <span class="n">ray_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 2. 基于启发式规则计算新偏移 ---</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">full_offset</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">10000.</span><span class="n">f</span><span class="p">);</span> <span class="c1">// 初始设为无效值</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">cell_offset_limit</span> <span class="o">=</span> <span class="n">max_probe_offset</span> <span class="o">*</span> <span class="n">probe_spacing</span><span class="p">;</span> <span class="c1">// 偏移不能超出探针单元格太多</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 读取上一帧的偏移量，实现渐进式更新</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">current_offset</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">first_frame</span> <span class="o">==</span> <span class="mo">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ... (从纹理中读取 current_offset.rgb)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 【启发式规则 1: 探针在墙内】</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果超过1/4的光线击中背面，我们认为探针在几何体内。</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">bool</span> <span class="n">inside_geometry</span> <span class="o">=</span> <span class="p">(</span><span class="k">float</span><span class="p">(</span><span class="n">backfaces_count</span><span class="p">)</span> <span class="o">/</span> <span class="k">float</span><span class="p">(</span><span class="n">probe_rays</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">0.25</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">inside_geometry</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">closest_backface_index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 目标：将探针沿“最近的背面”的反方向推出。</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="k">vec3</span> <span class="n">closest_backface_direction</span> <span class="o">=</span> <span class="n">closest_backface_distance</span> <span class="o">*</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">random_rotation</span><span class="p">)</span> <span class="o">*</span> <span class="n">spherical_fibonacci</span><span class="p">(</span><span class="n">closest_backface_index</span><span class="p">,</span> <span class="n">probe_rays</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ... (计算推出的距离因子 direction_scale_factor)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 新偏移 = 当前偏移 - 推出的向量 (减号代表反方向)</span>
</span></span><span class="line"><span class="cl">        <span class="n">full_offset</span> <span class="o">=</span> <span class="n">current_offset</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">closest_backface_direction</span> <span class="o">*</span> <span class="n">direction_scale_factor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 【启发式规则 2: 探针离墙太近】</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">closest_frontface_distance</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 目标：将探针沿“最远的视线方向”移动，即推向更开阔的空间。</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="k">vec3</span> <span class="n">farthest_direction</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mf">0.2</span><span class="n">f</span><span class="p">,</span> <span class="n">farthest_frontface_distance</span><span class="p">)</span> <span class="o">*</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">random_rotation</span><span class="p">)</span> <span class="o">*</span> <span class="n">spherical_fibonacci</span><span class="p">(</span><span class="n">farthest_frontface_index</span><span class="p">,</span> <span class="n">probe_rays</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="k">vec3</span> <span class="n">closest_direction</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">random_rotation</span><span class="p">)</span> <span class="o">*</span> <span class="n">spherical_fibonacci</span><span class="p">(</span><span class="n">closest_frontface_index</span><span class="p">,</span> <span class="n">probe_rays</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果最远和最近方向大致相反（点积小），才进行移动，避免在角落里抖动</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">farthest_direction</span><span class="p">,</span> <span class="n">closest_direction</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">full_offset</span> <span class="o">=</span> <span class="n">current_offset</span><span class="p">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="n">farthest_direction</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 3. 应用并写回新偏移 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 只有当计算出的新偏移在合理范围内时，才更新它</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">all</span><span class="p">(</span><span class="n">lessThan</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">full_offset</span><span class="p">),</span> <span class="n">cell_offset_limit</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">current_offset</span><span class="p">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">full_offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将最终偏移写回纹理</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">global_images_2d</span><span class="p">[</span><span class="n">probe_offset_texture_index</span><span class="p">],</span> <span class="cm">/* ... coords ... */</span><span class="p">,</span> <span class="n">current_offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="更新探针状态">
<a class="header-anchor" href="#%e6%9b%b4%e6%96%b0%e6%8e%a2%e9%92%88%e7%8a%b6%e6%80%81"></a>
更新探针状态
</h3><p>这个Shader的目标是判断每个探针应该是激活状态（参与光照计算）还是关闭状态（在空旷区域或墙内，可以跳过）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// 每个线程负责一个光照探针</span>
</span></span><span class="line"><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">int</span> <span class="n">probe_index</span> <span class="o">=</span> <span class="k">int</span><span class="p">(</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... (越界检查)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 1. 分析光线追踪结果 (与上一个Shader类似) ---</span>
</span></span><span class="line"><span class="cl">    <span class="k">int</span> <span class="n">backfaces_count</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">closest_frontface_distance</span> <span class="o">=</span> <span class="mf">100000000.</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... (省略类似的循环和变量来查找背面命中数和最近正面距离)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">ray_index</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="n">ray_index</span> <span class="o">&lt;</span> <span class="n">probe_rays</span><span class="p">;</span> <span class="o">++</span><span class="n">ray_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 2. 基于启发式规则判断状态 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 读取上一帧的状态</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">probe_status</span><span class="p">[</span><span class="n">probe_index</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 定义一个有效着色范围，如果命中点在此范围内，探针就应该激活</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">outerBounds</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">probe_spacing</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">probe_spacing</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mf">2.0</span><span class="n">f</span> <span class="o">*</span> <span class="n">self_shadow_bias</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 重新检查所有正面命中</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">ray_index</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="n">ray_index</span> <span class="o">&lt;</span> <span class="n">probe_rays</span><span class="p">;</span> <span class="o">++</span><span class="n">ray_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">d_front</span> <span class="o">=</span> <span class="cm">/* ... texelFetch ... */</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">d_front</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">frontFaceDirection</span> <span class="o">=</span> <span class="n">d_front</span> <span class="o">*</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">random_rotation</span><span class="p">)</span> <span class="o">*</span> <span class="n">spherical_fibonacci</span><span class="p">(</span><span class="n">ray_index</span><span class="p">,</span> <span class="n">probe_rays</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 【规则1: 激活】如果任何一个命中点在有效范围内，说明此探针能影响附近表面，激活它。</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">all</span><span class="p">(</span><span class="n">lessThan</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">frontFaceDirection</span><span class="p">),</span> <span class="n">outerBounds</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">flag</span> <span class="o">=</span> <span class="n">PROBE_STATUS_ACTIVE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 【规则2: 关闭】如果探针在墙内，关闭它。</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">closest_backface_index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="k">float</span><span class="p">(</span><span class="n">backfaces_count</span><span class="p">)</span> <span class="o">/</span> <span class="k">float</span><span class="p">(</span><span class="n">probe_rays</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">0.25</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">flag</span> <span class="o">=</span> <span class="n">PROBE_STATUS_OFF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 【规则3: 关闭】如果探针什么正面都没看到（例如在天空或空旷区域），关闭它。</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">closest_frontface_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">flag</span> <span class="o">=</span> <span class="n">PROBE_STATUS_OFF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 【规则4: 激活】如果探针离某个表面非常近，激活它。</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">closest_frontface_distance</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">flag</span> <span class="o">=</span> <span class="n">PROBE_STATUS_ACTIVE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 3. 写回新状态 ---</span>
</span></span><span class="line"><span class="cl">    <span class="n">probe_status</span><span class="p">[</span><span class="n">probe_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">flag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>整个决策过程并非精确的物理模拟，而是基于一套高效的<strong>启发式规则（经验法则）</strong>。这些规则是通过观察和实验总结出来的，能在保证速度的同时达到很好的效果。</p>
<ul>
<li><code>&quot;backfaces_count / probe_rays &gt; 0.25f&quot;</code> 就是一个典型的启发式规则，它简单快速地判断出“探针大概率在几何体内”。</li>
<li>“沿最远视线方向移动”也是一个聪明的做法，它能引导探针自动寻找并移动到局部空间的中心位置。</li>
</ul>
<h1 id="ray-traced-shadows">
<a class="header-anchor" href="#ray-traced-shadows"></a>
Ray Traced Shadows
</h1><p><a href="https://www.cg.tuwien.ac.at/research/publications/2019/BOKSANSKY-2019-RTS/">Ray Traced Shadows: Maintaining Real-Time Frame Rates</a>.</p>
<h2 id="工作流程-1">
<a class="header-anchor" href="#%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b-1"></a>
工作流程
</h2><ol>
<li><strong>Variance History:</strong> 计算并存储过去四帧的可见性方差。</li>
<li><strong>Sample Count Estimation:</strong> 使用最大滤波器和帐篷滤波器估计每个片段和每个光源的采样数量。</li>
<li><strong>Inline Ray Tracing:</strong> 使用采样数量追踪阴影射线到场景中，以获取原始可见性值。</li>
<li><strong>Denoising:</strong> 对原始可见性进行时间和空间滤波，以减少噪声。</li>
<li><strong>Lighting Integration:</strong> 在最终的光照计算中使用滤波后的阴影可见性。</li>
</ol>
<h2 id="计算可见性方差">
<a class="header-anchor" href="#%e8%ae%a1%e7%ae%97%e5%8f%af%e8%a7%81%e6%80%a7%e6%96%b9%e5%b7%ae"></a>
计算可见性方差
</h2><p>这个步骤是整个实时光线追踪阴影算法的起点，其核心思想是<strong>识别出画面中哪些区域的阴影正在发生变化或处于不稳定状态</strong>，从而在后续步骤中对这些区域投入更多的计算资源（发射更多的光线），对稳定区域则使用较少的资源，实现性能与效果的平衡。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief  计算阴影可见性的方差（Variance）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @details 该计算着色器通过分析前四帧的阴影可见性历史数据，来计算每个像素的可见性方差。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 这个方差值实际上是一个简化的衡量标准（取最大值与最小值的差），用于表示阴影的“不稳定性”。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 结果将被存储到一个新的纹理中，供后续的采样数估算步骤使用。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 此过程在半分辨率下运行以提高性能。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义计算着色器的本地工作组大小为 8x8x1。</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 意味着每个工作组包含 64 个着色器调用（线程）。</span>
</span></span><span class="line"><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 1. 计算当前处理的像素坐标 ---</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取目标纹理的分辨率（半分辨率）。</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec2</span> <span class="n">iresolution</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">resolution</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 检查当前着色器调用（线程）是否在目标纹理的有效范围内。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果超出范围，则直接返回，不做任何处理。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// gl_GlobalInvocationID 是当前线程在整个网格中的唯一ID。</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">iresolution</span><span class="p">.</span><span class="n">x</span> <span class="o">||</span> <span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="n">iresolution</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将全局调用ID转换为纹理坐标，用于读取和写入。</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec3</span> <span class="n">tex_coord</span> <span class="o">=</span> <span class="k">ivec3</span><span class="p">(</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 2. 读取历史可见性数据 ---</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 从3D纹理（实际上用作2D纹理数组）中读取存储的前四帧的可见性数据。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// texelFetch 用于精确获取指定整数坐标的纹素值，无需归一化。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// `visibility_cache_texture_index` 是一个全局uniform变量，指向包含历史数据的纹理。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 返回的 vec4 中，每个分量（x, y, z, w）分别代表了过去某一帧的可见性值（0.0为完全阴影，1.0为完全照亮）。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">last_visibility_values</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures_3d</span><span class="p">[</span><span class="n">visibility_cache_texture_index</span><span class="p">],</span> <span class="n">tex_coord</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 3. 计算可见性方差 ---</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 找到这四帧可见性中的最大值。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">max_v</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">last_visibility_values</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">last_visibility_values</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="n">max</span><span class="p">(</span><span class="n">last_visibility_values</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="n">last_visibility_values</span><span class="p">.</span><span class="n">w</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 找到这四帧可见性中的最小值。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">min_v</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">last_visibility_values</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">last_visibility_values</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="n">min</span><span class="p">(</span><span class="n">last_visibility_values</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="n">last_visibility_values</span><span class="p">.</span><span class="n">w</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算最大值与最小值之差。这个差值（delta）被用作方差的近似衡量。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果差值大，说明在过去几帧里，该像素的阴影状态变化剧烈（例如，从全亮到全黑）。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果差值小，说明阴影状态很稳定。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">max_v</span> <span class="o">-</span> <span class="n">min_v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 4. 存储计算结果 ---</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将计算出的方差值（delta）写入到输出图像（Image）中。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// imageStore 用于向指定整数坐标的图像写入数据。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// `variation_texture_index` 指向用于存储方差结果的纹理。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里只使用了vec4的第一个分量（r通道）来存储delta。</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">global_images_3d</span><span class="p">[</span><span class="n">variation_texture_index</span><span class="p">],</span> <span class="n">tex_coord</span><span class="p">,</span> <span class="k">vec4</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="计算阴影可见性">
<a class="header-anchor" href="#%e8%ae%a1%e7%ae%97%e9%98%b4%e5%bd%b1%e5%8f%af%e8%a7%81%e6%80%a7"></a>
计算阴影可见性
</h2><p>这是整个流程的心脏。它接收前一阶段生成的“方差图”，经过一系列复杂的滤波处理，智能地为每个像素决定需要发射多少条阴影光线，然后调用光线追踪硬件进行计算，最后更新历史数据以供下一帧使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief  估算采样数、执行光追并更新历史缓存。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @details
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 该着色器是自适应光追阴影的核心。其主要工作包括：
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 1. (空间滤波) 对上一阶段的方差图进行最大值滤波和帐篷滤波，以平滑和扩大不稳定的区域。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 2. (时间滤波) 将滤波后的方差与历史数据结合，进一步稳定信号。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 3. (采样数估算) 根据最终的稳定方差值，动态地增加或减少每个像素的阴影光线采样数。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 4. (光线追踪) 根据估算出的采样数，调用光线追踪函数，计算当前像素的原始阴影可见性。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 5. (更新缓存) 将本帧计算出的新数据（可见性、方差、采样数）写入历史缓存，供下一帧使用。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义工作组大小为 8x8</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define GROUP_SIZE 8</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 定义共享内存大小，需要比工作组大，以容纳邻域数据 (8 + 6*2 = 20)</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define LOCAL_DATA_SIZE (GROUP_SIZE + 6 * 2)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="n">GROUP_SIZE</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="n">GROUP_SIZE</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 声明共享内存，用于在工作组内高效地共享像素数据，避免重复读取全局内存</span>
</span></span><span class="line"><span class="cl"><span class="n">shared</span> <span class="k">float</span> <span class="n">local_image_data</span><span class="p">[</span><span class="n">LOCAL_DATA_SIZE</span><span class="p">][</span><span class="n">LOCAL_DATA_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">shared</span> <span class="k">float</span> <span class="n">local_max_image_data</span><span class="p">[</span><span class="n">LOCAL_DATA_SIZE</span><span class="p">][</span><span class="n">LOCAL_DATA_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// [! 为了篇幅，此处省略 max_filter, read_variation_value, tent_kernel 的定义 !]</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [! 它们的功能将在下面的原理解析中详细说明 !]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 准备工作：坐标计算与边界检查 ---</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec2</span> <span class="n">iresolution</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">resolution</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">iresolution</span><span class="p">.</span><span class="n">x</span> <span class="o">||</span> <span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="n">iresolution</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">ivec3</span> <span class="n">local_index</span> <span class="o">=</span> <span class="k">ivec3</span><span class="p">(</span><span class="n">gl_LocalInvocationID</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">+</span> <span class="k">ivec3</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec3</span> <span class="n">global_index</span> <span class="o">=</span> <span class="k">ivec3</span><span class="p">(</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 第 1 步：加载方差数据到共享内存 (优化) ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 每个线程负责将自己的方差值读入共享内存。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 边界上的线程会额外加载邻域数据，供整个工作组使用。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 此处省略了复杂的邻域加载代码，其目的是将一个更大的区域(20x20)读入共享内存 ...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// local_image_data[...][...] = texelFetch(variation_texture_index, ...);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 同步点：确保所有线程都已将数据写入共享内存，才能继续</span>
</span></span><span class="line"><span class="cl">    <span class="n">memoryBarrierShared</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">barrier</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 第 2 步：空间滤波 - 最大值滤波 (Max Filter) + 帐篷滤波 (Tent Filter) ---</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2.1 对原始方差图进行 5x5 最大值滤波。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这会“扩张”不稳定的区域，确保阴影边缘得到充分处理。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">max_filtered_value</span> <span class="o">=</span> <span class="n">max_filter</span><span class="p">(</span><span class="n">local_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">local_max_image_data</span><span class="p">[</span><span class="n">local_index</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">local_index</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_filtered_value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 同步点：确保最大值滤波完成</span>
</span></span><span class="line"><span class="cl">    <span class="n">memoryBarrierShared</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">barrier</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2.2 对最大值滤波的结果再进行 13x13 帐篷滤波（加权平均）。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这会进一步平滑和模糊方差信号，使其变化更平缓。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// `tent_kernel` 是一个预计算的权重矩阵。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">spatial_filtered_value</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 此处省略了 tent filter 的循环代码，它将 local_max_image_data 与 tent_kernel 相乘求和 ...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// spatial_filtered_value = a_sum_of(local_max_image_data * tent_kernel);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 第 3 步：时间滤波 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 读取上一帧的滤波后方差历史值</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">last_variation_values</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures_3d</span><span class="p">[</span><span class="n">variation_cache_texture_index</span><span class="p">],</span> <span class="n">global_index</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将当前帧的空间滤波结果与历史结果进行混合，得到一个更稳定的最终方差信号。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">final_filtered_value</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">spatial_filtered_value</span> <span class="o">+</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="p">(</span><span class="n">last_variation_values</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">last_variation_values</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">last_variation_values</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">last_variation_values</span><span class="p">.</span><span class="n">w</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 从G-Buffer读取运动矢量。-1.0 是一个标记，表示该像素没有有效的历史。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">motion_vectors_value</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">motion_vectors_texture_index</span><span class="p">],</span> <span class="p">...).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 第 4 步：采样数量估算 ---</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">sample_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 分支 1: 历史有效 (Temporal Reprojection is Successful)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">motion_vectors_value</span><span class="p">.</span><span class="n">r</span> <span class="o">!=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 继承上一帧的采样数作为基础</span>
</span></span><span class="line"><span class="cl">        <span class="n">uvec4</span> <span class="n">sample_count_history</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(...,</span> <span class="n">samples_count_cache_texture_index</span><span class="p">,</span> <span class="p">...);</span>
</span></span><span class="line"><span class="cl">        <span class="n">sample_count</span> <span class="o">=</span> <span class="n">sample_count_history</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 检查历史是否稳定</span>
</span></span><span class="line"><span class="cl">        <span class="k">bool</span> <span class="n">stable_sample_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">sample_count_history</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">sample_count_history</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">...;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 对天空盒等特殊情况做处理</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">raw_depth</span> <span class="o">==</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">sample_count</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// 应用带有“惯性”的调整逻辑 (Hysteresis)</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果方差大，增加采样数</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">filtered_value</span> <span class="o">&gt;</span> <span class="n">delta</span> <span class="o">&amp;&amp;</span> <span class="n">sample_count</span> <span class="o">&lt;</span> <span class="n">MAX_SHADOW_VISIBILITY_SAMPLE_COUNT</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">sample_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> 
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果方差小且历史稳定，减少采样数</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">stable_sample_count</span> <span class="o">&amp;&amp;</span> <span class="n">sample_count</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">filtered_value</span> <span class="o">&lt;</span> <span class="n">delta</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">sample_count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 保证最少有1个采样</span>
</span></span><span class="line"><span class="cl">            <span class="n">sample_count</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">sample_count</span><span class="p">,</span> <span class="mi">1</span><span class="n">u</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 分支 2: 历史无效 (Disocclusion Detected)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 对于没有历史的“新”像素，我们无法预测其复杂度。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 采取保守策略：直接使用最大采样数，以保证第一次出现的质量，避免闪烁。</span>
</span></span><span class="line"><span class="cl">        <span class="n">sample_count</span> <span class="o">=</span> <span class="n">MAX_SHADOW_VISIBILITY_SAMPLE_COUNT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 第 5 步：执行光线追踪 ---</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">visibility</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">sample_count</span> <span class="o">&gt;</span> <span class="mo">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 准备光追所需数据：世界坐标、法线等</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="k">vec3</span> <span class="n">pixel_world_position</span> <span class="o">=</span> <span class="p">...;</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="k">vec3</span> <span class="n">normal</span> <span class="o">=</span> <span class="p">...;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 根据灯光类型，调用不同的光追函数</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">is_raytrace_shadow_point_light</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">visibility</span> <span class="o">=</span> <span class="n">get_point_light_visibility</span><span class="p">(...,</span> <span class="n">sample_count</span><span class="p">,</span> <span class="p">...);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">visibility</span> <span class="o">=</span> <span class="n">get_directional_light_visibility</span><span class="p">(...,</span> <span class="n">sample_count</span><span class="p">,</span> <span class="p">...);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 第 6 步：更新所有历史缓存 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 更新可见性历史、方差历史和采样数历史，将当前帧的数据推入队列</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">new_visibility_history</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 分支 1: 历史有效</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">motion_vectors_value</span><span class="p">.</span><span class="n">r</span> <span class="o">!=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 读取旧的历史值</span>
</span></span><span class="line"><span class="cl">        <span class="n">new_visibility_history</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(...,</span> <span class="n">visibility_cache_texture_index</span><span class="p">,</span> <span class="p">...);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 将历史数据像队列一样前移一位</span>
</span></span><span class="line"><span class="cl">        <span class="n">new_visibility_history</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">new_visibility_history</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">new_visibility_history</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">new_visibility_history</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">new_visibility_history</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">new_visibility_history</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 分支 2: 历史无效</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 历史数据是错误的（属于上一个物体），必须被丢弃。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 直接用当前帧计算出的新可见性值，填满整个历史记录。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 这相当于重置(reset)了这个像素的时间滤波器，防止产生鬼影(ghosting)。</span>
</span></span><span class="line"><span class="cl">        <span class="n">new_visibility_history</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">visibility</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">new_visibility_history</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">visibility</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">new_visibility_history</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">visibility</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 无论哪个分支，都把当前帧的新可见性值放到历史记录的第一位</span>
</span></span><span class="line"><span class="cl">    <span class="n">new_visibility_history</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">visibility</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 此处省略了繁琐的历史数据更新和 imageStore 写入代码 ...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// imageStore(visibility_cache_texture_index, ..., new_visibility_history);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// imageStore(filtered_variation_texture_index, ..., vec4(spatial_filtered_value, 0, 0, 0));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// imageStore(variation_cache_texture_index, ..., new_variation_history);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// imageStore(samples_count_cache_texture_index, ..., new_sample_count_history);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>方差 (Variation)
<img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507201755949.png" alt="variation"></p>
<p>滤波后方差 (Filtered Variation)
<img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507201753791.png" alt="filtered_variation"></p>
<p>方差缓存 (Variation History)
<img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507201801410.png" alt="variation_cache"></p>
<p>可见性缓存 (Visibility History)
<img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507201758141.png" alt="visibility_cache"></p>
<p>采样数缓存 (Samples Count History)
<img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507201759184.png" alt="samples_count_cache"></p>
<h3 id="motion-vectors">
<a class="header-anchor" href="#motion-vectors"></a>
Motion Vectors
</h3><p>计算<strong>运动矢量 (Motion Vector)</strong> 的计算着色器代码。</p>
<p>这个 Pass 在渲染管线中扮演着至关重要的角色，它是所有<strong>时间性技术 (Temporal Techniques)</strong>，如 TAA（时间性抗锯齿）和 SVGF（时空方差引导滤波）的基石。它的核心任务是为屏幕上的每个像素计算一个2D向量，这个向量描述了该像素上的物体从上一帧到当前帧在屏幕空间中移动的方向和距离。</p>
<p>值得注意的是，这段代码实际上计算并输出了<strong>两种</strong>不同的运动矢量，分别用于不同的目的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief  计算屏幕空间的运动矢量。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @details
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 该计算着色器通过比较当前帧和上一帧的顶点位置，为每个像素生成运动矢量。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 它会输出两种运动矢量：
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 1. 标准运动矢量：用于 TAA，精确计算了物体运动并移除了相机抖动(Jitter)的影响。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 2. 可见性运动矢量：用于阴影等需要历史有效性判断的场景，如果重投影不合法，
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 则存入一个特殊标记(-1, -1)。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 输出目标：一个用于TAA的标准运动矢量纹理</span>
</span></span><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">rg16f</span><span class="p">,</span> <span class="n">set</span> <span class="o">=</span> <span class="n">MATERIAL_SET</span><span class="p">,</span> <span class="n">binding</span> <span class="o">=</span> <span class="mi">51</span><span class="p">)</span> <span class="k">uniform</span> <span class="n">image2D</span> <span class="n">motion_vectors</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 输出目标：一个用于可见性/阴影缓冲区的运动矢量纹理</span>
</span></span><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">rg16f</span><span class="p">,</span> <span class="n">set</span> <span class="o">=</span> <span class="n">MATERIAL_SET</span><span class="p">,</span> <span class="n">binding</span> <span class="o">=</span> <span class="mi">52</span><span class="p">)</span> <span class="k">uniform</span> <span class="n">image2D</span> <span class="n">visibility_motion_vectors</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">set</span> <span class="o">=</span> <span class="n">MATERIAL_SET</span><span class="p">,</span> <span class="n">binding</span> <span class="o">=</span> <span class="mi">53</span><span class="p">)</span> <span class="k">uniform</span> <span class="k">sampler2D</span> <span class="n">normals_texture</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec3</span> <span class="n">pos</span> <span class="o">=</span> <span class="k">ivec3</span><span class="p">(</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 第 1 步：重建当前像素的世界坐标 ---</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">float</span> <span class="n">raw_depth</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">depth_texture_index</span><span class="p">)],</span> <span class="n">pos</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果是天空盒或背景，则没有运动，直接返回。</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">raw_depth</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">imageStore</span><span class="p">(</span><span class="n">motion_vectors</span><span class="p">,</span> <span class="n">pos</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="k">vec4</span><span class="p">(</span><span class="mo">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">imageStore</span><span class="p">(</span><span class="n">visibility_motion_vectors</span><span class="p">,</span> <span class="n">pos</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="k">vec4</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">));</span> <span class="c1">// 标记为无效</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">vec2</span> <span class="n">screen_uv</span> <span class="o">=</span> <span class="n">uv_nearest</span><span class="p">(</span><span class="n">pos</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">resolution</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">vec3</span> <span class="n">pixel_world_position</span> <span class="o">=</span> <span class="n">world_position_from_depth</span><span class="p">(</span><span class="n">screen_uv</span><span class="p">,</span> <span class="n">raw_depth</span><span class="p">,</span> <span class="n">inverse_view_projection</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 第 2 步：计算当前和历史的NDC坐标 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算当前像素在当前帧的NDC（归一化设备坐标，范围[-1, 1]）坐标。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">current_position_ndc</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">ndc_from_uv_raw_depth</span><span class="p">(</span><span class="n">screen_uv</span><span class="p">,</span> <span class="n">raw_depth</span><span class="p">),</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将当前世界坐标用【上一帧】的视图投影矩阵进行变换，得到该点在【上一帧】的NDC坐标。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">previous_position_ndc</span> <span class="o">=</span> <span class="n">previous_view_projection</span> <span class="o">*</span> <span class="k">vec4</span><span class="p">(</span><span class="n">pixel_world_position</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">previous_position_ndc</span><span class="p">.</span><span class="n">xyz</span> <span class="o">/=</span> <span class="n">previous_position_ndc</span><span class="p">.</span><span class="n">w</span><span class="p">;</span> <span class="c1">// 执行透视除法</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 任务 A: 计算标准运动矢量 (用于 TAA)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 2D运动矢量即为两帧NDC坐标的xy差值。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">velocity</span> <span class="o">=</span> <span class="n">current_position_ndc</span><span class="p">.</span><span class="n">xy</span> <span class="o">-</span> <span class="n">previous_position_ndc</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 为了实现 TAA，每一帧的投影矩阵都会有一个亚像素级别的抖动(Jitter)。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算出的速度必须减去这个相机抖动带来的位移，以得到物体纯粹的运动。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">jitter_difference</span> <span class="o">=</span> <span class="p">(</span><span class="n">jitter_xy</span> <span class="o">-</span> <span class="n">previous_jitter_xy</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">velocity</span> <span class="o">-=</span> <span class="n">jitter_difference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将最终的、经过抖动校正的运动矢量写入纹理。</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">motion_vectors</span><span class="p">,</span> <span class="n">pos</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="k">vec4</span><span class="p">(</span><span class="n">velocity</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 任务 B: 计算可见性运动矢量 (用于阴影)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这是一个带有效性检查的运动矢量。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 首先，计算两帧之间归一化的深度差异。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">depth_diff</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">previous_position_ndc</span><span class="p">.</span><span class="n">z</span> <span class="o">/</span> <span class="n">current_position_ndc</span><span class="p">.</span><span class="n">z</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 然后，计算一个自适应的深度差异阈值 eps。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这个阈值会根据表面法线与视线夹角（view_normal.z）动态变化。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 表面越是正对屏幕，eps越大，容差越高。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">normal</span> <span class="o">=</span> <span class="n">octahedral_decode</span><span class="p">(</span><span class="n">texelFetch</span><span class="p">(</span><span class="n">normals_texture</span><span class="p">,</span> <span class="n">pos</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">rg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">view_normal</span> <span class="o">=</span> <span class="n">world_to_camera</span> <span class="o">*</span> <span class="k">vec4</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">c1</span> <span class="o">=</span> <span class="mf">0.003</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="mf">0.017</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">eps</span> <span class="o">=</span> <span class="n">c1</span> <span class="o">+</span> <span class="n">c2</span> <span class="o">*</span> <span class="n">abs</span><span class="p">(</span><span class="n">view_normal</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果深度差异在容差范围内，则认为重投影有效，存储原始的运动矢量。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 否则，认为发生了遮挡剔除 (disocclusion)，存入一个特殊标记值 (-1, -1)。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">visibility_motion</span> <span class="o">=</span> <span class="n">depth_diff</span> <span class="o">&lt;</span> <span class="n">eps</span> <span class="o">?</span> <span class="p">(</span><span class="n">current_position_ndc</span><span class="p">.</span><span class="n">xy</span> <span class="o">-</span> <span class="n">previous_position_ndc</span><span class="p">.</span><span class="n">xy</span><span class="p">)</span> <span class="o">:</span> <span class="k">vec2</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">visibility_motion_vectors</span><span class="p">,</span> <span class="n">pos</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="k">vec4</span><span class="p">(</span><span class="n">visibility_motion</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="第一部分计算标准运动矢量-用于taa">
<a class="header-anchor" href="#%e7%ac%ac%e4%b8%80%e9%83%a8%e5%88%86%e8%ae%a1%e7%ae%97%e6%a0%87%e5%87%86%e8%bf%90%e5%8a%a8%e7%9f%a2%e9%87%8f-%e7%94%a8%e4%ba%8etaa"></a>
第一部分：计算标准运动矢量 (用于TAA)
</h4><ol>
<li><strong>重建世界坐标</strong>: 首先，着色器利用深度图和当前帧的相机逆矩阵，从2D屏幕坐标反推出该像素在3D世界中的坐标 <code>pixel_world_position</code>。</li>
<li><strong>计算今/昔NDC坐标</strong>:
<ul>
<li><strong>当前NDC</strong>: 将当前像素的UV和深度直接转换为当前帧的NDC坐标。</li>
<li><strong>历史NDC</strong>: 这是最关键的一步。它拿起当前点的3D世界坐标，问一个问题：“在<strong>上一帧</strong>的相机视角下，这个3D点会被投影到屏幕的哪个位置？” 它通过将 <code>pixel_world_position</code> 乘以 <code>previous_view_projection</code> (上一帧的视图投影矩阵) 来得到答案。</li>
</ul>
</li>
<li><strong>计算原始速度</strong>: 两个NDC坐标的 <code>xy</code> 分量之差，<code>current_position_ndc.xy - previous_position_ndc.xy</code>，就是该点在屏幕上从上一帧到当前帧的移动向量。</li>
<li><strong>移除相机抖动 (Jitter Correction)</strong>: TAA为了达到超采样效果，每帧都会对相机做亚像素级别的微小平移（Jitter）。这个平移也会体现在运动矢量中。为了只保留物体的纯粹运动，必须减去两帧之间相机抖动的差值 <code>jitter_difference</code>。</li>
<li><strong>存储结果</strong>: 最终得到的 <code>velocity</code> 被写入 <code>motion_vectors</code> 纹理，供 TAA Pass 使用。</li>
</ol>
<h4 id="第二部分计算可见性运动矢量-用于阴影">
<a class="header-anchor" href="#%e7%ac%ac%e4%ba%8c%e9%83%a8%e5%88%86%e8%ae%a1%e7%ae%97%e5%8f%af%e8%a7%81%e6%80%a7%e8%bf%90%e5%8a%a8%e7%9f%a2%e9%87%8f-%e7%94%a8%e4%ba%8e%e9%98%b4%e5%bd%b1"></a>
第二部分：计算可见性运动矢量 (用于阴影)
</h4><ol>
<li><strong>计算深度差异</strong>: 它比较了重投影后的历史NDC深度 <code>previous_position_ndc.z</code> 和当前NDC深度 <code>current_position_ndc.z</code>。如果两者差异巨大，通常意味着这个像素在上一帧被其他物体遮挡了。</li>
<li><strong>计算自适应阈值</strong>: 为了让深度比较更鲁棒，它没有使用固定的阈值，而是根据表面的朝向计算了一个动态阈值 <code>eps</code>。</li>
<li><strong>有效性判断</strong>: 如果深度差异小于这个自适应阈值，就认为历史数据是有效的，存储一个<strong>未经抖动校正</strong>的运动矢量。</li>
<li><strong>存储结果或标记</strong>: 如果深度差异过大，就存入一个特殊的标记值 <code>vec2(-1, -1)</code>。后续的 Pass（如我们之前分析过的阴影和SVGF Pass）在读取这个纹理时，一旦看到 <code>(-1, -1)</code>，就知道这个像素的历史数据不可信，需要丢弃。</li>
</ol>
<p>时间性算法最大的敌人就是<strong>遮挡剔除 (Disocclusion)</strong>，即前景物体移开，暴露出新的背景。此时，新的背景像素如果错误地重投影，就会采样到前景物体的历史颜色，产生鬼影。</p>
<ul>
<li><code>visibility_motion_vectors</code> 纹理就是为了解决这个问题而生的。它不仅仅是速度，更是一个<strong>带有“有效/无效”状态的速度</strong>。</li>
<li>通过比较深度，可以非常可靠地检测出 Disocclusion 事件。当后续的着色器需要复用历史时，它会先检查这个运动矢量是否为 <code>(-1, -1)</code>，从而做出是“复用”还是“丢弃”历史的正确决策。</li>
</ul>
<h3 id="光线追踪辅助函数">
<a class="header-anchor" href="#%e5%85%89%e7%ba%bf%e8%bf%bd%e8%b8%aa%e8%be%85%e5%8a%a9%e5%87%bd%e6%95%b0"></a>
光线追踪辅助函数
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief  为点光源计算阴影可见性（软阴影）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param light_index       当前处理的点光源索引（未使用，但可能用于多光源场景）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param sample_count      根据方差估算出的，需要为此像素发射的光线数量。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param world_position    当前像素在世界坐标系中的位置。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param normal            当前像素表面的法线。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param frame_index       当前帧的索引，用于在泊松盘采样中实现时间上的抖动。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return float            最终的可见性（0.0为完全阴影，1.0为完全照亮）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">float</span> <span class="n">get_point_light_visibility</span><span class="p">(</span><span class="n">uint</span> <span class="n">light_index</span><span class="p">,</span> <span class="n">uint</span> <span class="n">sample_count</span><span class="p">,</span> <span class="k">vec3</span> <span class="n">world_position</span><span class="p">,</span> <span class="k">vec3</span> <span class="n">normal</span><span class="p">,</span> <span class="n">uint</span> <span class="n">frame_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 1. 计算基础光照几何信息 ---</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算从像素表面指向光源的向量。</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">vec3</span> <span class="n">position_to_light</span> <span class="o">=</span> <span class="n">raytraced_shadow_light_position</span> <span class="o">-</span> <span class="n">world_position</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 归一化该向量，得到标准的光线方向 &#39;l&#39;。</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">vec3</span> <span class="n">l</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">position_to_light</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算法线与光线方向的点积 (N dot L)。如果小于0，说明表面背向光源。</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">float</span> <span class="n">NoL</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算像素到光源的实际距离 &#39;d&#39;。</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">float</span> <span class="n">distance_to_light</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">position_to_light</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 2. 构建采样所需的坐标系 ---</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 为了在垂直于光线方向的平面上进行随机采样（模拟光源面积），</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 我们需要构建一个局部坐标系。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 首先，通过与一个固定的&#39;up&#39;向量（这里用Y轴）进行叉乘，得到x轴。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">x_axis</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">cross</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 再次叉乘，得到与x轴和光线方向都垂直的y轴。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">y_axis</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">cross</span><span class="p">(</span><span class="n">x_axis</span><span class="p">,</span> <span class="n">l</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 3. 初始化并进行光照剔除/衰减检查 ---</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">visibility</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="c1">// 初始化可见性累加器</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取点光源的半径（影响范围）。</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">float</span> <span class="n">light_radius</span> <span class="o">=</span> <span class="n">raytraced_shadow_light_radius</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算基于距离平方反比的光照衰减。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="n">attenuation_square_falloff</span><span class="p">(</span><span class="n">position_to_light</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">/</span> <span class="n">light_radius</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 为了模拟光源的体积，计算一个缩放因子。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 距离光源越近，光源看起来越大，因此软阴影的半影区域也应该越宽。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这个因子用于调整随机采样点的偏移范围。</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">float</span> <span class="n">scaled_distance</span> <span class="o">=</span> <span class="n">light_radius</span> <span class="o">/</span> <span class="n">distance_to_light</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// *** 核心性能优化与有效性检查 ***</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 只有同时满足以下所有条件，才进行昂贵的光线追踪计算：</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. NoL &gt; 0.001f:         表面必须朝向光源。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. distance_to_light &lt;= light_radius: 像素必须在光源的影响半径之内。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. attenuation &gt; 0.001f:  光照衰减后的强度足够大，值得计算。</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">((</span><span class="n">NoL</span> <span class="o">&gt;</span> <span class="mf">0.001</span><span class="n">f</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">distance_to_light</span> <span class="o">&lt;=</span> <span class="n">light_radius</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">attenuation</span> <span class="o">&gt;</span> <span class="mf">0.001</span><span class="n">f</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 4. 循环执行光线追踪 ---</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">s</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">sample_count</span><span class="p">;</span> <span class="o">++</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 从预计算的泊松盘采样表中获取一个2D随机点。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// `(s * FRAME_HISTORY_COUNT + frame_index) % SAMPLE_NUM` 确保每一帧、每一次采样的随机点都不同。</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec2</span> <span class="n">poisson_sample</span> <span class="o">=</span> <span class="n">POISSON_SAMPLES</span><span class="p">[(</span><span class="n">s</span> <span class="o">*</span> <span class="n">FRAME_HISTORY_COUNT</span> <span class="o">+</span> <span class="n">frame_index</span><span class="p">)</span> <span class="o">%</span> <span class="n">SAMPLE_NUM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 将2D随机点映射到我们之前构建的3D坐标系上，并根据距离进行缩放，模拟光源的表观大小。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 这会产生一个指向光源虚拟面积上某个随机点的偏移向量。</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">random_x</span> <span class="o">=</span> <span class="n">x_axis</span> <span class="o">*</span> <span class="n">poisson_sample</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">scaled_distance</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.01</span><span class="p">;</span> <span class="c1">// 0.01是人为调整的缩放系数</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">random_y</span> <span class="o">=</span> <span class="n">y_axis</span> <span class="o">*</span> <span class="n">poisson_sample</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">scaled_distance</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.01</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 将原始光线方向与随机偏移结合，得到一条抖动后的新光线方向。</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">random_dir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">random_x</span> <span class="o">+</span> <span class="n">random_y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 初始化光线查询</span>
</span></span><span class="line"><span class="cl">            <span class="n">rayQueryEXT</span> <span class="n">rayQuery</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">rayQueryInitializeEXT</span><span class="p">(</span><span class="n">rayQuery</span><span class="p">,</span> <span class="n">as</span><span class="p">,</span> <span class="n">gl_RayFlagsOpaqueEXT</span> <span class="o">|</span> <span class="n">gl_RayFlagsTerminateOnFirstHitEXT</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                  <span class="mh">0xff</span><span class="p">,</span>                <span class="c1">// mask: 追踪所有不透明物体</span>
</span></span><span class="line"><span class="cl">                                  <span class="n">world_position</span><span class="p">,</span>      <span class="c1">// origin: 光线起点</span>
</span></span><span class="line"><span class="cl">                                  <span class="mf">0.05</span><span class="p">,</span>                <span class="c1">// tMin:   最小距离，防止自相交</span>
</span></span><span class="line"><span class="cl">                                  <span class="n">random_dir</span><span class="p">,</span>          <span class="c1">// dir:    光线方向</span>
</span></span><span class="line"><span class="cl">                                  <span class="n">distance_to_light</span><span class="p">);</span>  <span class="c1">// tMax:   最大距离，光线只需追踪到光源位置即可</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 执行光线追踪</span>
</span></span><span class="line"><span class="cl">            <span class="n">rayQueryProceedEXT</span><span class="p">(</span><span class="n">rayQuery</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 检查光线是否在到达光源前被遮挡</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">rayQueryGetIntersectionTypeEXT</span><span class="p">(</span><span class="n">rayQuery</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span> <span class="o">!=</span> <span class="n">gl_RayQueryCommittedIntersectionNoneEXT</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 如果有交点，需要进一步判断交点是否真的在光源前面</span>
</span></span><span class="line"><span class="cl">                <span class="n">visibility</span> <span class="o">+=</span> <span class="n">rayQueryGetIntersectionTEXT</span><span class="p">(</span><span class="n">rayQuery</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">distance_to_light</span> <span class="o">?</span> <span class="mf">0.0</span><span class="n">f</span> <span class="o">:</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 如果没有命中任何物体，说明这条光路是通畅的</span>
</span></span><span class="line"><span class="cl">                <span class="n">visibility</span> <span class="o">+=</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 5. 返回最终结果 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 返回平均可见度。如果循环未执行，visibility为0，结果正确。</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">visibility</span> <span class="o">/</span> <span class="k">float</span><span class="p">(</span><span class="n">sample_count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="共享内存优化-shared-memory">
<a class="header-anchor" href="#%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98%e4%bc%98%e5%8c%96-shared-memory"></a>
共享内存优化 (Shared Memory)
</h3><ul>
<li><strong>目的</strong>：为了进行最大值和帐篷滤波，每个线程都需要读取其周围邻居像素的方差值。如果每个线程都直接从全局纹理内存中读取所有邻居数据，会导致大量的重复读取和高延迟。</li>
<li><strong>技术</strong>：<code>shared</code> 内存是 GPU 上一种速度极快的小容量内存，由同一个工作组（Workgroup）内的所有线程共享。该着色器首先让工作组内的线程协作，将计算所需的一大块区域数据从慢速的全局内存一次性读入快速的共享内存。之后，所有的滤波操作都直接在共享内存上进行，速度得到极大提升。<code>barrier()</code>同步原语确保了所有线程在读写步骤上保持一致。</li>
</ul>
<h3 id="空间滤波扩张与平滑">
<a class="header-anchor" href="#%e7%a9%ba%e9%97%b4%e6%bb%a4%e6%b3%a2%e6%89%a9%e5%bc%a0%e4%b8%8e%e5%b9%b3%e6%bb%91"></a>
空间滤波：扩张与平滑
</h3><ul>
<li><strong>最大值滤波 (Max Filter)</strong>：这是一种<strong>形态学扩张 (Dilation)</strong> 操作。它将一个像素的值替换为其 5x5 邻域内的最大值。
<ul>
<li><strong>作用</strong>：如果一个像素的方差很高（不稳定），经过最大值滤波后，它周围的像素也会被“感染”成高方差。这会<strong>有效扩大需要高采样率的区域</strong>，形成一个“安全边界”，防止因为物体移动过快而导致阴影边缘出现采样不足的闪烁噪点。</li>
</ul>
</li>
<li><strong>帐篷滤波 (Tent Filter)</strong>：这是一个加权平均的<strong>卷积滤波</strong>，其权重从中心到边缘线性递减，形状像一个帐篷。
<ul>
<li><strong>作用</strong>：它对最大值滤波后的结果进行<strong>平滑/模糊</strong>处理。这可以防止采样数量在相邻像素间发生剧烈跳变（比如从1突变到16），让采样数的过渡更加平缓自然，避免产生块状的视觉瑕疵。</li>
</ul>
</li>
</ul>
<h3 id="采样数估算的时间滞后效应-hysteresis">
<a class="header-anchor" href="#%e9%87%87%e6%a0%b7%e6%95%b0%e4%bc%b0%e7%ae%97%e7%9a%84%e6%97%b6%e9%97%b4%e6%bb%9e%e5%90%8e%e6%95%88%e5%ba%94-hysteresis"></a>
采样数估算的“时间滞后效应” (Hysteresis)
</h3><p>代码中最核心的决策逻辑是动态调整<code>sample_count</code>。它并没有简单地设置一个阈值，而是采用了带有“记忆”和“惯性”的策略，这在控制理论中称为<strong>滞后 (Hysteresis)</strong>。</p>
<ul>
<li><strong>增加采样</strong>：条件很简单，只要<code>final_filtered_value &gt; delta_threshold</code>，就增加采样数。系统对“不稳定”信号的反应非常灵敏。</li>
<li><strong>减少采样</strong>：条件非常苛刻，必须同时满足 <code>filtered_value &lt; delta_threshold</code> <strong>并且</strong> <code>stable_sample_count</code> 为真（即过去四帧的采样数都一样）。</li>
<li><strong>目的</strong>：这种不对称的逻辑可以防止采样数在阈值附近不停地抖动。一旦一个区域被判定为不稳定，它会保持较高的采样数一段时间，直到系统确认该区域<strong>持续稳定</strong>后，才敢慢慢降低采样数。这极大地增强了最终画面的时间稳定性。</li>
</ul>
<h2 id="降噪">
<a class="header-anchor" href="#%e9%99%8d%e5%99%aa"></a>
降噪
</h2><p>这个着色器是一个典型的<strong>时空降噪 (Spatio-temporal Denoising)</strong> 滤波器。它的目标是将在上一个 Pass 中用少量光线计算出的、充满噪点的原始可见性图，处理成一幅干净、稳定且保留了细节的最终阴影图。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief  对光线追踪生成的原始阴影可见性进行时空降噪。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @details
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 该着色器结合了时间和空间两种维度的滤波来消除阴影噪点。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 1. (时间滤波) 首先，它对一个像素过去四帧的可见性结果取平均值，获得一个初步稳定的基准值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 2. (空间滤波) 接着，它对时间滤波后的结果进行一个带边缘检测的5x5高斯模糊。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 这个“边缘检测”通过比较像素间的法线来实现，防止模糊效果跨越几何边缘，从而保护场景细节。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 最终输出一张干净平滑的阴影图，用于最终的光照合成。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义工作组大小 8x8</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define GROUP_SIZE 8</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 共享内存大小，需要比工作组大，以容纳 5x5 滤波核所需的邻域数据 (8 + 2*2 = 12)</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define LOCAL_DATA_SIZE (GROUP_SIZE + 2 * 2)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="n">GROUP_SIZE</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="n">GROUP_SIZE</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 预计算的 5x5 高斯核权重</span>
</span></span><span class="line"><span class="cl"><span class="k">float</span> <span class="n">gaussian_kernel</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 声明共享内存，用于高效缓存邻域的可见性和法线数据</span>
</span></span><span class="line"><span class="cl"><span class="n">shared</span> <span class="k">float</span> <span class="n">local_image_data</span><span class="p">[</span><span class="n">LOCAL_DATA_SIZE</span><span class="p">][</span><span class="n">LOCAL_DATA_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">shared</span> <span class="k">vec3</span>  <span class="n">local_normal_data</span><span class="p">[</span><span class="n">LOCAL_DATA_SIZE</span><span class="p">][</span><span class="n">LOCAL_DATA_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief  进行时间滤波。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return float 过去四帧可见性的平均值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">float</span> <span class="n">visibility_temporal_filter</span><span class="p">(</span><span class="k">ivec3</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 从历史缓存中读取前一帧(x)、前两帧(y)、前三帧(z)、前四帧(w)的可见性值。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 注意：这里的x分量是上一Pass刚写入的、充满噪点的当前帧原始可见性。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">last_visibility_values</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures_3d</span><span class="p">[</span><span class="n">visibility_cache_texture_index</span><span class="p">],</span> <span class="n">index</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将这四帧的值简单相加后取平均，得到一个在时间上初步平滑的结果。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">filtered_visibility</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="p">(</span><span class="n">last_visibility_values</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">last_visibility_values</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">last_visibility_values</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">last_visibility_values</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">filtered_visibility</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// [! 此处省略 get_normal 函数，其作用是从G-Buffer中读取法线 !]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 准备工作：坐标计算与边界检查 ---</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec2</span> <span class="n">iresolution</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">resolution</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">iresolution</span><span class="p">.</span><span class="n">x</span> <span class="o">||</span> <span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="n">iresolution</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">ivec3</span> <span class="n">local_index</span> <span class="o">=</span> <span class="k">ivec3</span><span class="p">(</span><span class="n">gl_LocalInvocationID</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">+</span> <span class="k">ivec3</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec3</span> <span class="n">global_index</span> <span class="o">=</span> <span class="k">ivec3</span><span class="p">(</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 第 1 步：加载数据到共享内存 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 每个线程负责将自己经过“时间滤波”后的可见性值，以及对应的法线值读入共享内存。</span>
</span></span><span class="line"><span class="cl">    <span class="n">local_image_data</span><span class="p">[</span><span class="n">local_index</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">local_index</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">visibility_temporal_filter</span><span class="p">(</span><span class="n">global_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">local_normal_data</span><span class="p">[</span><span class="n">local_index</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">local_index</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_normal</span><span class="p">(</span><span class="n">global_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 边界上的线程额外加载邻域数据，供整个工作组进行5x5滤波使用。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 此处省略了复杂的邻域加载代码 ...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 同步点：确保所有数据都已加载到共享内存</span>
</span></span><span class="line"><span class="cl">    <span class="n">memoryBarrierShared</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">barrier</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 第 2 步：执行带边缘检测的空间滤波 ---</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">spatial_filtered_value</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取当前中心像素的法线</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">p_normal</span> <span class="o">=</span> <span class="n">local_normal_data</span><span class="p">[</span><span class="n">local_index</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">local_index</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历 5x5 邻域</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 获取邻域像素的法线</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">q_normal</span> <span class="o">=</span> <span class="n">local_normal_data</span><span class="p">[</span><span class="n">local_index</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">y</span><span class="p">][</span><span class="n">local_index</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// *** 核心：边缘检测 (Edge Detection) ***</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 比较中心像素法线 p_normal 和邻域像素法线 q_normal 的点积。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果点积小于一个阈值（如0.9），意味着两个法线差异很大，</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 表明它们可能位于不同的几何平面上（例如，墙角或物体边缘）。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 在这种情况下，我们不应该将邻域像素的颜色混合进来，以避免模糊掉边缘。</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">p_normal</span><span class="p">,</span> <span class="n">q_normal</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.9</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span><span class="p">;</span> <span class="c1">// 跳过这个邻居，不参与计算</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果法线相似，则这是一个有效的邻居</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">v</span> <span class="o">=</span> <span class="n">local_image_data</span><span class="p">[</span><span class="n">local_index</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">y</span><span class="p">][</span><span class="n">local_index</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="p">];</span> <span class="c1">// 读取其可见性</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">k</span> <span class="o">=</span> <span class="n">gaussian_kernel</span><span class="p">[</span><span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">][</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>                           <span class="c1">// 读取对应的高斯权重</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 累加加权后的可见性值</span>
</span></span><span class="line"><span class="cl">            <span class="n">spatial_filtered_value</span> <span class="o">+=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 第 3 步：存储最终降噪结果 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将最终计算出的平滑可见性值写入到输出纹理中。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这张纹理将在最后的光照合成阶段被使用。</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">global_images_3d</span><span class="p">[</span><span class="n">filtered_visibility_texture</span><span class="p">],</span> <span class="n">global_index</span><span class="p">,</span> <span class="k">vec4</span><span class="p">(</span><span class="n">spatial_filtered_value</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol>
<li>
<p><strong>数据加载与时间滤波</strong>：</p>
<ul>
<li><code>main</code>函数启动后，每个线程首先调用 <code>visibility_temporal_filter</code>。这个函数从历史缓存中读取<strong>最近四帧</strong>的原始可见性数据（包括刚刚由上一个Pass生成、充满噪点的当前帧数据）。</li>
<li>它将这四帧的数据简单地<strong>取平均值</strong>。这是一个基础的<strong>时间滤波</strong>，能有效利用帧间的连贯性，快速地将闪烁的噪点大部分抚平。</li>
<li>同时，线程也从G-Buffer中获取当前像素的<strong>法线</strong>向量。</li>
<li>这两个结果（时间滤波后的可见性 和 法线）被一同加载到<strong>共享内存</strong>中，为接下来的空间滤波做准备。</li>
</ul>
</li>
<li>
<p><strong>边缘感知的空间滤波</strong>：</p>
<ul>
<li>这是整个降噪过程的精华所在。在所有数据加载完毕后，每个线程开始对自己负责的像素进行<strong>空间滤波</strong>。</li>
<li>它遍历其周围 5x5 的邻域像素（数据已在共享内存中）。</li>
<li>对于每一个邻居，它并不直接进行模糊，而是先执行一个<strong>检查</strong>：计算中心像素的法线 <code>p_normal</code> 和邻居像素的法线 <code>q_normal</code> 之间的<strong>点积</strong>。</li>
<li><strong>如果点积 &gt; 0.9</strong> (即两个法线方向非常接近)，说明这两个像素很可能在同一个平面上。此时，就将邻居像素的可见性值，乘以其对应的高斯权重，累加到最终结果中。</li>
<li><strong>如果点积 &lt;= 0.9</strong> (即两个法线方向差异较大)，说明这两个像素位于几何边缘或不同的物体上。此时，<code>continue</code> 语句会<strong>跳过这个邻居</strong>，防止它的颜色“污染”中心像素，从而完美地<strong>保留了场景的几何轮廓</strong>。</li>
</ul>
</li>
<li>
<p><strong>输出结果</strong>：</p>
<ul>
<li>循环结束后，<code>spatial_filtered_value</code> 就包含了所有“有效”邻居的加权平均值。</li>
<li>最后，通过 <code>imageStore</code> 将这个干净、平滑且保留了边缘细节的最终可见性值写入到输出纹理 <code>filtered_visibility_texture</code> 中。这张纹理就是最终可以用于光照计算的、高质量的阴影图。
<img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507201753199.png" alt=""></li>
</ul>
</li>
</ol>
<h3 id="关键技术与原理">
<a class="header-anchor" href="#%e5%85%b3%e9%94%ae%e6%8a%80%e6%9c%af%e4%b8%8e%e5%8e%9f%e7%90%86"></a>
关键技术与原理
</h3><ul>
<li>
<p><strong>时空降噪 (Spatio-temporal Denoising)</strong>:
这是现代实时渲染中降噪的标准范式。单纯的空间滤波（模糊）会损失细节，而单纯的时间滤波会产生鬼影（ghosting）。将两者结合，先用时间滤波稳定信号，再用空间滤波清理剩余的噪点，可以在效果和性能之间取得极佳的平衡。</p>
</li>
<li>
<p><strong>高斯模糊 (Gaussian Blur)</strong>:
这是一种经典的低通滤波器，它使用一个高斯函数作为权重核。中心像素的权重最高，越往外的像素权重越低。其效果是平滑图像，有效去除高频噪声。代码中的 <code>gaussian_kernel</code> 就是一个预计算好的权重矩阵。</p>
</li>
<li>
<p><strong>边缘感知滤波 (Edge-Aware Filtering) / 交叉双边滤波 (Cross-Bilateral Filter)</strong>:</p>
<ul>
<li><strong>原理</strong>：通过引入一个额外的指导信息（这里是<strong>法线</strong>），来决定是否应该混合邻居像素的颜色。只有当邻居像素的指导信息（法线）与中心像素相似时，才允许进行混合。</li>
<li><strong>效果</strong>：这使得滤波器可以在平坦的表面上（法线都一样）大力进行模糊降噪，但在遇到几何边缘时（法线突变）则“收手”，不进行模糊。最终实现了<strong>既要降噪，又要保边</strong>的理想效果。这种使用一个图像（法线图）来指导另一个图像（可见性图）滤波的方法，通常被称为<strong>交叉双边滤波 (Cross-Bilateral Filter)</strong>。</li>
</ul>
</li>
</ul>
<h1 id="ray-traced-reflections">
<a class="header-anchor" href="#ray-traced-reflections"></a>
Ray Traced Reflections
</h1><h2 id="工作流程-2">
<a class="header-anchor" href="#%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b-2"></a>
工作流程
</h2><ol>
<li><strong>G-buffer Check:</strong> 检查每个片段的表面粗糙度是否低于指定阈值，以决定是否计算反射。</li>
<li><strong>Ray Casting:</strong> 每个片段发射一条反射光线，方向使用 GGX 分布采样。</li>
<li><strong>Secondary Lighting:</strong> 如果反射光线命中几何体，则向一个重要采样的光源发射次级光线。如果光源可见，则使用照明模型计算颜色。</li>
<li><strong>Denoising:</strong> 由于每个片段只使用一个样本（导致输出噪点），使用 <strong>时空方差引导滤波</strong> (<a href="https://research.nvidia.com/publication/2017-07_spatiotemporal-variance-guided-filtering-real-time-reconstruction-path-traced">SVGF</a>) 处理原始反射数据，以显著减少噪点，利用空间和时间信息。</li>
<li><strong>Lighting Integration:</strong> 将去噪后的反射数据集成到场景的镜面光照计算中。</li>
</ol>
<h2 id="reflections-shaders">
<a class="header-anchor" href="#reflections-shaders"></a>
Reflections Shaders
</h2><p><img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507202007124.png" alt=""></p>
<h3 id="光线生成着色器-ray-generation-shader">
<a class="header-anchor" href="#%e5%85%89%e7%ba%bf%e7%94%9f%e6%88%90%e7%9d%80%e8%89%b2%e5%99%a8-ray-generation-shader"></a>
光线生成着色器 (Ray Generation Shader)
</h3><p>这是整个流程的起点和核心，负责为屏幕上的每个像素生成并追踪反射光线，并在光线命中物体后计算最终的颜色。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// 定义光线负载（Payload），用于在着色器之间传递光线追踪的结果。</span>
</span></span><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mo">0</span><span class="p">)</span> <span class="n">rayPayloadEXT</span> <span class="n">RayPayload</span> <span class="n">payload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ... [此处省略各种随机数生成函数和 sampleGGXVNDF 函数] ...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// sampleGGXVNDF: 根据GGX微表面模型和观察方向，生成一个重要的法线方向，用于模拟粗糙表面的反射。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 1. 初始化与G-Buffer读取 ---</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec2</span> <span class="n">xy</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">gl_LaunchIDEXT</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec2</span> <span class="n">scaled_xy</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">xy</span> <span class="o">*</span> <span class="n">resolution_scale</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 从G-Buffer中读取当前像素的粗糙度。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">roughness</span> <span class="o">=</span> <span class="n">forced_roughness</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="o">?</span> <span class="n">forced_roughness</span> <span class="o">:</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">gbuffer_texures</span><span class="p">.</span><span class="n">x</span><span class="p">],</span> <span class="n">scaled_xy</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">reflection_color</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 只为粗糙度较低（镜面反射较强）的表面计算反射。</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">roughness</span> <span class="o">&lt;=</span> <span class="mf">0.3</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 2. 生成主反射光线 (Primary Reflection Ray) ---</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 从G-Buffer读取深度、法线等信息，重建像素的世界坐标。</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">depth_texture_index</span><span class="p">],</span> <span class="n">scaled_xy</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec2</span> <span class="n">screen_uv</span> <span class="o">=</span> <span class="n">uv_nearest</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">resolution</span> <span class="o">/</span> <span class="n">resolution_scale</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">world_pos</span> <span class="o">=</span> <span class="n">world_position_from_depth</span><span class="p">(</span><span class="n">screen_uv</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">inverse_view_projection</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">normal</span> <span class="o">=</span> <span class="n">octahedral_decode</span><span class="p">(</span><span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">gbuffer_texures</span><span class="p">.</span><span class="n">y</span><span class="p">],</span> <span class="n">scaled_xy</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">rg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">incoming</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">world_pos</span> <span class="o">-</span> <span class="n">camera_position</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span> <span class="c1">// 观察方向</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 生成两个[0,1]的随机数，用于重要性采样。</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec2</span> <span class="n">U</span> <span class="o">=</span> <span class="n">interleaved_gradient_noise2</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">current_frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 使用GGX-VNDF采样，根据粗糙度生成一个微表面法线。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 这比简单的reflect(incoming, normal)更物理正确，能表现粗糙表面的模糊反射。</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">vndf_normal</span> <span class="o">=</span> <span class="n">sampleGGXVNDF</span><span class="p">(</span><span class="n">incoming</span><span class="p">,</span> <span class="n">roughness</span><span class="p">,</span> <span class="n">roughness</span><span class="p">,</span> <span class="n">U</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">U</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 基于采样的微表面法线，计算出最终的反射光线方向。</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">reflected_ray</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">reflect</span><span class="p">(</span><span class="n">incoming</span><span class="p">,</span> <span class="n">vndf_normal</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 3. 追踪主反射光线 ---</span>
</span></span><span class="line"><span class="cl">        <span class="n">traceRayEXT</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">gl_RayFlagsOpaqueEXT</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">sbt_offset</span><span class="p">,</span> <span class="n">sbt_stride</span><span class="p">,</span> <span class="n">miss_index</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">world_pos</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">reflected_ray</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// --- 4. 处理光线命中结果 ---</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果 payload.geometry_id 不是-1，说明光线命中了场景中的某个物体。</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="n">geometry_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// --- 4a. 手动获取命中点的几何与材质信息 ---</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 根据payload中的信息，反向查找顶点、索引、UV等数据。</span>
</span></span><span class="line"><span class="cl">            <span class="n">MeshInstanceDraw</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">mesh_instance_draws</span><span class="p">[</span><span class="n">payload</span><span class="p">.</span><span class="n">geometry_id</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">MeshDraw</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh_draws</span><span class="p">[</span><span class="n">instance</span><span class="p">.</span><span class="n">mesh_draw_index</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// ... [省略了繁琐的从全局Buffer中读取顶点和UV的代码] ...</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 使用重心坐标插值，计算出命中点的精确UV坐标。</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">b</span> <span class="o">=</span> <span class="n">payload</span><span class="p">.</span><span class="n">barycentric_weights</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">c</span> <span class="o">=</span> <span class="n">payload</span><span class="p">.</span><span class="n">barycentric_weights</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">b</span> <span class="o">-</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec2</span> <span class="n">uv</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">uv0</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">uv1</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">uv2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 计算命中点的世界坐标。</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">p_world</span> <span class="o">=</span> <span class="n">world_pos</span> <span class="o">+</span> <span class="n">reflected_ray</span> <span class="o">*</span> <span class="n">payload</span><span class="p">.</span><span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 手动计算命中三角形的法线。</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">triangle_normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">cross</span><span class="p">(</span><span class="n">p1_world</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">p0_world</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">p2_world</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">p0_world</span><span class="p">.</span><span class="n">xyz</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// --- 4b. 在命中点进行直接光照计算 (Many-Light Sampling) ---</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 这是一个高级优化：当场景中有很多光源时，为每个点计算所有光源的光照开销巨大。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 这里采用重要性采样，根据每个光源对当前点的“重要性”（亮度、距离、角度），</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 随机选择一个光源进行计算。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 第一轮循环：计算每个光源的“重要性” (importance)。</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">lights_importance</span><span class="p">[</span><span class="n">NUM_LIGHTS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">total_importance</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">l</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">active_lights</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// importance 综合了光源强度、距离衰减和方向衰减。</span>
</span></span><span class="line"><span class="cl">                <span class="n">lights_importance</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">calculate_light_importance</span><span class="p">(...);</span>
</span></span><span class="line"><span class="cl">                <span class="n">total_importance</span> <span class="o">+=</span> <span class="n">lights_importance</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 第二轮循环：根据随机数和重要性分布，选中一个光源。</span>
</span></span><span class="line"><span class="cl">            <span class="n">uint</span> <span class="n">light_index</span> <span class="o">=</span> <span class="n">select_light_based_on_importance</span><span class="p">(...);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// --- 4c. 追踪阴影光线 (Shadow Ray) ---</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">light_index</span> <span class="o">&lt;</span> <span class="n">active_lights</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">Light</span> <span class="n">light</span> <span class="o">=</span> <span class="n">lights</span><span class="p">[</span><span class="n">light_index</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="k">vec3</span> <span class="n">l</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">world_position</span> <span class="o">-</span> <span class="n">p_world</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">float</span> <span class="n">light_distance</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">world_position</span> <span class="o">-</span> <span class="n">p_world</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// 从命中点向选中的光源发射一条光线，检查是否有遮挡。</span>
</span></span><span class="line"><span class="cl">                <span class="n">traceRayEXT</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">gl_RayFlagsOpaqueEXT</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">sbt_offset</span><span class="p">,</span> <span class="n">sbt_stride</span><span class="p">,</span> <span class="n">miss_index</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="n">p_world</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">light_distance</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                
</span></span><span class="line"><span class="cl">                <span class="c1">// 如果 payload.geometry_id 为-1，说明阴影光线未被遮挡。</span>
</span></span><span class="line"><span class="cl">                <span class="k">float</span> <span class="n">shadow_term</span> <span class="o">=</span> <span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="n">geometry_id</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mf">1.0</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// --- 4d. 计算最终PBR光照颜色 ---</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 计算衰减和 Lambertian 项 (NoL)。</span>
</span></span><span class="line"><span class="cl">                <span class="k">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="n">attenuation_square_falloff</span><span class="p">(...)</span> <span class="o">*</span> <span class="n">shadow_term</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">float</span> <span class="n">NoL</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">triangle_normal</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">attenuation</span> <span class="o">&gt;</span> <span class="mf">0.0001</span><span class="n">f</span> <span class="o">&amp;&amp;</span> <span class="n">NoL</span> <span class="o">&gt;</span> <span class="mf">0.0001</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// 获取命中点的PBR材质参数（金属度、粗糙度等）。</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// ...</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// 计算最终的光照贡献。</span>
</span></span><span class="line"><span class="cl">                    <span class="k">vec4</span> <span class="n">albedo</span> <span class="o">=</span> <span class="n">textureLod</span><span class="p">(...);</span>
</span></span><span class="line"><span class="cl">                    <span class="n">reflection_color</span> <span class="o">=</span> <span class="n">albedo</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">intensity</span> <span class="o">*</span> <span class="n">attenuation</span> <span class="o">*</span> <span class="n">NoL</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// --- 4e. 添加间接光照贡献 ---</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 从光照探针或类似结构中采样间接光照。</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">indirect_color</span> <span class="o">=</span> <span class="n">sample_irradiance</span><span class="p">(</span><span class="n">p_world</span><span class="p">,</span> <span class="n">triangle_normal</span><span class="p">,</span> <span class="n">camera_position</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">reflection_color</span> <span class="o">+=</span> <span class="n">indirect_color</span> <span class="o">*</span> <span class="n">albedo</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 5. 写入最终结果 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将计算出的反射颜色写入到输出图像中。</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">global_images_2d</span><span class="p">[</span><span class="n">out_image_index</span><span class="p">],</span> <span class="n">xy</span><span class="p">,</span> <span class="k">vec4</span><span class="p">(</span><span class="n">reflection_color</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="最近命中与未命中着色器-closest-hit--miss-shaders">
<a class="header-anchor" href="#%e6%9c%80%e8%bf%91%e5%91%bd%e4%b8%ad%e4%b8%8e%e6%9c%aa%e5%91%bd%e4%b8%ad%e7%9d%80%e8%89%b2%e5%99%a8-closest-hit--miss-shaders"></a>
最近命中与未命中着色器 (Closest-Hit &amp; Miss Shaders)
</h3><p>这两个着色器的作用非常简单：它们在 <code>traceRayEXT</code> 函数执行过程中被调用，其唯一目的就是填充 <code>RayPayload</code> 结构体，将结果返回给调用者（Ray Generation Shader）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// 当光线命中物体时，此着色器被调用。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mo">0</span><span class="p">)</span> <span class="n">rayPayloadInEXT</span> <span class="n">RayPayload</span> <span class="n">payload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">hitAttributeEXT</span> <span class="k">vec2</span> <span class="n">barycentric_weights</span><span class="p">;</span> <span class="c1">// 由硬件提供的重心坐标插值</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将命中的几何体ID、图元ID、重心坐标、变换矩阵、距离等信息</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 全部打包到 payload 结构体中，以供光线生成着色器后续使用。</span>
</span></span><span class="line"><span class="cl">    <span class="n">payload</span><span class="p">.</span><span class="n">geometry_id</span>       <span class="o">=</span> <span class="n">gl_GeometryIndexEXT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">payload</span><span class="p">.</span><span class="n">primitive_id</span>      <span class="o">=</span> <span class="n">gl_PrimitiveID</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">payload</span><span class="p">.</span><span class="n">barycentric_weights</span> <span class="o">=</span> <span class="n">barycentric_weights</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">payload</span><span class="p">.</span><span class="n">object_to_world</span>   <span class="o">=</span> <span class="n">gl_ObjectToWorldEXT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">payload</span><span class="p">.</span><span class="n">t</span>                 <span class="o">=</span> <span class="n">gl_HitTEXT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">payload</span><span class="p">.</span><span class="n">triangle_facing</span>   <span class="o">=</span> <span class="n">gl_HitKindEXT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 当光线未命中任何物体时，此着色器被调用。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mo">0</span><span class="p">)</span> <span class="n">rayPayloadInEXT</span> <span class="n">RayPayload</span> <span class="n">payload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将 geometry_id 设置为一个特殊值（-1），</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 作为一个标记，告诉光线生成着色器“此次追踪未命中”。</span>
</span></span><span class="line"><span class="cl">    <span class="n">payload</span><span class="p">.</span><span class="n">geometry_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="核心原理与关键技术">
<a class="header-anchor" href="#%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%85%b3%e9%94%ae%e6%8a%80%e6%9c%af"></a>
核心原理与关键技术
</h3><h4 id="基于物理的反射与-ggx-vndf-采样">
<a class="header-anchor" href="#%e5%9f%ba%e4%ba%8e%e7%89%a9%e7%90%86%e7%9a%84%e5%8f%8d%e5%b0%84%e4%b8%8e-ggx-vndf-%e9%87%87%e6%a0%b7"></a>
基于物理的反射与 GGX-VNDF 采样
</h4><p>为了渲染出逼真的粗糙表面（如拉丝金属、磨砂塑料），简单的镜面反射 <code>reflect()</code> 函数是不够的。现代 PBR（Physically Based Rendering）理论将表面建模为由大量微小的镜面组成的<strong>微表面 (Microfacet)</strong>。</p>
<p><strong>GGX-VNDF 采样</strong>: 不是采样一个随机的微观法线，而是智能地采样一个<strong>既符合GGX分布，又对观察者可见</strong>的法线。这能极大地减少噪点，用更少的光线样本收敛到更准确的模糊反射效果。最终的 <code>reflected_ray</code> 因此具有了基于物理的、与粗糙度匹配的模糊方向。</p>
<p><code>sampleGGXVNDF</code>函数是实现基于物理的粗糙反射 (Physically Based Rough Reflections) 的关键。它的目标不是简单地进行镜面反射，而是根据 GGX 微表面模型的分布，智能地采样一个对最终结果贡献最大的微表面法线 (<code>vndf_normal</code>)。</p>
<p>一个“粗糙”的表面在微观上是由无数个朝向各异的微小镜面组成的。当光线射到这样的表面上时，会向多个方向散射，形成模糊的反射效果。<code>sampleGGXVNDF</code> 的作用就是重要性采样 (Importance Sampling)：它根据物理模型，优先采样那些最有可能将光线反射到观察者眼中的微表面法线，从而用极少数的光线样本，高效地模拟出逼真的模糊反射，并大幅减少噪点。</p>
<p>该函数的实现遵循了论文 <em>“<a href="https://jcgt.org/published/0007/04/01/paper.pdf">Sampling the GGX Distribution of Visible Normals (VNDF)</a>”</em> 中的步骤。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// Input Ve:  观察方向（View Direction）</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Input alpha_x, alpha_y: 对应x和y轴的粗糙度</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Input U1, U2: 两个 [0,1] 范围内的均匀随机数</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Output Ne: 采样出的、符合物理模型的微表面法线</span>
</span></span><span class="line"><span class="cl"><span class="k">vec3</span> <span class="n">sampleGGXVNDF</span><span class="p">(</span><span class="k">vec3</span> <span class="n">Ve</span><span class="p">,</span> <span class="k">float</span> <span class="n">alpha_x</span><span class="p">,</span> <span class="k">float</span> <span class="n">alpha_y</span><span class="p">,</span> <span class="k">float</span> <span class="n">U1</span><span class="p">,</span> <span class="k">float</span> <span class="n">U2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 步骤 1: 将观察方向变换到“半球空间” ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 为了简化采样数学模型，我们将各向异性的椭球体GGX分布，通过缩放“拉伸”成一个完美的半球形分布。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Ve 是观察方向，这里将其变换到这个虚拟的“拉伸空间”中。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">Vh</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="k">vec3</span><span class="p">(</span><span class="n">alpha_x</span> <span class="o">*</span> <span class="n">Ve</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha_y</span> <span class="o">*</span> <span class="n">Ve</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">Ve</span><span class="p">.</span><span class="n">z</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 步骤 2: 构建局部坐标系 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 以变换后的观察方向 Vh 为 Z 轴，构建一个局部坐标系（T1, T2, Vh）。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 所有的采样将在这个方便的局部坐标系中进行。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">lensq</span> <span class="o">=</span> <span class="n">Vh</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">Vh</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">Vh</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">Vh</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">T1</span> <span class="o">=</span> <span class="n">lensq</span> <span class="o">&gt;</span> <span class="mo">0</span> <span class="o">?</span> <span class="k">vec3</span><span class="p">(</span><span class="o">-</span><span class="n">Vh</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">Vh</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mo">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">inversesqrt</span><span class="p">(</span><span class="n">lensq</span><span class="p">)</span> <span class="o">:</span> <span class="k">vec3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mo">0</span><span class="p">,</span><span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">Vh</span><span class="p">,</span> <span class="n">T1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 步骤 3: 在2D投影面上采样 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这是算法的精髓。它将两个均匀的随机数 U1, U2 映射到 Vh 向量所“看”到的</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 微表面法线投影圆盘上的一个点 (t1, t2)。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这个映射不是简单的均匀映射，而是经过精心设计的，以匹配可见法线分布的形状。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">r</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">U1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">phi</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">PI</span> <span class="o">*</span> <span class="n">U2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">s</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">Vh</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t2</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">t1</span><span class="o">*</span><span class="n">t1</span><span class="p">)</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">t2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 步骤 4: 从2D投影点反算回3D法线 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将2D采样点 (t1, t2) 从投影圆盘上“提拉”回半球表面，得到在局部坐标系中的采样法线 Nh。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">Nh</span> <span class="o">=</span> <span class="n">t1</span><span class="o">*</span><span class="n">T1</span> <span class="o">+</span> <span class="n">t2</span><span class="o">*</span><span class="n">T2</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">t1</span><span class="o">*</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t2</span><span class="o">*</span><span class="n">t2</span><span class="p">))</span><span class="o">*</span><span class="n">Vh</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 步骤 5: 将法线变换回“椭球空间” ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将在“拉伸空间”中采样到的法线 Nh，通过逆向的缩放操作，变换回原始的、</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 符合各向异性GGX分布的椭球空间，得到最终的微表面法线 Ne。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">Ne</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="k">vec3</span><span class="p">(</span><span class="n">alpha_x</span> <span class="o">*</span> <span class="n">Nh</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha_y</span> <span class="o">*</span> <span class="n">Nh</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">Nh</span><span class="p">.</span><span class="n">z</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Ne</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>最终，这个 <code>Ne</code> (vndf_normal) 会被用于 <code>reflect()</code> 函数，生成一条高度符合物理规律的反射光线。</p>
<h4 id="光源重要性采样-many-light-importance-sampling">
<a class="header-anchor" href="#%e5%85%89%e6%ba%90%e9%87%8d%e8%a6%81%e6%80%a7%e9%87%87%e6%a0%b7-many-light-importance-sampling"></a>
光源重要性采样 (Many-Light Importance Sampling)
</h4><p>在有成百上千个光源的复杂场景中，如果每个反射点都计算所有光源的直接光照，性能开销将是灾难性的。</p>
<ul>
<li><strong>技术原理</strong>: 该着色器采用了一种类似 &ldquo;<a href="https://research.nvidia.com/labs/rtr/publication/moreau2019manylight_rtg/">Importance Sampling of Many Lights on the GPU</a>&rdquo; 的技术。
<ol>
<li><strong>计算重要性</strong>: 遍历所有光源，根据光源的<strong>强度 (Intensity)</strong>、<strong>距离 (Distance)</strong> 和<strong>方向 (Orientation)</strong>，为每个光源计算一个“重要性”权重。一个离得近、亮度高且正对着命中点表面的光源，其重要性就高。</li>
<li><strong>随机选择</strong>: 将所有重要性归一化，形成一个概率分布函数 (PDF)。然后生成一个随机数，根据这个PDF随机选择<strong>一个</strong>光源。</li>
<li><strong>计算光照</strong>: 只为这一个被选中的光源计算阴影和光照贡献。虽然单次计算有偏差，但在多个像素、多帧上进行蒙特卡洛积分，最终结果会收敛到正确的全局光照效果，同时性能开销极低。</li>
</ol>
</li>
</ul>
<h4 id="手动属性获取与lod计算">
<a class="header-anchor" href="#%e6%89%8b%e5%8a%a8%e5%b1%9e%e6%80%a7%e8%8e%b7%e5%8f%96%e4%b8%8elod%e8%ae%a1%e7%ae%97"></a>
手动属性获取与LOD计算
</h4><p>与一些简单的光追教程不同，这里的最近命中着色器（Closest-Hit）非常“轻量”，只负责传递ID和坐标。所有复杂的材质和几何属性获取（如UV、顶点位置）都在光线生成着色器中<strong>手动完成</strong>。</p>
<ul>
<li><strong>设计选择</strong>: 这是一种设计模式。它将复杂的着色逻辑（PBR计算、多光源采样等）集中在Ray Generation Shader中，简化了Shader Binding Table (SBT) 的管理，但代价是需要在RayGen中编写大量手动获取和插值数据的代码。</li>
<li><strong>手动LOD</strong>: <code>float lod = 0.5 * log2( texel_area / triangle_area )</code> 是一个经典的<strong>纹理细节层次 (LOD)</strong> 计算方法。它通过比较纹理在纹理空间中的面积与它在屏幕空间中的投影面积的比率，来估算应该采样哪个 Mipmap 级别，有效防止了纹理在远处产生摩尔纹（Moiré pattern）并提升了纹理缓存的效率。</li>
</ul>
<p>如果不计算LOD，直接用最高精度的 Mipmap 0 级去采样，当一个布满精细纹理的表面被投影到远处很小的几个像素上时，就会发生<strong>纹理混叠 (Texture Aliasing)</strong>，产生闪烁和摩尔纹。正确的LOD可以根据物体在屏幕上的大小，选择合适的 Mipmap 等级进行采样，既能抗锯齿，又能提升纹理缓存的命中率。</p>
<p>该方法通过计算 <strong>“纹素(texel)到像素(pixel)的面积比”</strong> 来估算LOD。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// --- 步骤 1: 计算命中三角形在“纹理空间”中的面积 ---</span>
</span></span><span class="line"><span class="cl"><span class="c1">// abs(...)这部分是利用顶点叉乘的几何意义计算三角形面积的2D版本。</span>
</span></span><span class="line"><span class="cl"><span class="c1">// (uv1 - uv0) 和 (uv2 - uv0) 是三角形在UV空间的两条边向量。</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 这里的计算结果是三角形在 [0,1] UV空间中所占面积的两倍。</span>
</span></span><span class="line"><span class="cl"><span class="k">float</span> <span class="n">uv_area</span> <span class="o">=</span> <span class="n">abs</span><span class="p">((</span><span class="n">uv1</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">uv0</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">uv2</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">uv0</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">uv2</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">uv0</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">uv1</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">uv0</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 将UV空间面积乘以纹理的实际尺寸，得到三角形覆盖的总“纹素(texel)”数量。</span>
</span></span><span class="line"><span class="cl"><span class="k">float</span> <span class="n">texel_area</span> <span class="o">=</span> <span class="n">texture_size</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">texture_size</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">uv_area</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// --- 步骤 2: 计算命中三角形在“屏幕空间”中的面积 ---</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用完全相同的公式，但输入的是三角形顶点在屏幕上的投影坐标。</span>
</span></span><span class="line"><span class="cl"><span class="c1">// (p1_screen, p0_screen, p2_screen)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 计算出三角形在屏幕上覆盖的“像素(pixel)”数量。</span>
</span></span><span class="line"><span class="cl"><span class="k">float</span> <span class="n">triangle_area</span> <span class="o">=</span> <span class="n">abs</span><span class="p">((</span><span class="n">p1_screen</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">p0_screen</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">p2_screen</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">p0_screen</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">p2_screen</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">p0_screen</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">p1_screen</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">p0_screen</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// --- 步骤 3: 根据面积比计算LOD ---</span>
</span></span><span class="line"><span class="cl"><span class="c1">// texel_area / triangle_area 就是“每个像素对应多少个纹素”的比率，即纹素密度。</span>
</span></span><span class="line"><span class="cl"><span class="c1">// - 如果比值 &gt;&gt; 1: 说明纹理被急剧缩小（minification），需要使用更高（更模糊）的Mipmap等级。</span>
</span></span><span class="line"><span class="cl"><span class="c1">// - 如果比值 &lt;&lt; 1: 说明纹理被放大（magnification），应该使用更低（更清晰）的Mipmap等级。</span>
</span></span><span class="line"><span class="cl"><span class="c1">//</span>
</span></span><span class="line"><span class="cl"><span class="c1">// log2: Mipmap的等级是按2的对数关系组织的，所以用log2来转换。</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 0.5 *: 面积是长度的平方，而LOD与长度成正比。log2(Area) = log2(Length^2) = 2*log2(Length)。</span>
</span></span><span class="line"><span class="cl"><span class="c1">//         所以需要乘以0.5来抵消这个平方关系。</span>
</span></span><span class="line"><span class="cl"><span class="k">float</span> <span class="n">lod</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">log2</span><span class="p">(</span><span class="n">texel_area</span> <span class="o">/</span> <span class="n">triangle_area</span><span class="p">));</span>
</span></span></code></pre></div><p>这个 <code>lod</code> 值最终会被传递给 <code>textureLod</code> 函数，以精确的 Mipmap 等级进行纹理采样，从而获得高质量、无锯齿的纹理外观。</p>
<h2 id="svgf-降噪">
<a class="header-anchor" href="#svgf-%e9%99%8d%e5%99%aa"></a>
SVGF 降噪
</h2><h3 id="accumulation-pass">
<a class="header-anchor" href="#accumulation-pass"></a>
Accumulation Pass
</h3><p>这个着色器是 <strong>SVGF (Spatiotemporal Variance-Guided Filtering)</strong> 降噪算法中的<strong>时间累积 (Temporal Accumulation)</strong> 阶段。它的核心任务是将当前帧带有噪点的反射颜色，与前几帧积累的、相对干净的颜色历史进行混合，从而在时间维度上平滑噪点。</p>
<p>为了防止混合出错（例如，将墙壁的颜色历史混合到移动的角色上），这个阶段花费了大量精力去进行<strong>时间一致性检查 (Temporal Consistency Check)</strong>，只有在确认当前像素和它在上一帧的对应像素属于同一个物体表面时，才会进行混合。</p>
<p>混合后的颜色
<img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507202050802.png" alt="integrated_reflection_color"></p>
<p>混合后的矩
<img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507202050674.png" alt="integrated_reflection_moments"></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// ... [此处省略 check_temporal_consistency 函数的定义] ...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义工作组大小 8x8</span>
</span></span><span class="line"><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 1. 读取输入并计算矩 (Moments) ---</span>
</span></span><span class="line"><span class="cl">    <span class="n">uvec2</span> <span class="n">frag_coord</span> <span class="o">=</span> <span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 读取当前帧由光追计算出的、带有噪点的原始反射颜色。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">reflections_color</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">reflections_texture_index</span><span class="p">],</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">frag_coord</span><span class="p">),</span> <span class="mo">0</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算颜色亮度的“一阶矩”和“二阶矩”。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这是为后续空间滤波阶段计算“方差”做准备。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">u_1</span> <span class="o">=</span> <span class="n">luminance</span><span class="p">(</span><span class="n">reflections_color</span><span class="p">);</span> <span class="c1">// 一阶矩 (均值)</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">u_2</span> <span class="o">=</span> <span class="n">u_1</span> <span class="o">*</span> <span class="n">u_1</span><span class="p">;</span>                    <span class="c1">// 二阶矩的一部分</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">moments</span> <span class="o">=</span> <span class="k">vec2</span><span class="p">(</span><span class="n">u_1</span><span class="p">,</span> <span class="n">u_2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 2. 执行时间一致性检查 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用辅助函数，判断当前像素是否有有效的、可供复用的历史数据。</span>
</span></span><span class="line"><span class="cl">    <span class="k">bool</span> <span class="n">is_consistent</span> <span class="o">=</span> <span class="n">check_temporal_consistency</span><span class="p">(</span><span class="n">frag_coord</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 3. 条件性时间累积 ---</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">integrated_color_out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">integrated_moments_out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 分支 A：如果历史数据一致、有效</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">is_consistent</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 读取上一帧累积的颜色和矩</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">history_reflections_color</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">history_reflections_texture_index</span><span class="p">],</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">frag_coord</span><span class="p">),</span> <span class="mo">0</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec2</span> <span class="n">history_moments</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">history_moments_texture_index</span><span class="p">],</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">frag_coord</span><span class="p">),</span> <span class="mo">0</span><span class="p">).</span><span class="n">rg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 使用一个混合因子 alpha，将当前帧的数据与历史数据进行指数移动平均 (Exponential Moving Average)。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// alpha 较小，意味着更信任历史数据，画面更稳定但可能产生拖影；alpha 较大则相反。</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">integrated_color_out</span> <span class="o">=</span> <span class="n">mix</span><span class="p">(</span><span class="n">history_reflections_color</span><span class="p">,</span> <span class="n">reflections_color</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">integrated_moments_out</span> <span class="o">=</span> <span class="n">mix</span><span class="p">(</span><span class="n">history_moments</span><span class="p">,</span> <span class="n">moments</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 分支 B：如果历史数据不一致（例如发生遮挡）</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 丢弃无效的历史数据，直接使用当前帧的原始颜色和矩。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 这相当于重置(reset)了该像素的时间累积。</span>
</span></span><span class="line"><span class="cl">        <span class="n">integrated_color_out</span> <span class="o">=</span> <span class="n">reflections_color</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">integrated_moments_out</span> <span class="o">=</span> <span class="n">moments</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 4. 写入输出 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将本轮累积后的颜色和矩写入到新的纹理中，供下一阶段（空间滤波）使用。</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">global_images_2d</span><span class="p">[</span><span class="n">integrated_color_texture_index</span><span class="p">],</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">frag_coord</span><span class="p">),</span> <span class="k">vec4</span><span class="p">(</span><span class="n">integrated_color_out</span><span class="p">,</span> <span class="mo">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">global_images_2d</span><span class="p">[</span><span class="n">integrated_moments_texture_index</span><span class="p">],</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">frag_coord</span><span class="p">),</span> <span class="k">vec4</span><span class="p">(</span><span class="n">integrated_moments_out</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief  检查当前像素在时间上是否与前一帧连续。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param  frag_coord 当前像素的屏幕坐标。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return bool 如果历史数据有效且可复用，返回true。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">bool</span> <span class="n">check_temporal_consistency</span><span class="p">(</span><span class="n">uvec2</span> <span class="n">frag_coord</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 1. 时间重投影 (Temporal Reprojection) ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 读取当前像素的运动矢量。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">motion_vector</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">motion_vectors_texture_index</span><span class="p">],</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">frag_coord</span><span class="p">),</span> <span class="mo">0</span><span class="p">).</span><span class="n">rg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 根据运动矢量，计算出当前像素在上一帧的屏幕坐标 (prev_frag_coord)。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">prev_frag_coord</span> <span class="o">=</span> <span class="k">vec2</span><span class="p">(</span><span class="n">frag_coord</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">motion_vector</span> <span class="o">*</span> <span class="n">resolution_scale</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 2. 边界与物体ID检查 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 检查历史坐标是否超出屏幕范围。</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">any</span><span class="p">(</span><span class="n">lessThan</span><span class="p">(</span><span class="n">prev_frag_coord</span><span class="p">,</span> <span class="k">vec2</span><span class="p">(</span><span class="mo">0</span><span class="p">)))</span> <span class="o">||</span> <span class="n">any</span><span class="p">(</span><span class="n">greaterThanEqual</span><span class="p">(</span><span class="n">prev_frag_coord</span><span class="p">,</span> <span class="n">resolution</span> <span class="o">*</span> <span class="n">resolution_scale</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 检查当前像素与历史像素是否属于同一个物体。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这是最强的剔除标准之一，可以有效防止前景物体移开时，背景错误地复用前景的颜色历史（鬼影）。</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">mesh_id</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_utextures</span><span class="p">[</span><span class="n">mesh_id_texture_index</span><span class="p">],</span> <span class="p">...,</span> <span class="mo">0</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">prev_mesh_id</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_utextures</span><span class="p">[</span><span class="n">history_mesh_id_texture_index</span><span class="p">],</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">prev_frag_coord</span><span class="p">),</span> <span class="mo">0</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">mesh_id</span> <span class="o">!=</span> <span class="n">prev_mesh_id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 3. 深度与法线检查 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 为了处理物体内部的形变或视角变化，还需要比较几何属性。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">z</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">linear_z_dd_texture_index</span><span class="p">],</span> <span class="p">...,</span> <span class="mo">0</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">prev_z</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">history_linear_depth_texture</span><span class="p">],</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">prev_frag_coord</span><span class="p">),</span> <span class="mo">0</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算深度差异。如果差异过大，认为历史无效。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">depth_diff</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">prev_z</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">depth_normal_fwidth</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">depth_diff</span> <span class="o">&gt;</span> <span class="n">temporal_depth_difference</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">normal</span> <span class="o">=</span> <span class="p">...;</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">prev_normal</span> <span class="o">=</span> <span class="p">...;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算法线差异。如果法线夹角过大，认为历史无效。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">normal_diff</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">prev_normal</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">depth_normal_fwidth</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">normal_diff</span> <span class="o">&gt;</span> <span class="n">temporal_normal_difference</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 所有检查都通过，返回true。</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="核心原理与关键技术-1">
<a class="header-anchor" href="#%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%85%b3%e9%94%ae%e6%8a%80%e6%9c%af-1"></a>
核心原理与关键技术
</h4><h5 id="时间累积与历史拒绝-temporal-accumulation--history-rejection">
<a class="header-anchor" href="#%e6%97%b6%e9%97%b4%e7%b4%af%e7%a7%af%e4%b8%8e%e5%8e%86%e5%8f%b2%e6%8b%92%e7%bb%9d-temporal-accumulation--history-rejection"></a>
时间累积与历史拒绝 (Temporal Accumulation &amp; History Rejection)
</h5><ul>
<li><strong>指数移动平均 (Exponential Moving Average)</strong>: <code>integrated_color_out = mix(history, current, alpha)</code> 这行代码是时间累积的核心。它不是简单地取平均，而是给予当前帧一个固定的权重 <code>alpha</code>，历史一个 <code>1 - alpha</code> 的权重。这种方式可以在平滑噪声的同时，让画面能逐渐响应光照变化。</li>
<li><strong>鲁棒的历史拒绝</strong>: <code>check_temporal_consistency</code> 函数是该算法鲁棒性的关键。一个糟糕的时间降噪器会在物体移动时产生大量<strong>鬼影 (Ghosting)</strong>。通过依次检查<strong>物体ID</strong>、<strong>深度</strong>和<strong>法线</strong>，SVGF 能非常精确地判断历史数据是否可用，一旦判断为不可用（例如，角色跑开露出了后面的墙），就果断丢弃历史（<code>else</code> 分支），从而极大地抑制了鬼影。</li>
</ul>
<p>Mesh ID
<img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507202009435.png" alt=""></p>
<h5 id="基于矩的方差估计-moment-based-variance-estimation">
<a class="header-anchor" href="#%e5%9f%ba%e4%ba%8e%e7%9f%a9%e7%9a%84%e6%96%b9%e5%b7%ae%e4%bc%b0%e8%ae%a1-moment-based-variance-estimation"></a>
基于矩的方差估计 (Moment-based Variance Estimation)
</h5><p>SVGF 的一个精妙之处在于它指导空间滤波的方式。它需要知道一个像素邻域内的颜色<strong>方差 (Variance)</strong>，方差越大说明噪声越多。</p>
<ul>
<li><strong>矩 (Moments)</strong>: 直接在邻域内计算方差开销很大。SVGF 采用了一种更高效的方法：在时间累积阶段，顺便累积颜色亮度的一阶矩（就是亮度本身 $E[X]$）和二阶矩（亮度的平方 $E[X^2]$）。</li>
<li><strong>方差公式</strong>: 根据统计学公式，方差可以由这两个矩计算得出：
$$\sigma^2 = E[X^2] - (E[X])^2
    $$
在本 Pass 中，<code>integrated_moments_out</code> 的 <code>.x</code> 分量存储了累积后的 $E[X]$，<code>.y</code> 分量存储了累积后的 $E[X^2]$。在后续的空间滤波 Pass 中，可以直接利用这些预计算好的值，快速估算出像素邻域的方差，从而决定模糊的强度。</li>
</ul>
<h5 id="使用fwidth自适应设置阈值">
<a class="header-anchor" href="#%e4%bd%bf%e7%94%a8fwidth%e8%87%aa%e9%80%82%e5%ba%94%e8%ae%be%e7%bd%ae%e9%98%88%e5%80%bc"></a>
使用<code>fwidth</code>自适应设置阈值
</h5><p><code>depth_normal_fwidth = vec2(length(fwidth(world_position)), length(fwidth(normal)));</code></p>
<p><code>depth_normal_fwidth</code> 是一个预先计算好的 <code>vec2</code> 数据，它存储了每个像素的<strong>几何复杂度</strong>信息。</p>
<p>这个值通常是在一个单独的 Pass 中，通过对线性深度图和法线图应用 GLSL 的 <code>fwidth()</code> 函数来计算并存入一张纹理中的。<code>fwidth(p)</code> 函数会计算变量 <code>p</code> 在屏幕空间中相邻像素间的变化量总和，是衡量一个值变化有多“剧烈”的有效指标。</p>
<p><code>depth_normal_fwidth</code> 的核心作用是<strong>让时间一致性检查的阈值变得自适应 (Adaptive)，从而更“智能”地判断历史数据是否有效</strong>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="k">float</span> <span class="n">depth_diff</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">prev_z</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">depth_normal_fwidth</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">depth_diff</span> <span class="o">&gt;</span> <span class="n">temporal_depth_difference</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li><strong>当表面平坦、正对相机时</strong>: <code>depth_normal_fwidth.x</code> 的值非常小。这时分母很小，即使一个微小的 <code>abs(prev_z - z)</code> 也会导致 <code>depth_diff</code> 变得很大。这使得检查在这种区域<strong>非常敏感和严格</strong>，能捕捉到最细微的不连续。</li>
<li><strong>当表面是斜坡或曲面时</strong>: <code>depth_normal_fwidth.x</code> 的值很大。这时分母很大，即使 <code>abs(prev_z - z)</code> 较大，也会被这个大的分母“稀释”，使得最终的 <code>depth_diff</code> 保持在一个较小的范围内。这使得检查在这种区域<strong>非常宽松和容忍</strong>，允许因透视和曲率产生的正常深度变化，而不会错误地丢弃历史。</li>
</ul>
<p>对法线的检查 <code>normal_diff</code> 也是完全相同的道理。</p>
<p>综上所述，<code>depth_normal_fwidth</code> 通过提供一个对局部几何复杂度的衡量，将一个“一刀切”的固定阈值，升级为了一个能适应不同表面特性的、高度鲁棒的动态阈值。</p>
<h3 id="variance-pass">
<a class="header-anchor" href="#variance-pass"></a>
Variance Pass
</h3><p>它的唯一职责就是接收前一阶段累积的颜色“矩”，并用一个简单的统计学公式计算出每个像素的亮度方差。</p>
<p>这张最终生成的“方差图”就像一张“噪点地图”，它会精确地告诉最后一个 Pass（空间滤波）：“图中越亮的地方，噪点越多，你需要更用力地去模糊！”</p>
<p><img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507202112239.png" alt=""></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief  根据累积的颜色矩，计算亮度方差。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @details
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 该计算着色器是 SVGF 流程中的一步。它接收由时间累积 Pass
</span></span></span><span class="line"><span class="cl"><span class="cm"> * (COMPUTE_SVGF_ACCUMULATION) 生成的“矩”纹理，并应用统计学公式
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Variance = E[X^2] - (E[X])^2 来计算每个像素亮度的方差。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 输出的方差图将作为下一阶段空间滤波强度的指导图。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义工作组大小 8x8</span>
</span></span><span class="line"><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 1. 获取像素坐标并读取累积的矩 ---</span>
</span></span><span class="line"><span class="cl">    <span class="n">uvec2</span> <span class="n">frag_coord</span> <span class="o">=</span> <span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 从上一 Pass 输出的纹理中，读取时间累积后的“颜色矩”。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// moments.x 存储的是亮度的一阶矩 (均值, E[X])。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// moments.y 存储的是亮度的二阶矩 (平方的均值, E[X^2])。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">moments</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">integrated_moments_texture_index</span><span class="p">],</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">frag_coord</span><span class="p">),</span> <span class="mo">0</span><span class="p">).</span><span class="n">rg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果历史无效，则可以通过对邻域进行双边滤波来重新估算一个临时的方差。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 2. 计算方差 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 应用核心统计学公式：方差 = 平方的期望 - 期望的平方。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">variance</span> <span class="o">=</span> <span class="n">moments</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">pow</span><span class="p">(</span><span class="n">moments</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 3. 存储方差结果 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将计算出的方差值写入到一张新的“方差图”纹理中。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这张图将在后续的空间滤波 Pass 中被用作指导。</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">global_images_2d</span><span class="p">[</span><span class="n">variance_texture_index</span><span class="p">],</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">frag_coord</span><span class="p">),</span> <span class="k">vec4</span><span class="p">(</span><span class="n">variance</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol>
<li><strong>读取输入</strong>：对于屏幕上的每一个像素，它首先从 <code>integrated_moments_texture_index</code> 纹理中读取一个 <code>vec2</code> 数据。这个数据是前一个 Accumulation Pass 的输出，包含了经过时间累积（与历史数据混合）后的颜色亮度的“一阶矩”和“二阶矩”。</li>
<li><strong>计算方差</strong>：它应用 <code>variance = moments.y - pow(moments.x, 2);</code> 这个公式。这行代码是整个着色器的核心，它将两个矩值转换为了一个统计学上有效的方差值。</li>
<li><strong>写入输出</strong>：最后，它将计算出的 <code>variance</code> 值存入一张新的单通道纹理中。这张纹理就是“方差指导图”，供下一个也是最后一个 SVGF Pass 使用。</li>
</ol>
<p>这个 Pass 的精髓在于它计算方差的方法。方差 ($\sigma^2$) 在统计学上的基本定义是“一组数据与其均值差异的平方的平均值”，即 $\sigma^2 = E[(X - \mu)^2]$，其中 $\mu$ 是均值 $E[X]$。</p>
$$\sigma^2 = E[X^2] - (E[X])^2$$<h4 id="如何映射到代码">
<a class="header-anchor" href="#%e5%a6%82%e4%bd%95%e6%98%a0%e5%b0%84%e5%88%b0%e4%bb%a3%e7%a0%81"></a>
如何映射到代码
</h4><ul>
<li><strong>$E[X]$ (期望/均值)</strong>: 在前一个 Pass 中，我们累积了颜色的亮度，存放在 <code>moments.x</code> 中。它就是我们对亮度均值的最佳估计。</li>
<li><strong>$E[X^2]$ (平方的期望/二阶矩)</strong>: 同样，我们累积了亮度值的平方，存放在 <code>moments.y</code> 中。它就是对亮度平方的均值的最佳估计。</li>
</ul>
<p>因此，GLSL 代码 <code>variance = moments.y - pow(moments.x, 2);</code> 就是对 $\sigma^2 = E[X^2] - (E[X])^2$ 这个公式<strong>最直接、最高效的实现</strong>。</p>
<h3 id="wavelet-pass">
<a class="header-anchor" href="#wavelet-pass"></a>
Wavelet Pass
</h3><p>最后一步，也是最核心的一步：<strong>基于小波变换的方差引导空间滤波 (Wavelet-based, Variance-Guided Spatial Filtering)</strong>。</p>
<p>这个着色器通常会执行多轮（一般是3到5轮），每一轮都会增大采样步长 (<code>step_size</code>)。这种特殊的、带孔的滤波方式也称为 <strong>À-trous Filter</strong>（法语，意为 &ldquo;with holes&rdquo;），它能在保持极高效率的同时，实现大范围的模糊效果。</p>
<p>它的最终目标是将时间累积阶段生成的、依然有些许噪点和条纹的图像，彻底平滑成一幅干净、自然且保留了关键细节的最终图像。</p>
<p><img src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507202117202.png" alt=""></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief  计算中心像素p和邻居像素q之间的交叉双边权重。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param n_p             中心像素p的法线。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param linear_z_dd     中心像素p的线性深度及其梯度 {z, fwidth(z)}。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param l_p             中心像素p的亮度。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param l_q             邻居像素q的亮度。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param p, q            中心和邻居像素的坐标。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param phi_depth       一个根据p的深度梯度和atrous步长计算出的自适应深度阈值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return float          最终的相似度权重，介于[0, 1]之间。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">float</span> <span class="n">compute_w</span><span class="p">(</span><span class="k">vec3</span> <span class="n">n_p</span><span class="p">,</span> <span class="k">vec2</span> <span class="n">linear_z_dd</span><span class="p">,</span> <span class="k">float</span> <span class="n">l_p</span><span class="p">,</span> <span class="k">float</span> <span class="n">l_q</span><span class="p">,</span> <span class="k">ivec2</span> <span class="n">p</span><span class="p">,</span> <span class="k">ivec2</span> <span class="n">q</span><span class="p">,</span> <span class="k">float</span> <span class="n">phi_depth</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 准备工作: 获取邻居像素 q 的属性 ---</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec2</span> <span class="n">scaled_q</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">q</span> <span class="o">*</span> <span class="n">resolution_scale_rcp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">vec2</span> <span class="n">encoded_normal_q</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">normals_texture_index</span><span class="p">],</span> <span class="n">scaled_q</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">rg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">n_q</span> <span class="o">=</span> <span class="n">octahedral_decode</span><span class="p">(</span><span class="n">encoded_normal_q</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">z_q</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">linear_z_dd_texture_index</span><span class="p">],</span> <span class="n">scaled_q</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 权重 1: 法线权重 w_n (几何边缘保护)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算两个法线的点积。如果法线相同，点积为1；如果垂直，点积为0。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 使用 pow() 函数可以使权重的衰减变得更陡峭，sigma_n 控制陡峭程度。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这意味着只有法线方向非常接近的像素，才能获得较高的权重。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">w_n</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">n_p</span><span class="p">,</span> <span class="n">n_q</span><span class="p">)),</span> <span class="n">sigma_n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 权重 2: 深度权重 w_z (深度不连续保护)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 来自 https://github.com/NVIDIAGameWorks/Falcor/blob/master/Source/RenderPasses/SVGFPass/SVGFAtrous.ps.slang</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 它用原始的深度差，除以一个自适应的阈值 phi_depth。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// phi_depth = max(linear_z_dd.y, 1e-8) * step_size，它会随着</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 中心像素的深度梯度（几何陡峭程度）和 atrous 步长的增大而增大。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这使得深度检查在平坦区域更严格，在陡峭区域和大的采样步长下更宽松。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">w_z</span> <span class="o">=</span> <span class="p">(</span><span class="n">phi_depth</span> <span class="o">==</span> <span class="mo">0</span><span class="p">)</span> <span class="o">?</span> <span class="mf">0.0</span><span class="n">f</span> <span class="o">:</span> <span class="n">abs</span><span class="p">(</span><span class="n">linear_z_dd</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">z_q</span><span class="p">)</span> <span class="o">/</span> <span class="n">phi_depth</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 权重 3: 亮度权重 w_l (方差引导的材质/光照边缘保护)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 3a. 计算中心像素p的局部平均方差 g ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在计算亮度权重前，先对“方差图”进行一次 3x3 的高斯模糊。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 得到的 g 代表了中心像素p附近区域的平均“噪点程度”。</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">float</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">8.0</span><span class="p">},</span> <span class="p">{</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">8.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">16.0</span><span class="p">}};</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">g</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">int</span> <span class="n">radius</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">yy</span> <span class="o">=</span> <span class="o">-</span><span class="n">radius</span><span class="p">;</span> <span class="n">yy</span> <span class="o">&lt;=</span> <span class="n">radius</span><span class="p">;</span> <span class="n">yy</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">xx</span> <span class="o">=</span> <span class="o">-</span><span class="n">radius</span><span class="p">;</span> <span class="n">xx</span> <span class="o">&lt;=</span> <span class="n">radius</span><span class="p">;</span> <span class="n">xx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">ivec2</span> <span class="n">s</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// ... [边界检查] ...</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">k</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">[</span><span class="n">abs</span><span class="p">(</span><span class="n">xx</span><span class="p">)][</span><span class="n">abs</span><span class="p">(</span><span class="n">yy</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">v</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">variance_texture_index</span><span class="p">],</span> <span class="n">s</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">g</span> <span class="o">+=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 3b. 计算方差引导的亮度权重 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这是 SVGF 的灵魂。分母中的 sqrt(g) 是关键。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果局部方差 g 很高（噪点区），分母会很大，w_l 会趋近于1，从而允许混合不同亮度的颜色来降噪。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果局部方差 g 很低（干净区），分母会很小，w_l 对亮度差异会非常敏感，从而避免模糊，保护细节。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">w_l</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">l_p</span> <span class="o">-</span> <span class="n">l_q</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sigma_l</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span> <span class="n">g</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">5</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 最终权重组合</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将三个权重组合成最终的混合权重。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里的组合方式 exp(-a -b) * c 是双边滤波中的一种常见形式。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">final_weight</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="mf">0.0</span> <span class="o">-</span> <span class="n">max</span><span class="p">(</span><span class="n">w_z</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-</span> <span class="n">max</span><span class="p">(</span><span class="n">w_l</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span> <span class="o">*</span> <span class="n">w_n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">final_weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">float</span> <span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="mf">3.0</span> <span class="o">/</span> <span class="mf">8.0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">16.0</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 1. 初始化 ---</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec2</span> <span class="n">frag_coord</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 从上一 Pass 读取中心像素p的各种属性</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec2</span> <span class="n">scaled_xy</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">frag_coord</span> <span class="o">*</span> <span class="n">resolution_scale_rcp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">normal_p</span> <span class="o">=</span> <span class="n">octahedral_decode</span><span class="p">(</span><span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">normals_texture_index</span><span class="p">],</span> <span class="n">scaled_xy</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">rg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">linear_z_dd</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">linear_z_dd_texture_index</span><span class="p">],</span> <span class="n">scaled_xy</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">rg</span><span class="p">;</span> <span class="c1">// .x是深度, .y是深度梯度</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">color_p</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">integrated_color_texture_index</span><span class="p">],</span> <span class="n">frag_coord</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">luminance_p</span> <span class="o">=</span> <span class="n">luminance</span><span class="p">(</span><span class="n">color_p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化累加器</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">new_filtered_color</span> <span class="o">=</span> <span class="n">color_p</span><span class="p">;</span> <span class="c1">// 中心像素首先计入</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">color_weight</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">new_variance</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">variance_texture_index</span><span class="p">],</span> <span class="n">frag_coord</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 2. À-trous 滤波循环 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这是一个 3x3 的滤波核，但采样点是“带孔”的，由 step_size 控制间隔。</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">int</span> <span class="n">radius</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">radius</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">radius</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">radius</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">radius</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mo">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="mo">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// 跳过中心点</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 计算邻居像素q的坐标，间隔为 step_size</span>
</span></span><span class="line"><span class="cl">            <span class="k">ivec2</span> <span class="n">q</span> <span class="o">=</span> <span class="n">frag_coord</span> <span class="o">+</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">step_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// ... [边界检查] ...</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// --- 3. 计算权重并累加 ---</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 读取邻居像素q的颜色和亮度</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">c_q</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">integrated_color_texture_index</span><span class="p">],</span> <span class="n">q</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">l_q</span> <span class="o">=</span> <span class="n">luminance</span><span class="p">(</span><span class="n">c_q</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// h_q 是空间距离权重（高斯权重）</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">h_q</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="o">*</span> <span class="n">h</span><span class="p">[</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// w_pq 是基于几何和亮度相似度的“双边权重”</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">w_pq</span> <span class="o">=</span> <span class="n">compute_w</span><span class="p">(</span><span class="n">normal_p</span><span class="p">,</span> <span class="n">linear_z_dd</span><span class="p">,</span> <span class="n">luminance_p</span><span class="p">,</span> <span class="n">l_q</span><span class="p">,</span> <span class="n">frag_coord</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="p">...);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 最终样本权重是两者的乘积</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">sample_weight</span> <span class="o">=</span> <span class="n">h_q</span> <span class="o">*</span> <span class="n">w_pq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 累加带权的颜色和总权重</span>
</span></span><span class="line"><span class="cl">            <span class="n">new_filtered_color</span> <span class="o">+=</span> <span class="n">sample_weight</span> <span class="o">*</span> <span class="n">c_q</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">color_weight</span> <span class="o">+=</span> <span class="n">sample_weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 同时，根据权重传播和更新方差</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">prev_variance</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">variance_texture_index</span><span class="p">],</span> <span class="n">q</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">new_variance</span> <span class="o">+=</span> <span class="n">pow</span><span class="p">(</span><span class="n">h_q</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">w_pq</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">prev_variance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 4. 归一化并输出 ---</span>
</span></span><span class="line"><span class="cl">    <span class="n">new_filtered_color</span> <span class="o">/=</span> <span class="n">color_weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">new_variance</span> <span class="o">/=</span> <span class="n">pow</span><span class="p">(</span><span class="n">color_weight</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将本轮滤波后的结果写回，供下一轮（或最终显示）使用</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">global_images_2d</span><span class="p">[</span><span class="n">filtered_color_texture_index</span><span class="p">],</span> <span class="n">frag_coord</span><span class="p">,</span> <span class="k">vec4</span><span class="p">(</span><span class="n">new_filtered_color</span><span class="p">,</span> <span class="mo">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">global_images_2d</span><span class="p">[</span><span class="n">updated_variance_texture_index</span><span class="p">],</span> <span class="n">frag_coord</span><span class="p">,</span> <span class="k">vec4</span><span class="p">(</span><span class="n">new_variance</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="à-trous-带孔-小波滤波">
<a class="header-anchor" href="#%c3%a0-trous-%e5%b8%a6%e5%ad%94-%e5%b0%8f%e6%b3%a2%e6%bb%a4%e6%b3%a2"></a>
À-trous (带孔) 小波滤波
</h4><p>常规的大范围模糊需要一个巨大的滤波核，这会导致每个像素需要进行数千次纹理采样，性能极低。À-trous 滤波解决了这个问题。</p>
<ul>
<li><strong>原理</strong>: 它使用一个很小的核（这里是3x3），但在采样邻居时，会跳过一些像素，这个跳过的距离由 <code>step_size</code> 控制。</li>
<li><strong>流程</strong>:
<ul>
<li><strong>Pass 1</strong>: <code>step_size = 1</code>。进行一次标准的 3x3 滤波。</li>
<li><strong>Pass 2</strong>: <code>step_size = 2</code>。采样点间隔变为1个像素，等效于一个 5x5 的滤波范围。</li>
<li><strong>Pass 3</strong>: <code>step_size = 4</code>。采样点间隔变为3个像素，等效于一个 9x9 的滤波范围。</li>
<li><strong>Pass 4</strong>: <code>step_size = 8</code>。等效于一个 17x17 的滤波范围。</li>
<li><strong>Pass 5</strong>: <code>step_size = 16</code>。等效于一个 33x33 的滤波范围。</li>
</ul>
</li>
<li><strong>优势</strong>: 仅用 5 个 Pass，每个 Pass 只需采样 9 个点，就实现了过去需要一个巨大卷积核才能达到的模糊范围，效率极高。</li>
</ul>
<h4 id="交叉双边滤波-cross-bilateral-filter">
<a class="header-anchor" href="#%e4%ba%a4%e5%8f%89%e5%8f%8c%e8%be%b9%e6%bb%a4%e6%b3%a2-cross-bilateral-filter"></a>
交叉双边滤波 (Cross-Bilateral Filter)
</h4><p>这是 <code>compute_w</code> 函数的核心思想。一个普通的模糊滤波会无差别地混合所有邻居的颜色，导致边缘也被模糊掉。双边滤波则会根据“相似度”来决定混合权重。</p>
<ul>
<li><strong>交叉 (Cross)</strong>: 它的“智能”之处在于，判断相似度所依据的数据（指导图），和最终被模糊处理的图像（输入图）不是同一个。
<ul>
<li><strong>输入图</strong>: <code>integrated_color_texture</code> (需要被模糊的颜色图)</li>
<li><strong>指导图</strong>: <code>normals_texture</code>, <code>linear_z_dd_texture</code>, <code>variance_texture</code></li>
</ul>
</li>
<li>该实现综合了三种指导信息：
<ol>
<li><strong>法线相似度 (<code>w_n</code>)</strong>: 防止模糊跨越物体的几何棱角。</li>
<li><strong>深度相似度 (<code>w_z</code>)</strong>: 防止模糊跨越物体的边缘轮廓。</li>
<li><strong>亮度相似度 (<code>w_l</code>)</strong>: 防止模糊跨越材质或光照的明暗变化。</li>
</ol>
</li>
</ul>
<p><code>compute_w</code> 本质上是一个<strong>交叉双边权重 (Cross-Bilateral Weight)</strong> 的计算器，它同时考量了三个方面的相似性：<strong>几何法线、几何深度、以及由方差引导的颜色亮度</strong>。</p>
<p>权重 1: 法线权重 $w_n$ - 保护几何棱角</p>
<ul>
<li><strong>目的</strong>: 防止模糊效果“泄露”到不相关的几何表面上。例如，墙壁的颜色不应该模糊到地板上。</li>
<li><strong>方法</strong>: <code>dot(n_p, n_q)</code> 计算两个法线向量的余弦相似度。</li>
<li><strong><code>pow(..., sigma_n)</code></strong>: <code>sigma_n</code> 参数像一个“锐度”调节器。当 <code>sigma_n &gt; 1</code> 时，它会惩罚那些不是几乎完全平行的法线，使得只有在非常平坦的表面上，权重才接近1，从而让边缘保护更严格。</li>
</ul>
<p>权重 2: 深度权重 $w_z$ - 保护物体轮廓</p>
<ul>
<li><strong>目的</strong>: 防止模糊跨越有深度差异的边缘，例如一个物体与其后方背景的交界处。</li>
<li><strong>方法</strong>: <code>abs(linear_z_dd.x - z_q) / phi_depth</code>
<ul>
<li><strong>分子</strong>: <code>abs(linear_z_dd.x - z_q)</code> 是中心点 <code>p</code> 和邻居 <code>q</code> 之间最直接的深度差。</li>
<li><strong>分母</strong>: <code>phi_depth</code> 是一个<strong>自适应的容差</strong>。它由 <code>linear_z_dd.y</code> (中心点的深度梯度) 和 <code>step_size</code> (atrous滤波步长) 决定。
<ul>
<li>在<strong>平坦表面</strong> (<code>linear_z_dd.y</code> 小)，<code>phi_depth</code> 小，容差低，检查严格。</li>
<li>在<strong>陡峭表面</strong> (<code>linear_z_dd.y</code> 大)，<code>phi_depth</code> 大，容差高，检查宽松。</li>
<li>随着 <code>step_size</code> 增大，采样点距离变远，<code>phi_depth</code> 也随之增大，允许更大的深度差异。</li>
</ul>
</li>
<li>这个归一化后的 <code>w_z</code> 可以被认为是一个标准化的深度差异值。</li>
</ul>
</li>
</ul>
<p>权重 3: 亮度权重 $w_l$ - 保护材质与光照细节</p>
<ul>
<li><strong>目的</strong>: 这是 SVGF 最智能的部分。它既要能在噪点区域强力模糊，又要能在干净区域保护材质和阴影的精细边缘。</li>
<li><strong>方法</strong>: <code>exp(-(abs(l_p - l_q) / (sigma_l * sqrt(g) + 1e-5)))</code>
<ul>
<li><strong>分子</strong>: <code>abs(l_p - l_q)</code> 是中心点 <code>p</code> 和邻居 <code>q</code> 之间的亮度差异。</li>
<li><strong>分母</strong>: <code>sigma_l * sqrt(g)</code> 是一个<strong>由方差引导的自适应亮度容差</strong>。<code>g</code> 是我们刚刚在3x3邻域内计算出的局部平均方差。
<ul>
<li><strong>高方差区域 (噪点多)</strong>: <code>g</code> 很大，导致分母很大。此时，即使 <code>abs(l_p - l_q)</code> 也很大，整个分数也会很小，<code>w_l</code> 趋近于1。这意味着<strong>亮度差异被忽略</strong>，滤波器会强力混合颜色以消除噪点。</li>
<li><strong>低方差区域 (已干净)</strong>: <code>g</code> 很小，导致分母很小。此时，即使一个微小的亮度差异 <code>abs(l_p - l_q)</code> 都会导致分数很大，<code>w_l</code> 快速趋近于0。这意味着<strong>亮度差异被严格尊重</strong>，滤波器拒绝混合不同亮度的颜色，从而保护了细节。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>最终权重组合 <code>final_weight = exp(-max(w_z, 0.0) - max(w_l, 0.0)) * w_n</code></p>
<p>这个公式将三个权重因子非线性地组合在一起。深度和亮度权重在指数部分相加，这意味着它们中任何一个的惩罚效果都会被放大。法线权重则作为一个最终的乘数，如果法线不匹配，它可以一票否决掉整个权重。这种组合方式能产生平滑且自然的权重衰减，是实现高质量滤波效果的关键。</p>
<h4 id="方差引导滤波-variance-guided-filtering">
<a class="header-anchor" href="#%e6%96%b9%e5%b7%ae%e5%bc%95%e5%af%bc%e6%bb%a4%e6%b3%a2-variance-guided-filtering"></a>
方差引导滤波 (Variance-Guided Filtering)
</h4><p>这是 SVGF 的灵魂，体现在 <code>w_l</code> 的计算上。</p>
<p><code>w_l = exp(-(abs(l_p - l_q) / (sigma_l * sqrt(g) + 1e-5)))</code></p>
<p>这里的 <code>g</code> 是通过模糊方差图得到的<strong>局部平均方差</strong>。这个分母是整个算法的“自动调节旋钮”：</p>
<ul>
<li>
<p><strong>当局部方差 <code>g</code> 很高时 (噪点区域)</strong>:</p>
<ul>
<li>分母 <code>sigma_l * sqrt(g)</code> 变得很大。</li>
<li>整个分数项 <code>abs(l_p - l_q) / ...</code> 趋近于 0。</li>
<li><code>w_l</code> 趋近于 <code>exp(0)</code>，也就是 1。</li>
<li><strong>结果</strong>: 亮度权重失效了！滤波器会大胆地将差异巨大的颜色混合在一起，从而强力地抹除噪点。</li>
</ul>
</li>
<li>
<p><strong>当局部方差 <code>g</code> 很低时 (干净区域)</strong>:</p>
<ul>
<li>分母很小。</li>
<li>整个分数项对 <code>abs(l_p - l_q)</code> 的变化非常敏感。</li>
<li><code>w_l</code> 会因为微小的亮度差异而快速衰减到 0。</li>
<li><strong>结果</strong>: 亮度权重变得极其严格！滤波器会拒绝混合任何有细微明暗变化的颜色，从而完美地保护了图像细节。</li>
</ul>
</li>
</ul>
<p>通过这种方式，SVGF 算法实现了终极目标：<strong>在噪点多的地方大力模糊，在细节多的地方精细保护</strong>，而这一切都是根据前几步计算出的数据自动完成的。</p>
<h3 id="downsample-pass">
<a class="header-anchor" href="#downsample-pass"></a>
Downsample Pass
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief  对全分辨率的G-Buffer进行智能降采样，为下一帧生成历史纹理。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @details
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 该计算着色器为每个低分辨率（半分辨率）像素，检查其对应的 2x2 高分辨率像素块。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 它根据深度值选择这个 2x2 块中最“有代表性”的一个像素——即最靠近摄像机的那个像素。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 然后，它将这个被选中像素的 G-Buffer 数据（法线、物体ID、线性深度等）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 拷贝到低分辨率的历史纹理中。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 这种方法能有效保留物体边缘轮廓，防止前景的精细物体在降采样中被背景“侵蚀”。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义一个 2x2 像素块的相对偏移</span>
</span></span><span class="line"><span class="cl"><span class="k">ivec2</span> <span class="n">pixel_offsets</span><span class="p">[]</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">[](</span><span class="k">ivec2</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">),</span> <span class="k">ivec2</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="k">ivec2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mo">0</span><span class="p">),</span> <span class="k">ivec2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// frag_coord 是当前正在处理的低分辨率（目标分辨率）像素坐标。</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec2</span> <span class="n">frag_coord</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 1. 在 2x2 邻域内选择“最佳”像素 ---</span>
</span></span><span class="line"><span class="cl">    <span class="k">int</span> <span class="n">chosen_hiresolution_sample_index</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">closer_depth</span> <span class="o">=</span> <span class="mf">1.</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历当前低分辨率像素对应的 2x2 高分辨率像素块。</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 计算高分辨率像素的坐标。</span>
</span></span><span class="line"><span class="cl">        <span class="k">ivec2</span> <span class="n">hires_coord</span> <span class="o">=</span> <span class="n">frag_coord</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">pixel_offsets</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 读取该高分辨率像素的深度值。</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">depth_texture_index</span><span class="p">)],</span> <span class="n">hires_coord</span><span class="p">,</span> <span class="mo">0</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 寻找 2x2 块中深度值最小的像素。</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">closer_depth</span> <span class="o">&gt;</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">closer_depth</span> <span class="o">=</span> <span class="n">depth</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">chosen_hiresolution_sample_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// 记录下这个“获胜”像素的索引</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 2. 拷贝“最佳”像素的数据到历史纹理 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算出获胜像素的最终高分辨率坐标。</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec2</span> <span class="n">chosen_coord</span> <span class="o">=</span> <span class="n">frag_coord</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">pixel_offsets</span><span class="p">[</span><span class="n">chosen_hiresolution_sample_index</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 从全分辨率 G-Buffer 的“获胜”坐标处读取法线、物体ID、线性深度等信息...</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">normals</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">normals_texture_index</span><span class="p">)],</span> <span class="n">chosen_coord</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">mesh_id</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">mesh_id_texture_index</span><span class="p">)],</span> <span class="n">chosen_coord</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">linear_z_dd</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">linear_z_dd_texture_index</span><span class="p">)],</span> <span class="n">chosen_coord</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ...然后将这些信息写入到半分辨率的历史纹理中，供下一帧的时间性算法使用。</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">global_images_2d</span><span class="p">[</span><span class="n">history_normals_texture_index</span><span class="p">],</span> <span class="n">frag_coord</span><span class="p">,</span> <span class="n">normals</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">global_images_2d</span><span class="p">[</span><span class="n">history_mesh_id_texture_index</span><span class="p">],</span> <span class="n">frag_coord</span><span class="p">,</span> <span class="n">mesh_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">global_images_2d</span><span class="p">[</span><span class="n">history_linear_depth_texture</span><span class="p">],</span> <span class="n">frag_coord</span><span class="p">,</span> <span class="n">linear_z_dd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 3. 更新其他历史纹理 ---</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 对于某些已经是低分辨率的纹理（如上一Pass的输出），直接拷贝即可。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">moments</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">integrated_moments_texture_index</span><span class="p">)],</span> <span class="n">frag_coord</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">global_images_2d</span><span class="p">[</span><span class="n">history_moments_texture_index</span><span class="p">],</span> <span class="n">frag_coord</span><span class="p">,</span> <span class="n">moments</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="temporal-anti-aliasing-taa">
<a class="header-anchor" href="#temporal-anti-aliasing-taa"></a>
Temporal Anti-Aliasing (TAA)
</h1><h2 id="工作流程-3">
<a class="header-anchor" href="#%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b-3"></a>
工作流程
</h2><ol>
<li><strong>速度采样 (Velocity Sampling)</strong>:
<ul>
<li>首先，在3x3邻域内寻找<strong>深度最近</strong>的像素，并使用它的运动矢量。这对于处理细小物体或物体边缘的运动非常重要。</li>
</ul>
</li>
<li><strong>历史重投影与采样 (History Reprojection &amp; Sampling)</strong>:
<ul>
<li>使用获取到的 <code>velocity</code> 计算出重投影的UV坐标 <code>reprojected_uv</code>。</li>
<li>根据 <code>history_sampling_filter</code> 模式，使用单点采样或高质量的 Catmull-Rom 滤波来获取 <code>history_color</code>。</li>
</ul>
</li>
<li><strong>当前邻域分析 (Current Neighborhood Analysis)</strong>:
<ul>
<li>遍历当前像素的3x3邻域。</li>
<li>使用 <code>subsample_filter</code>（如 Mitchell-Netravali 或 Blackman-Harris）对邻域进行加权平均，得到一个高质量的当前帧颜色 <code>current_sample</code>。</li>
<li>同时，计算出该邻域的颜色AABB (<code>neighborhood_min/max</code>) 和颜色矩 (<code>m1</code>, <code>m2</code>)，为历史裁剪做准备。</li>
</ul>
</li>
<li><strong>历史约束 (History Constraint)</strong>:
<ul>
<li>这是抑制鬼影的关键。根据 <code>history_constraint_mode</code> 的不同，对 <code>history_color</code> 执行不同的裁剪策略，包括简单的钳位（Clamp）、AABB裁剪（Clip），以及更高级的方差裁剪（VarianceClip）。</li>
</ul>
</li>
<li><strong>最终颜色混合 (Resolve)</strong>:
<ul>
<li>这是最后一步，将<strong>经过约束的历史颜色</strong>和<strong>经过滤波的当前颜色</strong>进行混合。</li>
<li>混合的权重 <code>current_weight</code> 和 <code>history_weight</code> 不是固定的 <code>0.1/0.9</code>，而是可以通过 <code>options</code> 进一步动态调整，例如：
<ul>
<li><code>use_temporal_filtering()</code>: 根据邻域颜色的变化幅度来调整权重。</li>
<li><code>use_inverse_luminance_filtering()</code>: 根据颜色的亮度来调整权重，有助于抑制高光区域的闪烁。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="temporal-anti-aliasing">
<a class="header-anchor" href="#temporal-anti-aliasing"></a>
Temporal Anti-Aliasing
</h2><p>TAA 是一种强大且在现代游戏中应用极其广泛的技术。它的核心思想是<strong>复用前几帧的历史信息</strong>，将时间上的分辨率转化为空间上的分辨率。通过每一帧对场景进行微小的抖动（Jitter），然后将当前帧与经过校正的历史图像进行混合，TAA 能以极低的性能开销实现媲美超采样 (Supersampling) 的高质量抗锯齿效果。</p>
<p>然而，TAA 的最大挑战是处理动态场景，如果历史信息校正不当，就会产生<strong>鬼影 (Ghosting)</strong> 和<strong>模糊 (Blur)</strong> 等副作用。因此，这段代码的大部分内容都是在用各种先进的技术来智能地约束历史数据，以抑制这些副作用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="k">vec3</span> <span class="n">taa</span><span class="p">(</span><span class="k">ivec2</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 第 1 步：速度矢量与时间重投影</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 为了更稳定地拾取运动矢量（尤其是在物体边缘），可以在 3x3 邻域内搜索最靠近的像素。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里我们假设已找到最近像素的坐标 `closest_position`。</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec2</span> <span class="n">closest_position</span> <span class="o">=</span> <span class="n">find_closest_fragment_3x3</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 采样该位置的运动矢量。</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">vec2</span> <span class="n">velocity</span> <span class="o">=</span> <span class="n">sample_motion_vector_point</span><span class="p">(</span><span class="n">closest_position</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算当前像素的 UV 坐标。</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">vec2</span> <span class="n">screen_uv</span> <span class="o">=</span> <span class="n">uv_nearest</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">resolution</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 根据运动矢量，反向计算出当前像素在上一帧的 UV 坐标 (reprojected_uv)。</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">vec2</span> <span class="n">reprojected_uv</span> <span class="o">=</span> <span class="n">screen_uv</span> <span class="o">-</span> <span class="n">velocity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 第 2 步：历史颜色采样</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 使用高质量的 Catmull-Rom 样条插值，从历史纹理中采样颜色。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这比简单的双线性插值更能保留细节，有效减缓 TAA 累积多帧后带来的模糊。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">history_color</span> <span class="o">=</span> <span class="n">sample_texture_catmull_rom</span><span class="p">(</span><span class="n">reprojected_uv</span><span class="p">,</span> <span class="n">history_color_texture_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 第 3 步：当前帧邻域分析</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历当前像素的 3x3 邻域，以收集用于验证和约束历史颜色的统计信息。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">current_sample_total</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mo">0</span><span class="p">);</span>  <span class="c1">// 邻域加权颜色累加器</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">current_sample_weight</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span> <span class="c1">// 邻域权重累加器</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">neighborhood_min</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>  <span class="c1">// 邻域颜色AABB的最小值</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">neighborhood_max</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="o">-</span><span class="mi">10000</span><span class="p">);</span> <span class="c1">// 邻域颜色AABB的最大值</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">m1</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mo">0</span><span class="p">);</span> <span class="c1">// 邻域颜色的一阶矩（用于计算均值）</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">m2</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mo">0</span><span class="p">);</span> <span class="c1">// 邻域颜色的二阶矩（用于计算方差）</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">ivec2</span> <span class="n">pixel_position</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">pixel_position</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">pixel_position</span><span class="p">,</span> <span class="k">ivec2</span><span class="p">(</span><span class="mo">0</span><span class="p">),</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">resolution</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">current_sample_neighbor</span> <span class="o">=</span> <span class="n">sample_current_color_point</span><span class="p">(</span><span class="n">pixel_position</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 根据邻域像素与中心点的距离，计算一个空间权重。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 这通常是一个中心点权重最高的滤波核，如 Tent 或 Gaussian 核。</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">subsample_distance</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="k">vec2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">subsample_weight</span> <span class="o">=</span> <span class="n">subsample_filter</span><span class="p">(</span><span class="n">subsample_distance</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 累加加权后的颜色和权重。</span>
</span></span><span class="line"><span class="cl">            <span class="n">current_sample_total</span> <span class="o">+=</span> <span class="n">current_sample_neighbor</span> <span class="o">*</span> <span class="n">subsample_weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">current_sample_weight</span> <span class="o">+=</span> <span class="n">subsample_weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 更新邻域颜色的AABB包围盒。</span>
</span></span><span class="line"><span class="cl">            <span class="n">neighborhood_min</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">neighborhood_min</span><span class="p">,</span> <span class="n">current_sample_neighbor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">neighborhood_max</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">neighborhood_max</span><span class="p">,</span> <span class="n">current_sample_neighbor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 累加矩，用于后续的方差计算。</span>
</span></span><span class="line"><span class="cl">            <span class="n">m1</span> <span class="o">+=</span> <span class="n">current_sample_neighbor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">m2</span> <span class="o">+=</span> <span class="n">current_sample_neighbor</span> <span class="o">*</span> <span class="n">current_sample_neighbor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算经过空间滤波后的当前帧颜色。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">current_sample</span> <span class="o">=</span> <span class="n">current_sample_total</span> <span class="o">/</span> <span class="n">current_sample_weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果重投影坐标超出了屏幕范围，则无法复用历史，直接返回经过邻域滤波的当前颜色。</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">any</span><span class="p">(</span><span class="n">lessThan</span><span class="p">(</span><span class="n">reprojected_uv</span><span class="p">,</span> <span class="k">vec2</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">)))</span> <span class="o">||</span> <span class="n">any</span><span class="p">(</span><span class="n">greaterThan</span><span class="p">(</span><span class="n">reprojected_uv</span><span class="p">,</span> <span class="k">vec2</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span><span class="p">))))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">current_sample</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 第 4 步：历史约束与鬼影抑制</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这是 TAA 算法的灵魂，用于判断采样到的 history_color 是否“合理”。</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">history_constraint_mode</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">case</span> <span class="n">HistoryConstraintModeNone</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 不做任何处理，完全相信历史颜色。容易产生鬼影。</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">case</span> <span class="n">HistoryConstraintModeClamp</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 硬性裁剪：将历史颜色强制限制在当前邻域颜色的AABB包围盒内。</span>
</span></span><span class="line"><span class="cl">            <span class="n">history_color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">history_color</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">neighborhood_min</span><span class="p">,</span> <span class="n">neighborhood_max</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">case</span> <span class="n">HistoryConstraintModeClip</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// AABB 裁剪：将从 current_sample 指向 history_color 的线段，</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 与邻域 AABB 包围盒求交。这比 Clamp 更柔和，能保留颜色的变化方向。</span>
</span></span><span class="line"><span class="cl">            <span class="n">history_color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">clip_aabb</span><span class="p">(</span><span class="n">neighborhood_min</span><span class="p">,</span> <span class="n">neighborhood_max</span><span class="p">,</span> <span class="k">vec4</span><span class="p">(</span><span class="n">history_color</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">),</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">case</span> <span class="n">HistoryConstraintModeVarianceClip</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 方差裁剪：计算邻域颜色的均值(mu)和标准差(sigma)。</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">mu</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">/</span> <span class="mf">9.0</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">abs</span><span class="p">((</span><span class="n">m2</span> <span class="o">/</span> <span class="mf">9.0</span><span class="n">f</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">mu</span> <span class="o">*</span> <span class="n">mu</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 构建一个基于统计的“智能”包围盒 [mu - gamma*sigma, mu + gamma*sigma]。</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">minc</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">-</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">maxc</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 将历史颜色裁剪到这个统计包围盒内。</span>
</span></span><span class="line"><span class="cl">            <span class="n">history_color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">clip_aabb</span><span class="p">(</span><span class="n">minc</span><span class="p">,</span> <span class="n">maxc</span><span class="p">,</span> <span class="k">vec4</span><span class="p">(</span><span class="n">history_color</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">case</span> <span class="n">HistoryConstraintModeVarianceClipClamp</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 混合模式：先进行一次硬性的 AABB Clamp，再进行一次方差裁剪。</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 这是最鲁棒的模式，Clamp 移除了极端异常值，VarianceClip 进行更精细的统计约束。</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">rcp_sample_count</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">/</span> <span class="mf">9.0</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">float</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">mu</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">*</span> <span class="n">rcp_sample_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">abs</span><span class="p">((</span><span class="n">m2</span> <span class="o">*</span> <span class="n">rcp_sample_count</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">mu</span> <span class="o">*</span> <span class="n">mu</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">minc</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">-</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">maxc</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">vec3</span> <span class="n">clamped_history_color</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">history_color</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">neighborhood_min</span><span class="p">,</span> <span class="n">neighborhood_max</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">history_color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">clip_aabb</span><span class="p">(</span><span class="n">minc</span><span class="p">,</span> <span class="n">maxc</span><span class="p">,</span> <span class="k">vec4</span><span class="p">(</span><span class="n">clamped_history_color</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 第 5 步：最终混合与解析</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ===================================================================</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 动态计算混合权重，以在稳定性和响应性之间取得平衡。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">current_weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">history_weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... [此处省略了多个复杂的动态权重计算逻辑] ...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这些逻辑会根据亮度、对比度等因素，动态调整 current_weight 和 history_weight。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 为了简化，我们假设一个基础的混合因子。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">blend_factor</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="c1">// 10% 当前帧, 90% 历史</span>
</span></span><span class="line"><span class="cl">    <span class="n">current_weight</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="n">blend_factor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">history_weight</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">blend_factor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 最终颜色是当前颜色和（经过约束的）历史颜色的加权平均。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_sample</span> <span class="o">*</span> <span class="n">current_weight</span> <span class="o">+</span> <span class="n">history_color</span> <span class="o">*</span> <span class="n">history_weight</span><span class="p">)</span> <span class="o">/</span> <span class="n">max</span><span class="p">(</span><span class="n">current_weight</span> <span class="o">+</span> <span class="n">history_weight</span><span class="p">,</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="核心原理与关键技术详解">
<a class="header-anchor" href="#%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%85%b3%e9%94%ae%e6%8a%80%e6%9c%af%e8%af%a6%e8%a7%a3"></a>
核心原理与关键技术详解
</h3><h4 id="邻域加权采样">
<a class="header-anchor" href="#%e9%82%bb%e5%9f%9f%e5%8a%a0%e6%9d%83%e9%87%87%e6%a0%b7"></a>
邻域加权采样
</h4><p>在分析当前帧时，TAA 并不仅仅看中心像素 <code>pos</code> 的颜色，而是对其 3x3 邻域进行一次<strong>空间滤波</strong>。<code>subsample_filter</code> 函数定义了一个空间权重核（例如中心点权重最高，角落权重最低），这样做有两个目的：</p>
<ul>
<li><strong>预滤波</strong>: 得到的 <code>current_sample</code> 本身就是一个轻微模糊、抗锯齿的颜色，这有助于减少高频闪烁。</li>
<li><strong>收集统计数据</strong>: 更重要的是，这个 3x3 邻域提供了丰富的统计信息（min/max AABB, 均值，方差），它们是后续<strong>历史约束</strong>步骤做出智能判断的依据。</li>
</ul>
<h4 id="历史约束的所有模式">
<a class="header-anchor" href="#%e5%8e%86%e5%8f%b2%e7%ba%a6%e6%9d%9f%e7%9a%84%e6%89%80%e6%9c%89%e6%a8%a1%e5%bc%8f"></a>
历史约束的所有模式
</h4><p>这是 TAA 算法质量的分水岭，用于解决<strong>鬼影 (Ghosting)</strong> 问题。</p>
<ul>
<li><strong><code>None</code></strong>: 不做任何操作，用于调试或对比。</li>
<li><strong><code>Clamp</code></strong>: “硬”限制。非常暴力地将历史颜色拉回邻域AABB内，能有效防止极端鬼影，但可能在某些情况下丢失颜色变化的方向性，显得生硬。</li>
<li><strong><code>Clip</code></strong>: “软”限制。它将 <code>current_sample</code> 和 <code>history_color</code> 看作一条线段的两个端点。如果 <code>history_color</code> 在AABB之外，它会找到这条线段与AABB的交点作为新的 <code>history_color</code>。这比 <code>Clamp</code> 更优，因为它保留了颜色从当前帧到历史帧的变化趋势。</li>
<li><strong><code>VarianceClip</code></strong>: 统计限制。这是最智能的方法。它认为一个“合理”的历史颜色，应该落在当前邻域颜色分布的几个标准差之内。它创建了一个统计学上的置信区间，任何落在这个区间外的历史颜色都被视为“异常值”（即鬼影）并被修正。</li>
<li><strong><code>VarianceClipClamp</code></strong>: 终极鲁棒模式。它结合了 <code>Clamp</code> 和 <code>VarianceClip</code> 的优点。先用 <code>Clamp</code> 粗暴地干掉那些最离谱的鬼影颜色，防止它们污染后续的统计计算。然后，在被“预处理”过的颜色上，再用更精细的 <code>VarianceClip</code> 进行约束。这在快速运动和高对比度场景中表现得最为稳定。</li>
</ul>
<h4 id="动态混合权重">
<a class="header-anchor" href="#%e5%8a%a8%e6%80%81%e6%b7%b7%e5%90%88%e6%9d%83%e9%87%8d"></a>
动态混合权重
</h4><p>一个高质量的 TAA 不会使用固定的混合系数（如 <code>blend_factor = 0.1</code>）。<strong>动态权重</strong>可以基于如下因素进行调整：</p>
<ul>
<li><strong>对比度/亮度检测</strong>: 在图像对比度高（细节丰富）的区域，可能会增加历史权重，以便用更多的时间样本来更好地解析这些细节。</li>
<li><strong>亮度差异检测</strong>: 如果当前帧和历史帧的亮度差异很大，可能说明场景发生了剧烈变化（如爆炸），此时会降低历史权重（增加当前帧权重），让画面更快地更新到新状态，减少拖影。</li>
<li><strong>逆亮度权重</strong>: <code>current_weight *= 1.0 / (1.0 + luminance_source)</code> 是一种特殊技巧，用于抑制<strong>高光噪点 (Fireflies)</strong>。它降低了非常亮的像素在混合中的权重，防止这些偶然出现的闪烁噪点被 TAA “锁定”并保留在画面上。</li>
</ul>
<h5 id="基于对比度的自适应滤波-contrast-adaptive-filtering">
<a class="header-anchor" href="#%e5%9f%ba%e4%ba%8e%e5%af%b9%e6%af%94%e5%ba%a6%e7%9a%84%e8%87%aa%e9%80%82%e5%ba%94%e6%bb%a4%e6%b3%a2-contrast-adaptive-filtering"></a>
基于对比度的自适应滤波 (Contrast-Adaptive Filtering)
</h5><p>这个 <code>if (use_temporal_filtering())</code> 分支的目的是根据<strong>图像的局部对比度</strong>来调整混合权重。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// --- 1. 基于对比度的自适应滤波 ---</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">use_temporal_filtering</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1a. 计算局部对比度</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// abs(neighborhood_max - neighborhood_min) 计算了3x3邻域颜色AABB的大小，</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 是一个衡量局部颜色变化范围（即对比度）的指标。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 再除以邻域的平均颜色 current_sample 进行归一化。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 结果 temporal_weight 是一个 [0, 1] 的值，代表了局部对比度的高低。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">temporal_weight</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">neighborhood_max</span> <span class="o">-</span> <span class="n">neighborhood_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">current_sample</span><span class="p">,</span> <span class="k">vec3</span><span class="p">(</span><span class="mo">0</span><span class="p">),</span> <span class="k">vec3</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 1b. 将对比度映射到历史权重</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 使用 mix 函数进行线性映射：</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// - 如果对比度低 (temporal_weight 接近 0)，history_weight 接近 0.25。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// - 如果对比度高 (temporal_weight 接近 1)，history_weight 接近 0.85。</span>
</span></span><span class="line"><span class="cl">    <span class="n">history_weight</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">mix</span><span class="p">(</span><span class="k">vec3</span><span class="p">(</span><span class="mf">0.25</span><span class="p">),</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">0.85</span><span class="p">),</span> <span class="n">temporal_weight</span><span class="p">),</span> <span class="k">vec3</span><span class="p">(</span><span class="mo">0</span><span class="p">),</span> <span class="k">vec3</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前帧的权重与历史权重互补。</span>
</span></span><span class="line"><span class="cl">    <span class="n">current_weight</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">-</span> <span class="n">history_weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li><strong>目的解析</strong>:
<ul>
<li><strong>在低对比度区域 (如平坦的墙面)</strong>: <code>history_weight</code> 会较低（~0.25），意味着当前帧的权重较高（~0.75）。图像会<strong>更快地收敛</strong>到当前帧。这样做的好处是，在这些平滑区域，鬼影会特别明显，所以快速混合有助于<strong>抑制鬼影</strong>。</li>
<li><strong>在高对比度区域 (如物体边缘、精细纹理)</strong>: <code>history_weight</code> 会较高（~0.85），意味着当前帧的权重较低（~0.15）。图像会<strong>更慢地收敛</strong>，更多地依赖历史信息。这样做的好处是，这些区域是<strong>锯齿最明显</strong>的地方，通过累积更多的历史样本，可以更好地<strong>平滑锯齿</strong>，提升抗锯齿质量。</li>
</ul>
</li>
</ul>
<h5 id="基于亮度的权重调整-luminance-based-weight-adjustment">
<a class="header-anchor" href="#%e5%9f%ba%e4%ba%8e%e4%ba%ae%e5%ba%a6%e7%9a%84%e6%9d%83%e9%87%8d%e8%b0%83%e6%95%b4-luminance-based-weight-adjustment"></a>
基于亮度的权重调整 (Luminance-Based Weight Adjustment)
</h5><p>这个 <code>if (use_inverse_luminance_filtering() || ...)</code> 分支包含两种基于亮度信息的、用于抑制特定类型瑕疵的启发式算法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// --- 2. 基于亮度的权重调整 ---</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">use_inverse_luminance_filtering</span><span class="p">()</span> <span class="o">||</span> <span class="n">use_luminance_difference_filtering</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 2a. 准备工作：计算压缩后的颜色和亮度</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 为了让亮度比较不受HDR高动态范围的极端值影响，先将颜色压缩到[0,1]范围。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">compressed_source</span> <span class="o">=</span> <span class="n">current_sample</span> <span class="o">/</span> <span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">current_sample</span><span class="p">.</span><span class="n">r</span><span class="p">,</span> <span class="n">current_sample</span><span class="p">.</span><span class="n">g</span><span class="p">),</span> <span class="n">current_sample</span><span class="p">.</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">compressed_history</span> <span class="o">=</span> <span class="n">history_color</span> <span class="o">/</span> <span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">history_color</span><span class="p">.</span><span class="n">r</span><span class="p">,</span> <span class="n">history_color</span><span class="p">.</span><span class="n">g</span><span class="p">),</span> <span class="n">history_color</span><span class="p">.</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">luminance_source</span> <span class="o">=</span> <span class="n">luminance</span><span class="p">(</span><span class="n">compressed_source</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">luminance_history</span> <span class="o">=</span> <span class="n">luminance</span><span class="p">(</span><span class="n">compressed_history</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 2b. 启发式算法一：亮度差异滤波</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">use_luminance_difference_filtering</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 计算当前帧和历史帧之间归一化的亮度差异。</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">unbiased_diff</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">luminance_source</span> <span class="o">-</span> <span class="n">luminance_history</span><span class="p">)</span> <span class="o">/</span> <span class="n">max</span><span class="p">(</span><span class="n">luminance_source</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">luminance_history</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将差异（0-1）转化为相似度（1-0）。</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">unbiased_weight</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">unbiased_diff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 对相似度进行平方，使得权重对差异更敏感。</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">unbiased_weight_sqr</span> <span class="o">=</span> <span class="n">unbiased_weight</span> <span class="o">*</span> <span class="n">unbiased_weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// k_feedback 是最终的混合因子，unbiased_weight_sqr 越高，k_feedback 越接近1。</span>
</span></span><span class="line"><span class="cl">        <span class="k">float</span> <span class="n">k_feedback</span> <span class="o">=</span> <span class="n">mix</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="n">unbiased_weight_sqr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 用 k_feedback 来设置权重。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果亮度相似 (k_feedback高)，则更多地混合当前帧，以快速响应细微的光照变化。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果亮度差异大 (k_feedback低)，则更多地信任历史，以防止突变。</span>
</span></span><span class="line"><span class="cl">        <span class="n">history_weight</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">k_feedback</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">current_weight</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="n">k_feedback</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 2c. 启发式算法二：反向亮度滤波 (抑制高光噪点)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这是在之前计算出的权重基础上，再乘上一个衰减因子。</span>
</span></span><span class="line"><span class="cl">    <span class="n">current_weight</span> <span class="o">*=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">luminance_source</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">history_weight</span> <span class="o">*=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">luminance_history</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li><strong>目的解析</strong>:
<ul>
<li><strong>亮度差异滤波</strong>: 这是一个额外的动态权重调节器。它根据当前帧和历史帧的亮度相似度来微调混合速度，其具体策略（相似时混合快还是慢）取决于引擎的整体调优目标。</li>
<li><strong>反向亮度滤波 (核心)</strong>: 这是抑制<strong>高光噪点 (Fireflies)</strong> 或<strong>镜面高光闪烁</strong>的关键技巧。
<ul>
<li>在光线追踪或某些PBR着色中，偶尔会因为采样不足而产生一些随机的、亮度极高的“野像素”（即“萤火虫”）。</li>
<li><code>1.0 / (1.0 + luminance)</code> 这个公式的特性是，当 <code>luminance</code> 非常大时，结果会非常接近 0。</li>
<li>通过将权重乘以这个因子，TAA 会<strong>极大地降低这些“萤火虫”像素的权重</strong>，无论它们出现在当前帧还是历史帧。这可以有效防止这些偶然出现的亮斑被 TAA 的反馈循环“锁定”，从而避免它们在屏幕上停留多帧，形成恼人的闪烁。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="catmull-rom-滤波优化">
<a class="header-anchor" href="#catmull-rom-%e6%bb%a4%e6%b3%a2%e4%bc%98%e5%8c%96"></a>
Catmull-Rom 滤波优化
</h4><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// 使用 Catmull-Rom 滤波对纹理进行采样，但只用 9 次纹理拾取（而非 16 次）。</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 这种优化利用了硬件的双线性过滤能力。</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 更多细节请参阅：http://vec3.ca/bicubic-filtering-in-fewer-taps/</span>
</span></span><span class="line"><span class="cl"><span class="k">vec3</span> <span class="n">sample_texture_catmull_rom</span><span class="p">(</span><span class="k">vec2</span> <span class="n">uv</span><span class="p">,</span> <span class="n">uint</span> <span class="n">texture_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 计算基础纹素坐标和分数偏移量。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 我们首先确定输入 UV 坐标周围的 4x4 纹素网格。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">sample_position</span> <span class="o">=</span> <span class="n">uv</span> <span class="o">*</span> <span class="n">resolution</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// &#39;tex_pos_1&#39; 是中心 2x2 块左上角纹素的坐标。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">tex_pos_1</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">sample_position</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// &#39;f&#39; 是相对 &#39;tex_pos_1&#39; 的分数偏移量，用于插值计算。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">f</span> <span class="o">=</span> <span class="n">sample_position</span> <span class="o">-</span> <span class="n">tex_pos_1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 计算 Catmull-Rom 样条权重。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这是四个标准的 1D Catmull-Rom 核函数权重，根据分数偏移量 &#39;f&#39; 分别为 x 和 y 轴计算。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">w0</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">+</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">w1</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">f</span> <span class="o">*</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mf">2.5</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">+</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">-</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">w3</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 合并中间样本的权重并计算新的偏移量。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这是优化的核心。我们合并中间两个样本 (w1, w2) 的权重，并计算一个新的偏移量，</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 从而利用硬件的双线性插值器在一次拾取中完成采样。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">w12</span> <span class="o">=</span> <span class="n">w1</span> <span class="o">+</span> <span class="n">w2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">offset_12</span> <span class="o">=</span> <span class="n">w2</span> <span class="o">/</span> <span class="n">w12</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4. 计算最终用于采样的 3x3 UV 坐标网格。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 现在我们不再需要 4x4 的网格，只需在 3x3 的位置上采样。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">tex_pos_0</span> <span class="o">=</span> <span class="n">tex_pos_1</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">tex_pos_3</span> <span class="o">=</span> <span class="n">tex_pos_1</span> <span class="o">+</span> <span class="mf">2.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec2</span> <span class="n">tex_pos_12</span> <span class="o">=</span> <span class="n">tex_pos_1</span> <span class="o">+</span> <span class="n">offset_12</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将坐标归一化到 [0, 1] 范围以便进行纹理拾取。</span>
</span></span><span class="line"><span class="cl">    <span class="n">tex_pos_0</span> <span class="o">/=</span> <span class="n">resolution</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">tex_pos_3</span> <span class="o">/=</span> <span class="n">resolution</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">tex_pos_12</span> <span class="o">/=</span> <span class="n">resolution</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 5. 执行 9 次纹理拾取并应用权重。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 我们在计算出的 9 个 UV 坐标上对纹理进行采样，并乘以相应的组合权重，以计算出最终颜色。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">result</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 第 0 行</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">+=</span> <span class="n">textureLod</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">texture_index</span><span class="p">)],</span> <span class="k">vec2</span><span class="p">(</span><span class="n">tex_pos_0</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tex_pos_0</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="mo">0</span><span class="p">).</span><span class="n">rgb</span>   <span class="o">*</span> <span class="n">w0</span><span class="p">.</span><span class="n">x</span>  <span class="o">*</span> <span class="n">w0</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">+=</span> <span class="n">textureLod</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">texture_index</span><span class="p">)],</span> <span class="k">vec2</span><span class="p">(</span><span class="n">tex_pos_12</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tex_pos_0</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="mo">0</span><span class="p">).</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">w12</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">w0</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">+=</span> <span class="n">textureLod</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">texture_index</span><span class="p">)],</span> <span class="k">vec2</span><span class="p">(</span><span class="n">tex_pos_3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tex_pos_0</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="mo">0</span><span class="p">).</span><span class="n">rgb</span>  <span class="o">*</span> <span class="n">w3</span><span class="p">.</span><span class="n">x</span>  <span class="o">*</span> <span class="n">w0</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 第 1 行</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">+=</span> <span class="n">textureLod</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">texture_index</span><span class="p">)],</span> <span class="k">vec2</span><span class="p">(</span><span class="n">tex_pos_0</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tex_pos_12</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="mo">0</span><span class="p">).</span><span class="n">rgb</span>   <span class="o">*</span> <span class="n">w0</span><span class="p">.</span><span class="n">x</span>  <span class="o">*</span> <span class="n">w12</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">+=</span> <span class="n">textureLod</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">texture_index</span><span class="p">)],</span> <span class="k">vec2</span><span class="p">(</span><span class="n">tex_pos_12</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tex_pos_12</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="mo">0</span><span class="p">).</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">w12</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">w12</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">+=</span> <span class="n">textureLod</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">texture_index</span><span class="p">)],</span> <span class="k">vec2</span><span class="p">(</span><span class="n">tex_pos_3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tex_pos_12</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="mo">0</span><span class="p">).</span><span class="n">rgb</span>  <span class="o">*</span> <span class="n">w3</span><span class="p">.</span><span class="n">x</span>  <span class="o">*</span> <span class="n">w12</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 第 2 行</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">+=</span> <span class="n">textureLod</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">texture_index</span><span class="p">)],</span> <span class="k">vec2</span><span class="p">(</span><span class="n">tex_pos_0</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tex_pos_3</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="mo">0</span><span class="p">).</span><span class="n">rgb</span>   <span class="o">*</span> <span class="n">w0</span><span class="p">.</span><span class="n">x</span>  <span class="o">*</span> <span class="n">w3</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">+=</span> <span class="n">textureLod</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">texture_index</span><span class="p">)],</span> <span class="k">vec2</span><span class="p">(</span><span class="n">tex_pos_12</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tex_pos_3</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="mo">0</span><span class="p">).</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">w12</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">w3</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">+=</span> <span class="n">textureLod</span><span class="p">(</span><span class="n">global_textures</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">texture_index</span><span class="p">)],</span> <span class="k">vec2</span><span class="p">(</span><span class="n">tex_pos_3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tex_pos_3</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="mo">0</span><span class="p">).</span><span class="n">rgb</span>  <span class="o">*</span> <span class="n">w3</span><span class="p">.</span><span class="n">x</span>  <span class="o">*</span> <span class="n">w3</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 6. 可选步骤：转换颜色空间。</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">use_ycocg</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span> <span class="o">=</span> <span class="n">rgb_to_ycocg</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">rgb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这个着色器（shader）使用 <strong>Catmull-Rom 样条</strong>来进行高质量的纹理过滤，这是一种三次插值（cubic interpolation）。该方法在视觉上比标准的双线性过滤更平滑，并避免了其他一些技术可能导致的过度模糊。这里的关键创新是一个极大地减少了所需纹理采样次数的优化。</p>
<h5 id="数学原理catmull-rom-样条">
<a class="header-anchor" href="#%e6%95%b0%e5%ad%a6%e5%8e%9f%e7%90%86catmull-rom-%e6%a0%b7%e6%9d%a1"></a>
数学原理：Catmull-Rom 样条
</h5><p>双三次滤波（Bicubic filtering）的原理是，通过一个 4x4 的纹素（texel）网格拟合出一条平滑曲线，从而找到特定 UV 坐标上的颜色。这通常需要先沿着一个轴（如水平方向）进行四次插值，然后用得到的结果在另一个轴（垂直方向）上进行最终的一次插值。</p>
<p>Catmull-Rom 插值公式根据一个分数距离 $f$ 和四个控制点 ($P_0, P_1, P_2, P_3$) 来计算一个点 $P$。最终值是一个加权和：</p>
<p>$P(f) = w_0 P_0 + w_1 P_1 + w_2 P_2 + w_3 P_3$</p>
<p>权重 ($w_0, w_1, w_2, w_3$) 是从 $f$ 推导出的三次多项式。代码为 x 和 y 轴预先计算了这些权重：</p>
<ul>
<li>$w_0(f) = -0.5f + f^2 - 0.5f^3$</li>
<li>$w_1(f) = 1 - 2.5f^2 + 1.5f^3$</li>
<li>$w_2(f) = 0.5f + 2f^2 - 1.5f^3$</li>
<li>$w_3(f) = -0.5f^2 + 0.5f^3$</li>
</ul>
<p>代码中的 <code>vec2 w0</code>, <code>w1</code>, <code>w2</code>, 和 <code>w3</code> 存储了这四个权重，其 <code>.x</code> 分量用于水平轴，<code>.y</code> 分量用于垂直轴。</p>
<p>这段代码中最精彩的优化是将所需的纹理拾取（texture fetch）次数从 16 次（对应 4x4 网格）大幅减少到 9 次。它通过巧妙地利用 GPU 内置的<strong>双线性过滤（bilinear filtering）硬件</strong>来实现这一点。</p>
<p>标准的 1D Catmull-Rom 插值需要四个纹素值：$T_0, T_1, T_2, T_3$。插值结果为：
$C = w_0 T_0 + w_1 T_1 + w_2 T_2 + w_3 T_3$</p>
<p>优化的重点在于中间的两个纹素 $T_1$ 和 $T_2$。它们贡献的部分是 $w_1 T_1 + w_2 T_2$。这个表达式可以改写为：</p>
<p>$w_1 T_1 + w_2 T_2 = (w_1 + w_2) \left( \frac{w_1}{w_1 + w_2} T_1 + \frac{w_2}{w_1 + w_2} T_2 \right)$</p>
<p>请注意括号中的部分：这是 $T_1$ 和 $T_2$ 之间的<strong>线性插值</strong>。这恰好是 GPU 的纹理采样器在两个纹素之间拾取纹理（即双线性过滤）时所做的工作！</p>
<ol>
<li><strong>组合权重</strong>：代码计算一个新的组合权重 <code>w12 = w1 + w2</code>。</li>
<li><strong>新偏移量</strong>：代码计算一个新的采样偏移 <code>offset_12 = w2 / w12</code>。这个偏移量精确地告诉 GPU 应该在纹素 $T_1$ 和 $T_2$ 之间的哪个位置进行采样，以获得我们想要的线性插值结果。</li>
<li><strong>单次拾取</strong>：通过在 <code>tex_pos_1 + offset_12</code> 位置采样，我们用<strong>一次纹理拾取</strong>就得到了括号中表达式的结果。</li>
</ol>
<p>这个技巧将每行/每列的四次采样减少到三次。当在二维（x 和 y 轴）上都应用这个技巧时，总的拾取次数就从 $4 \times 4 = 16$ 次减少到 $3 \times 3 = 9$ 次，从而在保持高质量视觉效果的同时，显著提升了性能。</p>
<h4 id="clip-aabb-函数">
<a class="header-anchor" href="#clip-aabb-%e5%87%bd%e6%95%b0"></a>
Clip AABB 函数
</h4><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// &#34;Inside&#34; 游戏中使用的优化版 AABB 裁剪函数。</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 该函数将一个点裁剪到一个轴对齐包围盒（AABB）的边界内。</span>
</span></span><span class="line"><span class="cl"><span class="k">vec4</span> <span class="n">clip_aabb</span><span class="p">(</span><span class="k">vec3</span> <span class="n">aabb_min</span><span class="p">,</span> <span class="k">vec3</span> <span class="n">aabb_max</span><span class="p">,</span> <span class="k">vec4</span> <span class="n">previous_sample</span><span class="p">,</span> <span class="k">float</span> <span class="n">average_alpha</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 注意：此方法总是将点朝向 AABB 的中心进行裁剪，但速度非常快！</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 计算 AABB 的中心点 (p_clip) 和半尺寸向量（范围, extents）。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这是表示 AABB 的一种常用且高效的方式。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">p_clip</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">aabb_max</span> <span class="o">+</span> <span class="n">aabb_min</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">e_clip</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">aabb_max</span> <span class="o">-</span> <span class="n">aabb_min</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.0000001</span><span class="p">;</span> <span class="c1">// 加上一个极小值以防止除以零</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 计算点相对于 AABB 中心的向量。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 我们在四维空间中进行计算，以同时处理位置（xyz）和 alpha 值（w）。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">v_clip</span> <span class="o">=</span> <span class="n">previous_sample</span> <span class="o">-</span> <span class="k">vec4</span><span class="p">(</span><span class="n">p_clip</span><span class="p">,</span> <span class="n">average_alpha</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 将向量归一化到 AABB 的单位空间内，并计算其 L-∞ 范数。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// &#39;v_unit&#39; 是点在 AABB 的局部坐标系中的位置，其中 AABB 本身变成了一个从 [-1, -1, -1] 到 [1, 1, 1] 的单位立方体。</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">v_unit</span> <span class="o">=</span> <span class="n">v_clip</span><span class="p">.</span><span class="n">xyz</span> <span class="o">/</span> <span class="n">e_clip</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">a_unit</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">v_unit</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// &#39;ma_unit&#39; 是点在单位化空间中的切比雪夫距离（Chebyshev distance），也称为 L-∞ 范数。</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 它表示所有坐标轴分量中的最大值。</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">ma_unit</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">a_unit</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">a_unit</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">a_unit</span><span class="p">.</span><span class="n">z</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4. 判断点是否在 AABB 外部，如果是，则将其拉回边界。</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ma_unit</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果 ma_unit &gt; 1.0，说明点在单位立方体之外，即在 AABB 之外。</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 我们通过除以 ma_unit 来缩放从中心出发的向量 v_clip，</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 从而将点精确地投射回 AABB 的边界上。</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">vec4</span><span class="p">(</span><span class="n">p_clip</span><span class="p">,</span> <span class="n">average_alpha</span><span class="p">)</span> <span class="o">+</span> <span class="n">v_clip</span> <span class="o">/</span> <span class="n">ma_unit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果 ma_unit &lt;= 1.0，说明点在 AABB 内部，无需裁剪。</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">previous_sample</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这个函数实现了一种非常快速的算法，用于将一个点“拉回”到一个轴对齐包围盒（AABB）的边界内。它因其在著名游戏《Inside》中的使用而为人所知。其核心思想是<strong>空间变换</strong>和利用<strong>切比雪夫距离</strong>进行判断，从而避免了传统方法中复杂的、逐个平面的裁剪测试。</p>
<h5 id="关键技术与数学原理">
<a class="header-anchor" href="#%e5%85%b3%e9%94%ae%e6%8a%80%e6%9c%af%e4%b8%8e%e6%95%b0%e5%ad%a6%e5%8e%9f%e7%90%86"></a>
关键技术与数学原理
</h5><p>该算法的巧妙之处在于，它将针对任意 AABB 的裁剪问题，转化为一个针对单位立方体的、非常简单的裁剪问题。</p>
<p><strong>1. AABB 的中心-范围表示法 (Center-Extents Representation)</strong></p>
<p>代码首先没有直接使用 <code>aabb_min</code> 和 <code>aabb_max</code>，而是计算出了 AABB 的<strong>中心点 <code>p_clip</code></strong> 和<strong>半尺寸向量（或称范围）<code>e_clip</code></strong>。</p>
<ul>
<li><strong>中心 <code>p_clip</code></strong>: $(aabb_{max} + aabb_{min}) / 2$</li>
<li><strong>范围 <code>e_clip</code></strong>: $(aabb_{max} - aabb_{min}) / 2$</li>
</ul>
<p>这种表示法在后续计算中更为方便。</p>
<p><strong>2. 空间归一化 (Space Normalization)</strong></p>
<p>接下来是最关键的一步。代码计算了从 AABB 中心 <code>p_clip</code> 指向采样点 <code>previous_sample</code> 的向量 <code>v_clip</code>，然后用 AABB 的范围 <code>e_clip</code> 去除它：</p>
<p><code>vec3 v_unit = v_clip.xyz / e_clip;</code></p>
<p>这个除法操作在几何上等同于进行一次<strong>非均匀缩放</strong>。它将整个坐标系进行变换，使得原来的 AABB 在这个新的“单位空间”里，变成了一个<strong>中心在原点、大小为 2x2x2 的单位立方体</strong>（即从 <code>[-1,-1,-1]</code> 到 <code>[1,1,1]</code>）。而 <code>v_unit</code> 就是原始点在这个新空间中的坐标。</p>
<p><strong>3. 切比雪夫距离 (Chebyshev Distance)</strong></p>
<p>在单位立方体空间中，判断一个点是否在立方体内变得异常简单。一个点在立方体内，当且仅当它的 x, y, z 坐标的绝对值都小于等于 1。</p>
<p>代码计算的 <code>ma_unit</code> 正是这个判断依据：</p>
<p><code>float ma_unit = max(abs(v_unit.x), max(abs(v_unit.y), abs(v_unit.z)));</code></p>
<p>这个值在数学上被称为<strong>切比雪夫距离</strong>或 <strong>$L_∞$ 范数</strong>。</p>
<ul>
<li>如果 <code>ma_unit &lt;= 1.0</code>，说明点的所有分量都在 <code>[-1, 1]</code> 区间内，点位于 AABB <strong>内部</strong>。</li>
<li>如果 <code>ma_unit &gt; 1.0</code>，说明点至少有一个分量超出了 <code>[-1, 1]</code> 区间，点位于 AABB <strong>外部</strong>。</li>
</ul>
<p><strong>4. 投影裁剪 (Projection Clipping)</strong></p>
<p>当点在外部时 (<code>ma_unit &gt; 1.0</code>)，代码执行以下操作：</p>
<p><code>return vec4(p_clip, average_alpha) + v_clip / ma_unit;</code></p>
<p>这里的 <code>v_clip / ma_unit</code> 是一个非常精妙的计算。由于 <code>ma_unit</code> 是 <code>v_clip</code> 在单位空间中“超出”边界的比例，将原始的 <code>v_clip</code> 向量除以 <code>ma_unit</code>，会将其<strong>等比例缩短</strong>，使得其缩短后的终点<strong>恰好落在 AABB 的边界上</strong>。这个投影的方向始终是<strong>从 AABB 的中心指向原始点</strong>。</p>
<p><strong>总结</strong>：该算法通过一次向量减法、一次向量除法和一次最大值比较，就完成了裁剪判断和操作，完全避免了分支和复杂的几何测试，因此执行效率极高。其唯一的“限制”是裁剪方向固定为朝向包围盒中心，但这在许多图形学应用（如体积雾、TAA等）中是完全可以接受的。</p>

      
    </div>
    <footer class="article-footer">
      

      

      

      

      

      

      
      <ul class="article-tag-list" itemprop="keywords">
  
</ul>

    </footer>
  </div>
  
    
  <nav
    id="article-nav"
    data-aos="fade-up"
  >
    
      <div class="article-nav-link-wrap article-nav-link-left">
        
          
          
            <img
              data-src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202412220910158.jpg"
              data-sizes="auto"
              alt="Temporal Anti-Aliasing稳定性探究"
              class="lazyload"
            />
          
        
        <a href="https://nothingtosay0031.github.io/post/taa/"></a>
        <div class="article-nav-caption">Newer</div>
        <h3 class="article-nav-title">
          
            Temporal Anti-Aliasing稳定性探究
          
        </h3>
      </div>
    

    
      <div class="article-nav-link-wrap article-nav-link-right">
        
          
          
            <img
              data-src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202412220910158.jpg"
              data-sizes="auto"
              alt="Unreal Engine 与着色器卡顿：PSO 预缓存解决方案"
              class="lazyload"
            />
          
        
        <a href="https://nothingtosay0031.github.io/post/ue_pso/"></a>
        <div class="article-nav-caption">Older</div>
        <h3 class="article-nav-title">
          
            Unreal Engine 与着色器卡顿：PSO 预缓存解决方案
          
        </h3>
      </div>
    
  </nav>


  
</article>










</section>
          
            <aside id="sidebar">
  <div class="sidebar-wrapper wrap-sticky">
    <div
      class="sidebar-wrap"
      data-aos="fade-up"
    >
      
        <div class="sidebar-toc-sidebar">
          <div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#dynamic-diffuse-global-illumination-ddgi">Dynamic Diffuse Global Illumination (DDGI)</a>
      <ul>
        <li><a href="#工作流程">工作流程</a></li>
        <li><a href="#辐射度采集-gather-radiance">辐射度采集 (Gather Radiance)</a>
          <ul>
            <li><a href="#数据流与gpu调度">数据流与GPU调度</a></li>
            <li><a href="#ray-generation-shader-射线生成着色器">Ray Generation Shader (射线生成着色器)</a></li>
            <li><a href="#closest-hit-shader-最近命中着色器">Closest Hit Shader (最近命中着色器)</a></li>
            <li><a href="#miss-shader-未命中着色器">Miss Shader (未命中着色器)</a></li>
          </ul>
        </li>
        <li><a href="#核心辅助函数-core-helper-functions">核心辅助函数 (Core Helper Functions)</a>
          <ul>
            <li><a href="#球面斐波那契采样-spherical-fibonacci-sampling">球面斐波那契采样 (Spherical Fibonacci Sampling)</a></li>
            <li><a href="#八面体映射-octahedral-mapping">八面体映射 (Octahedral Mapping)</a></li>
            <li><a href="#探针网格与世界空间变换">探针网格与世界空间变换</a></li>
            <li><a href="#探针图集坐标计算-probe-atlas-coordinates">探针图集坐标计算 (Probe Atlas Coordinates)</a></li>
          </ul>
        </li>
        <li><a href="#更新辐照度与可见性-update-irradiance-and-visibility">更新辐照度与可见性 (Update Irradiance and Visibility)</a>
          <ul>
            <li><a href="#cpu端调度">CPU端调度</a></li>
            <li><a href="#计算着色器详解">计算着色器详解</a>
              <ul>
                <li><a href="#核心计算探针内部像素">核心计算（探针内部像素）</a></li>
                <li><a href="#边界处理探针边缘像素">边界处理（探针边缘像素）</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#采样-irradiance-probes">采样 Irradiance Probes</a>
          <ul>
            <li><a href="#三线性插值-trilinear-interpolation">三线性插值 (Trilinear Interpolation)</a></li>
            <li><a href="#方差阴影贴图-variance-shadow-mapping---vsm">方差阴影贴图 (Variance Shadow Mapping - VSM)</a></li>
            <li><a href="#切比雪夫不等式-chebyshevs-inequality">切比雪夫不等式 (Chebyshev&rsquo;s Inequality)</a></li>
          </ul>
        </li>
        <li><a href="#计算探针的偏移和状态">计算探针的偏移和状态</a>
          <ul>
            <li><a href="#更新探针偏移">更新探针偏移</a></li>
            <li><a href="#更新探针状态">更新探针状态</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#ray-traced-shadows">Ray Traced Shadows</a>
      <ul>
        <li><a href="#工作流程-1">工作流程</a></li>
        <li><a href="#计算可见性方差">计算可见性方差</a></li>
        <li><a href="#计算阴影可见性">计算阴影可见性</a>
          <ul>
            <li><a href="#motion-vectors">Motion Vectors</a>
              <ul>
                <li><a href="#第一部分计算标准运动矢量-用于taa">第一部分：计算标准运动矢量 (用于TAA)</a></li>
                <li><a href="#第二部分计算可见性运动矢量-用于阴影">第二部分：计算可见性运动矢量 (用于阴影)</a></li>
              </ul>
            </li>
            <li><a href="#光线追踪辅助函数">光线追踪辅助函数</a></li>
            <li><a href="#共享内存优化-shared-memory">共享内存优化 (Shared Memory)</a></li>
            <li><a href="#空间滤波扩张与平滑">空间滤波：扩张与平滑</a></li>
            <li><a href="#采样数估算的时间滞后效应-hysteresis">采样数估算的“时间滞后效应” (Hysteresis)</a></li>
          </ul>
        </li>
        <li><a href="#降噪">降噪</a>
          <ul>
            <li><a href="#关键技术与原理">关键技术与原理</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#ray-traced-reflections">Ray Traced Reflections</a>
      <ul>
        <li><a href="#工作流程-2">工作流程</a></li>
        <li><a href="#reflections-shaders">Reflections Shaders</a>
          <ul>
            <li><a href="#光线生成着色器-ray-generation-shader">光线生成着色器 (Ray Generation Shader)</a></li>
            <li><a href="#最近命中与未命中着色器-closest-hit--miss-shaders">最近命中与未命中着色器 (Closest-Hit &amp; Miss Shaders)</a></li>
            <li><a href="#核心原理与关键技术">核心原理与关键技术</a>
              <ul>
                <li><a href="#基于物理的反射与-ggx-vndf-采样">基于物理的反射与 GGX-VNDF 采样</a></li>
                <li><a href="#光源重要性采样-many-light-importance-sampling">光源重要性采样 (Many-Light Importance Sampling)</a></li>
                <li><a href="#手动属性获取与lod计算">手动属性获取与LOD计算</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#svgf-降噪">SVGF 降噪</a>
          <ul>
            <li><a href="#accumulation-pass">Accumulation Pass</a>
              <ul>
                <li><a href="#核心原理与关键技术-1">核心原理与关键技术</a>
                  <ul>
                    <li><a href="#时间累积与历史拒绝-temporal-accumulation--history-rejection">时间累积与历史拒绝 (Temporal Accumulation &amp; History Rejection)</a></li>
                    <li><a href="#基于矩的方差估计-moment-based-variance-estimation">基于矩的方差估计 (Moment-based Variance Estimation)</a></li>
                    <li><a href="#使用fwidth自适应设置阈值">使用<code>fwidth</code>自适应设置阈值</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#variance-pass">Variance Pass</a>
              <ul>
                <li><a href="#如何映射到代码">如何映射到代码</a></li>
              </ul>
            </li>
            <li><a href="#wavelet-pass">Wavelet Pass</a>
              <ul>
                <li><a href="#à-trous-带孔-小波滤波">À-trous (带孔) 小波滤波</a></li>
                <li><a href="#交叉双边滤波-cross-bilateral-filter">交叉双边滤波 (Cross-Bilateral Filter)</a></li>
                <li><a href="#方差引导滤波-variance-guided-filtering">方差引导滤波 (Variance-Guided Filtering)</a></li>
              </ul>
            </li>
            <li><a href="#downsample-pass">Downsample Pass</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#temporal-anti-aliasing-taa">Temporal Anti-Aliasing (TAA)</a>
      <ul>
        <li><a href="#工作流程-3">工作流程</a></li>
        <li><a href="#temporal-anti-aliasing">Temporal Anti-Aliasing</a>
          <ul>
            <li><a href="#核心原理与关键技术详解">核心原理与关键技术详解</a>
              <ul>
                <li><a href="#邻域加权采样">邻域加权采样</a></li>
                <li><a href="#历史约束的所有模式">历史约束的所有模式</a></li>
                <li><a href="#动态混合权重">动态混合权重</a>
                  <ul>
                    <li><a href="#基于对比度的自适应滤波-contrast-adaptive-filtering">基于对比度的自适应滤波 (Contrast-Adaptive Filtering)</a></li>
                    <li><a href="#基于亮度的权重调整-luminance-based-weight-adjustment">基于亮度的权重调整 (Luminance-Based Weight Adjustment)</a></li>
                  </ul>
                </li>
                <li><a href="#catmull-rom-滤波优化">Catmull-Rom 滤波优化</a>
                  <ul>
                    <li><a href="#数学原理catmull-rom-样条">数学原理：Catmull-Rom 样条</a></li>
                  </ul>
                </li>
                <li><a href="#clip-aabb-函数">Clip AABB 函数</a>
                  <ul>
                    <li><a href="#关键技术与数学原理">关键技术与数学原理</a></li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
        </div>
        <div class="sidebar-common-sidebar hidden">
          
<div class="sidebar-author">
  <img
    data-src="https://nothingtosay0031.github.io/avatar/../avatar.webp"
    data-sizes="auto"
    alt="NothingToSay0031"
    class="lazyload"
  />
  <div class="sidebar-author-name">NothingToSay0031</div>
  <div class="sidebar-description">又是一个做水果蛋糕的好天气啊！</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div>
    
    <div class="sidebar-state-number">24</div>
  </div>
  <div class="sidebar-state-category">
    <div>Categories</div>
    <div class="sidebar-state-number">
      0
    </div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tags</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-email sidebar-social-icon">
      <a
        href="mailto:jhwzju@gmail.com"
        itemprop="url"
        target="_blank"
        aria-label="email"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-github sidebar-social-icon">
      <a
        href="https://github.com/NothingToSay0031"
        itemprop="url"
        target="_blank"
        aria-label="github"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-linkedin sidebar-social-icon">
      <a
        href="https://www.linkedin.com/in/hongweiji"
        itemprop="url"
        target="_blank"
        aria-label="linkedin"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/"
        aria-label="Home"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Home</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/archives"
        aria-label="Archives"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Archives</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/about"
        aria-label="About"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">About</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/friend"
        aria-label="Friend"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Friend</div>
    </div>
  
</div>

        </div>
      

      
        <div class="sidebar-btn-wrapper" style="position:static">
          <div class="sidebar-toc-btn current"></div>
          <div class="sidebar-common-btn"></div>
        </div>
      
    </div>
  </div>

  
</aside>

          
        </main>
        



  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  



<footer id="footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div id="footer-info">
    <div>
      <span class="icon-copyright"></span>
      2021 -
      2025
      <span class="footer-info-sep rotate"></span>
      NothingToSay0031
    </div>
    
      <div>
        Powered by&nbsp;<a
          href="https://gohugo.io/"
          target="_blank"
          >Hugo</a
        >&nbsp; Theme.<a
          href="https://github.com/D-Sketon/hugo-theme-reimu"
          target="_blank"
          >Reimu</a
        >
      </div>
    
    
      <div>
        <span class="icon-brush"
          >&nbsp;
            66.9k
          </span
        >
        &nbsp;|&nbsp;
        <span class="icon-coffee">&nbsp;
          
          

          05:27
        </span>
      </div>
    
    
    
    
      <div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv"
          >Number of visits&nbsp;<span
            id="busuanzi_value_site_pv"
          ></span
        ></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv"
          >Number of visitors&nbsp;<span
            id="busuanzi_value_site_uv"
          ></span
        ></span>
      </div>
    
  </div>
</footer>

        
          <div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div>
        
        <div id="mask" class="hide"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar">
        <div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#dynamic-diffuse-global-illumination-ddgi">Dynamic Diffuse Global Illumination (DDGI)</a>
      <ul>
        <li><a href="#工作流程">工作流程</a></li>
        <li><a href="#辐射度采集-gather-radiance">辐射度采集 (Gather Radiance)</a>
          <ul>
            <li><a href="#数据流与gpu调度">数据流与GPU调度</a></li>
            <li><a href="#ray-generation-shader-射线生成着色器">Ray Generation Shader (射线生成着色器)</a></li>
            <li><a href="#closest-hit-shader-最近命中着色器">Closest Hit Shader (最近命中着色器)</a></li>
            <li><a href="#miss-shader-未命中着色器">Miss Shader (未命中着色器)</a></li>
          </ul>
        </li>
        <li><a href="#核心辅助函数-core-helper-functions">核心辅助函数 (Core Helper Functions)</a>
          <ul>
            <li><a href="#球面斐波那契采样-spherical-fibonacci-sampling">球面斐波那契采样 (Spherical Fibonacci Sampling)</a></li>
            <li><a href="#八面体映射-octahedral-mapping">八面体映射 (Octahedral Mapping)</a></li>
            <li><a href="#探针网格与世界空间变换">探针网格与世界空间变换</a></li>
            <li><a href="#探针图集坐标计算-probe-atlas-coordinates">探针图集坐标计算 (Probe Atlas Coordinates)</a></li>
          </ul>
        </li>
        <li><a href="#更新辐照度与可见性-update-irradiance-and-visibility">更新辐照度与可见性 (Update Irradiance and Visibility)</a>
          <ul>
            <li><a href="#cpu端调度">CPU端调度</a></li>
            <li><a href="#计算着色器详解">计算着色器详解</a>
              <ul>
                <li><a href="#核心计算探针内部像素">核心计算（探针内部像素）</a></li>
                <li><a href="#边界处理探针边缘像素">边界处理（探针边缘像素）</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#采样-irradiance-probes">采样 Irradiance Probes</a>
          <ul>
            <li><a href="#三线性插值-trilinear-interpolation">三线性插值 (Trilinear Interpolation)</a></li>
            <li><a href="#方差阴影贴图-variance-shadow-mapping---vsm">方差阴影贴图 (Variance Shadow Mapping - VSM)</a></li>
            <li><a href="#切比雪夫不等式-chebyshevs-inequality">切比雪夫不等式 (Chebyshev&rsquo;s Inequality)</a></li>
          </ul>
        </li>
        <li><a href="#计算探针的偏移和状态">计算探针的偏移和状态</a>
          <ul>
            <li><a href="#更新探针偏移">更新探针偏移</a></li>
            <li><a href="#更新探针状态">更新探针状态</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#ray-traced-shadows">Ray Traced Shadows</a>
      <ul>
        <li><a href="#工作流程-1">工作流程</a></li>
        <li><a href="#计算可见性方差">计算可见性方差</a></li>
        <li><a href="#计算阴影可见性">计算阴影可见性</a>
          <ul>
            <li><a href="#motion-vectors">Motion Vectors</a>
              <ul>
                <li><a href="#第一部分计算标准运动矢量-用于taa">第一部分：计算标准运动矢量 (用于TAA)</a></li>
                <li><a href="#第二部分计算可见性运动矢量-用于阴影">第二部分：计算可见性运动矢量 (用于阴影)</a></li>
              </ul>
            </li>
            <li><a href="#光线追踪辅助函数">光线追踪辅助函数</a></li>
            <li><a href="#共享内存优化-shared-memory">共享内存优化 (Shared Memory)</a></li>
            <li><a href="#空间滤波扩张与平滑">空间滤波：扩张与平滑</a></li>
            <li><a href="#采样数估算的时间滞后效应-hysteresis">采样数估算的“时间滞后效应” (Hysteresis)</a></li>
          </ul>
        </li>
        <li><a href="#降噪">降噪</a>
          <ul>
            <li><a href="#关键技术与原理">关键技术与原理</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#ray-traced-reflections">Ray Traced Reflections</a>
      <ul>
        <li><a href="#工作流程-2">工作流程</a></li>
        <li><a href="#reflections-shaders">Reflections Shaders</a>
          <ul>
            <li><a href="#光线生成着色器-ray-generation-shader">光线生成着色器 (Ray Generation Shader)</a></li>
            <li><a href="#最近命中与未命中着色器-closest-hit--miss-shaders">最近命中与未命中着色器 (Closest-Hit &amp; Miss Shaders)</a></li>
            <li><a href="#核心原理与关键技术">核心原理与关键技术</a>
              <ul>
                <li><a href="#基于物理的反射与-ggx-vndf-采样">基于物理的反射与 GGX-VNDF 采样</a></li>
                <li><a href="#光源重要性采样-many-light-importance-sampling">光源重要性采样 (Many-Light Importance Sampling)</a></li>
                <li><a href="#手动属性获取与lod计算">手动属性获取与LOD计算</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#svgf-降噪">SVGF 降噪</a>
          <ul>
            <li><a href="#accumulation-pass">Accumulation Pass</a>
              <ul>
                <li><a href="#核心原理与关键技术-1">核心原理与关键技术</a>
                  <ul>
                    <li><a href="#时间累积与历史拒绝-temporal-accumulation--history-rejection">时间累积与历史拒绝 (Temporal Accumulation &amp; History Rejection)</a></li>
                    <li><a href="#基于矩的方差估计-moment-based-variance-estimation">基于矩的方差估计 (Moment-based Variance Estimation)</a></li>
                    <li><a href="#使用fwidth自适应设置阈值">使用<code>fwidth</code>自适应设置阈值</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#variance-pass">Variance Pass</a>
              <ul>
                <li><a href="#如何映射到代码">如何映射到代码</a></li>
              </ul>
            </li>
            <li><a href="#wavelet-pass">Wavelet Pass</a>
              <ul>
                <li><a href="#à-trous-带孔-小波滤波">À-trous (带孔) 小波滤波</a></li>
                <li><a href="#交叉双边滤波-cross-bilateral-filter">交叉双边滤波 (Cross-Bilateral Filter)</a></li>
                <li><a href="#方差引导滤波-variance-guided-filtering">方差引导滤波 (Variance-Guided Filtering)</a></li>
              </ul>
            </li>
            <li><a href="#downsample-pass">Downsample Pass</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#temporal-anti-aliasing-taa">Temporal Anti-Aliasing (TAA)</a>
      <ul>
        <li><a href="#工作流程-3">工作流程</a></li>
        <li><a href="#temporal-anti-aliasing">Temporal Anti-Aliasing</a>
          <ul>
            <li><a href="#核心原理与关键技术详解">核心原理与关键技术详解</a>
              <ul>
                <li><a href="#邻域加权采样">邻域加权采样</a></li>
                <li><a href="#历史约束的所有模式">历史约束的所有模式</a></li>
                <li><a href="#动态混合权重">动态混合权重</a>
                  <ul>
                    <li><a href="#基于对比度的自适应滤波-contrast-adaptive-filtering">基于对比度的自适应滤波 (Contrast-Adaptive Filtering)</a></li>
                    <li><a href="#基于亮度的权重调整-luminance-based-weight-adjustment">基于亮度的权重调整 (Luminance-Based Weight Adjustment)</a></li>
                  </ul>
                </li>
                <li><a href="#catmull-rom-滤波优化">Catmull-Rom 滤波优化</a>
                  <ul>
                    <li><a href="#数学原理catmull-rom-样条">数学原理：Catmull-Rom 样条</a></li>
                  </ul>
                </li>
                <li><a href="#clip-aabb-函数">Clip AABB 函数</a>
                  <ul>
                    <li><a href="#关键技术与数学原理">关键技术与数学原理</a></li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
      </div>
      <div class="sidebar-common-sidebar hidden">
        
<div class="sidebar-author">
  <img
    data-src="https://nothingtosay0031.github.io/avatar/../avatar.webp"
    data-sizes="auto"
    alt="NothingToSay0031"
    class="lazyload"
  />
  <div class="sidebar-author-name">NothingToSay0031</div>
  <div class="sidebar-description">又是一个做水果蛋糕的好天气啊！</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div>
    
    <div class="sidebar-state-number">24</div>
  </div>
  <div class="sidebar-state-category">
    <div>Categories</div>
    <div class="sidebar-state-number">
      0
    </div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tags</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-email sidebar-social-icon">
      <a
        href="mailto:jhwzju@gmail.com"
        itemprop="url"
        target="_blank"
        aria-label="email"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-github sidebar-social-icon">
      <a
        href="https://github.com/NothingToSay0031"
        itemprop="url"
        target="_blank"
        aria-label="github"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-linkedin sidebar-social-icon">
      <a
        href="https://www.linkedin.com/in/hongweiji"
        itemprop="url"
        target="_blank"
        aria-label="linkedin"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/"
        aria-label="Home"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Home</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/archives"
        aria-label="Archives"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Archives</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/about"
        aria-label="About"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">About</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/friend"
        aria-label="Friend"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Friend</div>
    </div>
  
</div>

      </div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    
    






  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js"
    
    
    
    
    integrity="sha384-3gT/vsepWkfz/ff7PpWNUeMzeWoH3cDhm/A8jM7ouoAK0/fP/9bcHHR5kHq2nf&#43;e" crossorigin="anonymous"
  ></script>




  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js"
    
    
    
    
    integrity="sha384-J08i8An/QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"
  ></script>









  
      
      <script src="https://nothingtosay0031.github.io/js/main.js" integrity="" crossorigin="anonymous" ></script>
      



  





  
      
      <script src="https://nothingtosay0031.github.io/js/aos.js" integrity="" crossorigin="anonymous" ></script>
      

  <script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", aosInit);
    } else {
      aosInit();
    }
  </script>








  
      
      <script src="https://nothingtosay0031.github.io/js/pjax_main.js" integrity="" crossorigin="anonymous" data-pjax></script>
      





  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/mouse-firework@0.0.6/dist/index.umd.js"
    
    
    
    
    integrity="sha384-vkGvf25gm1C1PbcoD5dNfc137HzNL/hr1RKA5HniJOaawtvUmH5lTVFgFAruE9Ge" crossorigin="anonymous"
  ></script>


<script>
  if (window.firework) {
    const options = JSON.parse("{\"excludeelements\":[\"a\",\"button\"],\"particles\":[{\"colors\":[\"#ff5252\",\"#ff7c7c\",\"#ffafaf\",\"#ffd0d0\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"emit\"],\"number\":20,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.3,0.5],\"radius\":[16,32]}},{\"colors\":[\"#ff0000\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"diffuse\"],\"number\":1,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.2,0.5],\"lineWidth\":6,\"radius\":20}}]}");
    options.excludeElements = options.excludeelements;
    delete options.excludeelements;
    window.firework(options);
  }
</script>








<div id="lazy-script">
  <div>
    
    
      





  
      
      <script src="https://nothingtosay0031.github.io/js/insert_highlight.js" integrity="" crossorigin="anonymous" data-pjax></script>
      

      
      
      
      
      <script type="module" data-pjax>
        const PhotoSwipeLightbox = (await safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe-lightbox.esm.min.js", "sha384-DiL6M\/gG\u002bwmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF\/N6lrZi\/")).default;

        const pswp = () => {
          if (_$$('.article-entry a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-entry',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")
            }).init();
          }
          if(_$$('.article-gallery a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-gallery',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")
            }).init();
          }
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script>
      












    
    
      
        

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/katex@0.16.9/dist/katex.min.js"
    
    
    data-pjax
    
    integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8" crossorigin="anonymous"
  ></script>


        

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/katex@0.16.9/dist/contrib/auto-render.min.js"
    
    
    data-pjax
    
    integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05" crossorigin="anonymous"
  ></script>


        <script data-pjax>
          var renderMath = () => {
            if (!window.renderMathInElement) return;
            window.renderMathInElement(document.body, {
              delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "\\[", right: "\\]", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
              ],
            });
          };
          if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", renderMath, { once: true });
          } else {
            renderMath();
          }
        </script>
      
      
    
  </div>
</div>




  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js"
    
    async
    
    
    integrity="sha384-0M75wtSkhjIInv4coYlaJU83&#43;OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id&#43;S" crossorigin="anonymous"
  ></script>





  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then((registrations) => {
        for (let registration of registrations) {
          registration.unregister();
        }
      });
    }
  </script>


<script>
  const reimuCopyright = String.raw`
   ______     ______     __     __    __     __  __    
  /\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
  \ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
   \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
    \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                    
  `;
  console.log(String.raw`%c ${reimuCopyright}`, "color: #ff5252;");
  console.log(
    "%c Theme.Reimu" + " %c https://github.com/D-Sketon/hugo-theme-reimu ",
    "color: white; background: #ff5252; padding:5px 0;",
    "padding:4px;border:1px solid #ff5252;",
  );
</script>

  </body>
</html>
