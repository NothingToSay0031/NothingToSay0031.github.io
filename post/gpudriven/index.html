<!doctype html>
<html
  lang="en-us"
  
>
  <head>
    <meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, shrink-to-fit=no"
/>







  

<title>
  GPU-Driven Rendering Pipelines and Clustered Tile-Based Deferred Shading | NothingToSay0031
</title>
<meta
  name="description"
  content="Two pass culling with mesh shader and clustered tile-based deferred shading in Vulkan."
/>










<script>
  window.siteConfig = JSON.parse("{\"anchor_icon\":null,\"clipboard\":{\"copyright\":{\"content\":\"本文版权：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！\",\"count\":50,\"enable\":false},\"fail\":\"复制失败 (ﾟ⊿ﾟ)ﾂ\",\"success\":\"复制成功(*^▽^*)\"},\"code_block\":{\"expand\":true},\"icon_font\":\"4552607_tq6stt6tcg\",\"outdate\":{\"daysago\":180,\"enable\":false,\"message\":\"本文最后更新于 {time}，请注意文中内容可能已经发生变化。\"}}");
</script>











  
  
  
    
  

  
  
  
    
  

  
    

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  rel="preload"
  as="style"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
/>
<link
  rel="stylesheet"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
  media="print"
  onload="this.media='all'"
/>






  <link
    rel="preload"
    href="//at.alicdn.com/t/c/font_4552607_tq6stt6tcg.woff2"
    as="font"
    type="font/woff2"
    crossorigin="anonymous"
  />



  







  
 <link rel="stylesheet" href="https://nothingtosay0031.github.io/css/loader.min.2ad0e9bbffb534e893c0ecefc44787a277cf851387e8ad9dccfbc3a5f0886dbe.css" />




  <meta property="og:type" content="website" />
  <meta property="og:title" content="GPU-Driven Rendering Pipelines and Clustered Tile-Based Deferred Shading | NothingToSay0031" />
  <meta
    property="og:description"
    content="Two pass culling with mesh shader and clustered tile-based deferred shading in Vulkan."
  />
  <meta property="og:url" content="https://nothingtosay0031.github.io/post/gpudriven/" />
  <meta
    property="og:site_name"
    content="NothingToSay0031"
  />
  <meta
    property="og:image"
    content="/"
  />
  <meta property="article:author" content="NothingToSay0031" />
  <meta property="article:published_time" content="2024-12-25T18:11:48&#43;00:00" />
  <meta property="article:modified_time" content="2024-12-25T18:11:48&#43;00:00" />
  
  
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:image" content="/" />
  
  
  
  
  




<link rel="shortcut icon" href="https://nothingtosay0031.github.io/favicon.ico">








  
 <link rel="stylesheet" href="https://nothingtosay0031.github.io/css/main.min.4e3ed4ec96a449612baa01e942ad2e62fab14c5e1e8f6b3eeb13d1cbc2e0dc67.css" />





  <link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css"
    onload="this.onload=null;this.rel='stylesheet'"
  />






  <link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/katex@0.16.9/dist/katex.min.css"
    onload="this.onload=null;this.rel='stylesheet'"
  />








  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js"
    
    
    
    
    integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"
  ></script>





  


  <link rel="stylesheet" href="https://npm.webcache.cn/@reimujs/aos@0.1.0/dist/aos.css" />




  </head>
  <body>
    
  <div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        
          <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
            <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="#ff5252" />
            <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z 
          M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95z" fill="#ff5252" />
          </svg>
        
      </div>
      <div class="loading-word">少女祈祷中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>


<div id="copy-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
</div>


    <div id="container">
      <div id="wrap">
        
<div id="header-nav">
  <nav id="main-nav">
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/">Home</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/archives">Archives</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/about">About</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="https://nothingtosay0031.github.io/friend">Friend</a>
      </span>
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
    
  </nav>
</div>
<header id="header">
  
    <img fetchpriority="high" src="https://nothingtosay0031.github.io/images/banner.webp" alt="GPU-Driven Rendering Pipelines and Clustered Tile-Based Deferred Shading">
  

  <div id="header-outer">
    <div id="header-title">
      
        
        
          
        
  
        
          <a href="https://nothingtosay0031.github.io/" id="logo">
            <h1 data-aos="slide-up">GPU-Driven Rendering Pipelines and Clustered Tile-Based Deferred Shading</h1>
          </a>
        
      
  
      
        
        
        <h2 id="subtitle-wrap" data-aos="slide-down">
          
        </h2>
      
    </div>
  </div>
</header>
        <main id="content">
          
          <section id="main">
  <article
  class="h-entry article"
  itemprop="blogPost"
  itemscope
  itemtype="https://schema.org/BlogPosting"
>
  <div
    class="article-inner"
    data-aos="fade-up"
  >
    <div class="article-meta">
      <div class="article-date">
  <a
    href="https://nothingtosay0031.github.io/post/gpudriven/"
    class="article-date-link"
    data-aos="zoom-in"
  >
    <time datetime="2024-12-25 18:11:48 &#43;0000 UTC" itemprop="datePublished"
      >2024-12-25</time
    >
    <time style="display: none;" id="post-update-time"
      >2024-12-25</time
    >
  </a>
</div>

      <div class="article-category">
  
</div>

    </div>
    <div class="hr-line"></div>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
      
        <h1 id="mesh-shadervulkan-中的下一代渲染管线">
<a class="header-anchor" href="#mesh-shadervulkan-%e4%b8%ad%e7%9a%84%e4%b8%8b%e4%b8%80%e4%bb%a3%e6%b8%b2%e6%9f%93%e7%ae%a1%e7%ba%bf"></a>
Mesh Shader：Vulkan 中的下一代渲染管线
</h1><h2 id="为什么选择-mesh-shader">
<a class="header-anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%80%89%e6%8b%a9-mesh-shader"></a>
为什么选择 Mesh Shader？
</h2><p>在深入代码之前，我们先来聊聊“为什么”。传统的顶点着色 (Vertex Shading) 管线虽然服务了我们很多年，但它存在一些固有的效率瓶颈。<a href="https://developer.nvidia.com/blog/introduction-turing-mesh-shaders/">Mesh Shader</a> 的出现正是为了解决这些痛点。</p>
<h3 id="传统管线的瓶颈">
<a class="header-anchor" href="#%e4%bc%a0%e7%bb%9f%e7%ae%a1%e7%ba%bf%e7%9a%84%e7%93%b6%e9%a2%88"></a>
传统管线的瓶颈
</h3><ol>
<li><strong>重复的顶点批处理</strong>：即使场景中模型的拓扑结构（顶点连接关系）固定不变，硬件的“图元分发器” (Primitive Distributor) 每次绘制时仍然需要扫描整个索引缓冲区来创建顶点批次。这是一种不必要的重复劳动。</li>
<li><strong>无效的数据拉取</strong>：传统管线会拉取并处理大量最终不可见的顶点数据。这些顶点可能因为背面剔除 (Back-face Culling)、视锥剔除 (Frustum Culling) 或被遮挡而被丢弃，但 GPU 带宽和计算资源已经被浪费了。</li>
</ol>
<h3 id="mesh-shader-的解决方案">
<a class="header-anchor" href="#mesh-shader-%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88"></a>
Mesh Shader 的解决方案
</h3><p>Mesh Shader 引入了两个新的可编程阶段：Task Shader 和 Mesh Shader，它们以工作组 (workgroup) 的形式运作，将更多的控制权交给了开发者。</p>
<ul>
<li><strong>Task Shader</strong> (可选): 任务着色器，负责剔除和分发工作。它可以看作是 Mesh Shader 工作组的“调度员”，能够高效地剔除掉整个物体或大块的网格，决定是否需要启动后续的 Mesh Shader。</li>
<li><strong>Mesh Shader</strong>: 网格着色器，负责生成图元。它取代了传统的顶点、几何和曲面细分着色器，直接在一个工作组内生成一小批顶点和图元。</li>
</ul>
<p>这种新模式带来了三大核心优势：</p>
<ul>
<li><strong>极致的性能与可扩展性</strong>：通过减少固定功能硬件的干预，渲染负载更多地转移到通用的着色器核心上。这意味着我们可以充分利用现代 GPU 强大的并行计算能力。</li>
<li><strong>显著的带宽节省</strong>：顶点重用 (vertex re-use) 可以在预处理阶段完成，并将结果（称为 <strong>Meshlet</strong>）缓存起来复用。Meshlet 是一种高度优化的微型网格，它包含一小撮唯一的顶点和引用这些顶点的图元。这意味着 GPU 不再需要每次都扫描庞大的主索引缓冲区。使用 Meshlet 后，索引数据的大小通常能减少到原来的 75% 左右。</li>
<li><strong>前所未有的灵活性</strong>：开发者可以自由定义网格拓扑，甚至在 GPU 上程序化地生成几何体，而无需受限于旧管线的固定模式。</li>
</ul>
<h2 id="构建-meshlet">
<a class="header-anchor" href="#%e6%9e%84%e5%bb%ba-meshlet"></a>
构建 Meshlet
</h2><p>让我们看看如何将传统的顶点/索引数据转换为 Meshlet。我们使用 <a href="https://github.com/zeux/meshoptimizer">meshoptimizer</a> 来简化这个过程。</p>
<p>整个流程可以分解为以下几个步骤：</p>
<h3 id="定义-meshlet-的大小并准备数据">
<a class="header-anchor" href="#%e5%ae%9a%e4%b9%89-meshlet-%e7%9a%84%e5%a4%a7%e5%b0%8f%e5%b9%b6%e5%87%86%e5%a4%87%e6%95%b0%e6%8d%ae"></a>
定义 Meshlet 的大小并准备数据
</h3><p>首先，我们需要为每个 Meshlet 定义顶点和图元的上限。这些值需要权衡，以适应硬件特性。<code>64</code> 个顶点和 <code>124</code> 个三角形是常见且高效的选择。</p>
<p>接着，我们遍历 glTF 场景中的每个图元 (primitive)，提取其顶点数据（位置、法线、UV 等）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 为每个 meshlet 定义顶点和图元的上限
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="n">sizet</span> <span class="n">max_vertices</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">sizet</span> <span class="n">max_triangles</span> <span class="o">=</span> <span class="mi">124</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 遍历 glTF 场景中的所有 mesh 和 primitive
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="n">u32</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">mesh</span><span class="p">.</span><span class="n">primitives_count</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">glTF</span><span class="o">::</span><span class="n">MeshPrimitive</span><span class="o">&amp;</span> <span class="n">mesh_primitive</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">primitives</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 省略了从 glTF 加载顶点、法线、UV 等属性数据的代码 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// f32* vertices = ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// u16* indices = ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// u32 index_count = ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// u32 vertex_count = ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="使用-meshoptimizer-构建-meshlet">
<a class="header-anchor" href="#%e4%bd%bf%e7%94%a8-meshoptimizer-%e6%9e%84%e5%bb%ba-meshlet"></a>
使用 <code>meshoptimizer</code> 构建 Meshlet
</h3><p>这是整个流程的魔法所在。我们调用 <code>meshopt_buildMeshlets</code> 函数，它会智能地将输入的网格分割成符合我们设定大小限制的、对 GPU 缓存友好的 Meshlet。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 计算构建 meshlet 所需的最大空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="n">sizet</span> <span class="n">max_meshlets</span> <span class="o">=</span> <span class="n">meshopt_buildMeshletsBound</span><span class="p">(</span><span class="n">index_count</span><span class="p">,</span> <span class="n">max_vertices</span><span class="p">,</span> <span class="n">max_triangles</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 分配临时内存来存储 meshoptimizer 的输出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Array</span><span class="o">&lt;</span><span class="n">meshopt_Meshlet</span><span class="o">&gt;</span> <span class="n">local_meshlets</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">local_meshlets</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">temp_allocator</span><span class="p">,</span> <span class="n">max_meshlets</span><span class="p">,</span> <span class="n">max_meshlets</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ... 为 meshlet_vertex_indices 和 meshlet_triangles 分配内存 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 核心调用：构建 Meshlet！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sizet</span> <span class="n">meshlet_count</span> <span class="o">=</span> <span class="n">meshopt_buildMeshlets</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">local_meshlets</span><span class="p">.</span><span class="n">data</span><span class="p">,</span>          <span class="c1">// 输出的 meshlet 数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">meshlet_vertex_indices</span><span class="p">.</span><span class="n">data</span><span class="p">,</span>  <span class="c1">// 输出的顶点索引数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">meshlet_triangles</span><span class="p">.</span><span class="n">data</span><span class="p">,</span>       <span class="c1">// 输出的图元索引数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">indices</span><span class="p">,</span>                      <span class="c1">// 输入的原始索引数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">index_count</span><span class="p">,</span>                  <span class="c1">// 输入的索引数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">(</span><span class="n">f32</span><span class="o">*</span><span class="p">)</span><span class="n">vertices</span><span class="p">,</span>               <span class="c1">// 输入的顶点位置数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vertex_count</span><span class="p">,</span>                 <span class="c1">// 输入的顶点数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">sizeof</span><span class="p">(</span><span class="n">vec3s</span><span class="p">),</span>                <span class="c1">// 每个顶点的大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">max_vertices</span><span class="p">,</span>                 <span class="c1">// 单个 meshlet 的最大顶点数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">max_triangles</span><span class="p">,</span>                <span class="c1">// 单个 meshlet 的最大图元数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cone_weight</span><span class="p">);</span>                 <span class="c1">// 用于锥形剔除优化的权重
</span></span></span></code></pre></div><p><code>meshoptimizer</code> 会为我们生成三个关键数组：</p>
<ol>
<li><code>local_meshlets</code>: 描述每个 Meshlet 的元数据（顶点/图元数量和偏移量）。</li>
<li><code>meshlet_vertex_indices</code>: 所有 Meshlet 使用的顶点索引的集合。</li>
<li><code>meshlet_triangles</code>: 所有 Meshlet 使用的图元索引的集合。</li>
</ol>
<h3 id="数据打包与优化">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e6%89%93%e5%8c%85%e4%b8%8e%e4%bc%98%e5%8c%96"></a>
数据打包与优化
</h3><p><code>meshoptimizer</code> 生成了原始数据，但我们还需要将其转换为 GPU 更喜欢的紧凑格式，以便在 Shader 中高效访问。</p>
<p>首先，我们处理顶点数据。为了节省带宽，我们会对法线和切线进行量化（例如，从 <code>float</code> 转换为 8 位整数），对 UV 坐标进行半精度浮点数（<code>half</code>）的量化。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 遍历所有顶点，转换并打包数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="n">u32</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">vertex_count</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">GpuMeshletVertexData</span> <span class="n">meshlet_vertex_data</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将法线从 [-1, 1] 范围的 float 压缩到 [0, 255] 范围的 u8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">normals</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">meshlet_vertex_data</span><span class="p">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">normals</span><span class="p">[</span><span class="n">v</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.0f</span><span class="p">)</span> <span class="o">*</span> <span class="mf">127.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ... y 和 z 分量 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将 UV 坐标转换为 16 位半精度浮点数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">meshlet_vertex_data</span><span class="p">.</span><span class="n">uv_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">meshopt_quantizeHalf</span><span class="p">(</span><span class="n">tex_coords</span><span class="p">[</span><span class="n">v</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="n">meshlet_vertex_data</span><span class="p">.</span><span class="n">uv_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">meshopt_quantizeHalf</span><span class="p">(</span><span class="n">tex_coords</span><span class="p">[</span><span class="n">v</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">meshlets_vertex_data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">meshlet_vertex_data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="生成最终的-gpu-meshlet-结构">
<a class="header-anchor" href="#%e7%94%9f%e6%88%90%e6%9c%80%e7%bb%88%e7%9a%84-gpu-meshlet-%e7%bb%93%e6%9e%84"></a>
生成最终的 GPU Meshlet 结构
</h3><p>现在，我们将 <code>meshoptimizer</code> 的输出和我们打包好的顶点数据组合成最终的 <code>GpuMeshlet</code> 结构体。这个结构体包含了在 GPU 上进行渲染和剔除所需的一切信息。</p>
<p>我们通过<code>reinterpret_cast</code>将<code>unsigned char*</code>指针强制转换为<code>unsigned int*</code>（<code>uint32_t*</code>）指针。这使我们能够将原始的索引流按4字节的块进行处理。一个<code>uint32_t</code>可以容纳四个8位的局部索引。在Mesh Shader内部，我们可以用一条指令加载一个<code>uint32_t</code>，然后通过廉价的位移（<code>&gt;&gt;</code>）和位掩码（<code>&amp; 0xFF</code>）操作来解包得到四个独立的索引。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 遍历 meshoptimizer 生成的每个 meshlet
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="n">u32</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">meshlet_count</span><span class="p">;</span> <span class="o">++</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">meshopt_Meshlet</span><span class="o">&amp;</span> <span class="n">local_meshlet</span> <span class="o">=</span> <span class="n">local_meshlets</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 计算用于剔除的边界球和锥体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">meshopt_Bounds</span> <span class="n">bounds</span> <span class="o">=</span> <span class="n">meshopt_computeMeshletBounds</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 填充我们自定义的 GpuMeshlet 结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">GpuMeshlet</span> <span class="n">meshlet</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">    <span class="n">meshlet</span><span class="p">.</span><span class="n">vertex_count</span>   <span class="o">=</span> <span class="n">local_meshlet</span><span class="p">.</span><span class="n">vertex_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">meshlet</span><span class="p">.</span><span class="n">triangle_count</span> <span class="o">=</span> <span class="n">local_meshlet</span><span class="p">.</span><span class="n">triangle_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 填充 center, radius, cone_axis, cone_cutoff 等剔除信息 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">meshlet</span><span class="p">.</span><span class="n">mesh_index</span>     <span class="o">=</span> <span class="p">...;</span> <span class="c1">// 记录它所属的原始网格索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 将该 meshlet 的顶点索引和图元索引打包到一个连续的缓冲中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 顶点索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">meshlet</span><span class="p">.</span><span class="n">vertex_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">meshlets_data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="cm">/* ... vertex index ... */</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4. 将图元索引打包到我们最终的GPU缓冲中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 将 u8 指针重新解释为 u32 指针，以便进行块读取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">index_groups</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint32_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">meshlet_triangles</span><span class="p">.</span><span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">local_meshlet</span><span class="p">.</span><span class="n">triangle_offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算需要多少个u32的块才能容纳所有三角形索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">index_group_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">local_meshlet</span><span class="p">.</span><span class="n">triangle_count</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将打包好的 u32 数据块追加到最终的缓冲中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index_group_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">meshlets_data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">index_groups</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">meshlets</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">meshlet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="two-pass-culling">
<a class="header-anchor" href="#two-pass-culling"></a>
Two-Pass Culling
</h1><p>我们已经介绍了如何使用 Mesh Shader 构建高效的 Meshlet。现在，我们将探讨如何在 Vulkan 中基于 <a href="https://advances.realtimerendering.com/s2015/aaltonenhaar_siggraph2015_combined_final_footer_220dpi.pdf">SIGGRAPH 2015 &ldquo;GPU-Driven Rendering Pipelines&rdquo;</a> 实现一个高效的基于 Meshlet 的双通道剔除管线。</p>
<h2 id="整体管线架构">
<a class="header-anchor" href="#%e6%95%b4%e4%bd%93%e7%ae%a1%e7%ba%bf%e6%9e%b6%e6%9e%84"></a>
整体管线架构
</h2><p>系统的核心思想是利用时域剔除 (temporal culling)，即借助前一帧的渲染结果来加速当前帧的剔除过程。具体来说，它主要复用前一帧的深度信息。这种方法虽然高效，但也可能引发一些问题，例如前一帧的遮挡物在当前帧移开时，会导致被遮挡的物体突然“闪现”(pop-in)。</p>
<p>为了在保证效率的同时规避这类瑕疵，管线设计了一个双通道架构来确保渲染的正确性。</p>
<p>整个渲染管线分为以下几个主要阶段：</p>
<ol>
<li>
<p>初步剔除与绘制列表生成</p>
<ul>
<li>输入: 场景中的所有物体列表，以及上一帧生成的深度金字塔 (Depth Pyramid)。</li>
<li>处理: 在一个 Compute Shader 中，对场景里的每个物体进行初步的视锥剔除 (Frustum Culling) 和基于上一帧深度的遮挡剔除 (Occlusion Culling)。</li>
<li>输出: 此阶段会生成两个列表：一个包含了“可能可见”物体的绘制指令 (DrawIndirect commands)，另一个是暂时被剔除的物体列表，留待后续检查。</li>
</ul>
</li>
<li>
<p>首次 Task/Mesh Shader 绘制</p>
<ul>
<li>处理: 使用第一阶段生成的“可能可见”物体绘制列表，执行 G-buffer 的主要绘制流程。在这一步的 Task Shader 中，还会对网格簇 (meshlet) 再次进行精细的视锥和遮挡剔除。</li>
<li>输出: 生成当前帧的深度缓冲 (Depth Buffer)。</li>
</ul>
</li>
<li>
<p>生成当前帧的深度金字塔</p>
<ul>
<li>输入: 当前帧的深度缓冲。</li>
<li>处理: 构建一个新的深度金字塔。</li>
<li>输出: 一个可用于后续遮挡测试的深度金字塔纹理。</li>
</ul>
</li>
<li>
<p>二次剔除与修正绘制</p>
<ul>
<li>输入: 在第一阶段被剔除的物体列表，以及当前帧的深度金字塔。</li>
<li>处理: 再次启动 Compute Shader，处理那些在第一阶段可能被错误剔除的物体（即“假阴性”或 False-Negatives）。这些物体由于使用的是过时的深度信息而被剔除，现在将使用当前帧精确的深度数据进行重新测试。</li>
<li>输出: 一个需要补充绘制的物体指令列表。</li>
</ul>
</li>
<li>
<p>最终 Task/Mesh Shader 绘制</p>
<ul>
<li>处理: 执行上一阶段生成的补充绘制列表。</li>
<li>输出: 经过修正和完善的最终 G-buffer。</li>
</ul>
</li>
</ol>
<p>该设计的巧妙之处在于，它将绝大部分（通常超过95%）的剔除工作交给了高效但允许少量错误的阶段一。然后，它通过阶段四和阶段五，仅针对那一小部分可能出错的物体进行精确的修正渲染。这种策略在性能和渲染质量之间取得了出色的平衡。</p>
<h2 id="剔除并生成draw指令">
<a class="header-anchor" href="#%e5%89%94%e9%99%a4%e5%b9%b6%e7%94%9f%e6%88%90draw%e6%8c%87%e4%bb%a4"></a>
剔除并生成Draw指令
</h2><p>这是整个系统的核心，其目标是尽可能早、尽可能快地剔除掉大量不可见的物体。这个过程放在了一个Compute Shader中，每个着色器调用（Invocation）负责处理一个独立的物体实例。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// COMPUTE_GPU_MESH_CULLING</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 每个工作组派发64个线程，每个线程处理一个物体实例</span>
</span></span><span class="line"><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">mesh_instance_index</span> <span class="o">=</span> <span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 边界检查 ...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取物体实例数据和包围球信息</span>
</span></span><span class="line"><span class="cl">    <span class="n">MeshDraw</span> <span class="n">mesh_draw</span> <span class="o">=</span> <span class="n">mesh_draws</span><span class="p">[</span><span class="n">mesh_draw_index</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">bounding_sphere</span> <span class="o">=</span> <span class="n">mesh_bounds</span><span class="p">[</span><span class="n">mesh_draw_index</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">mat4</span> <span class="n">model</span> <span class="o">=</span> <span class="n">mesh_instance_draws</span><span class="p">[</span><span class="n">mesh_instance_index</span><span class="p">].</span><span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将包围球从模型空间转换到世界空间和观察空间</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">world_bounding_center</span> <span class="o">=</span> <span class="n">model</span> <span class="o">*</span> <span class="k">vec4</span><span class="p">(</span><span class="n">bounding_sphere</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">view_bounding_center</span> <span class="o">=</span> <span class="n">world_to_camera</span> <span class="o">*</span> <span class="n">world_bounding_center</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算世界空间下的包围球半径</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">model</span><span class="p">[</span><span class="mo">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">bounding_sphere</span><span class="p">.</span><span class="n">w</span> <span class="o">*</span> <span class="n">scale</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 视锥剔除</span>
</span></span><span class="line"><span class="cl">    <span class="k">bool</span> <span class="n">frustum_visible</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 平面方程: dot(N, P) + D = 0。我们预先计算好平面法线指向视锥内部</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// dot(plane, point) &gt; -radius 表示球体在平面的内侧或与平面相交</span>
</span></span><span class="line"><span class="cl">        <span class="n">frustum_visible</span> <span class="o">=</span> <span class="n">frustum_visible</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">frustum_planes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">view_bounding_center</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">radius</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 遮挡剔除</span>
</span></span><span class="line"><span class="cl">    <span class="k">bool</span> <span class="n">occlusion_visible</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">frustum_visible</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">occlusion_visible</span> <span class="o">=</span> <span class="n">occlusion_cull</span><span class="p">(...);</span> <span class="c1">// 详细实现在下文</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 生成绘制指令</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">frustum_visible</span> <span class="o">&amp;&amp;</span> <span class="n">occlusion_visible</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ... 使用 atomicAdd 将该物体的绘制指令写入可见列表 ...</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ... 使用 atomicAdd 将该物体的ID写入被剔除列表，用于Pass 3重检 ...</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="视锥剔除-frustum-culling">
<a class="header-anchor" href="#%e8%a7%86%e9%94%a5%e5%89%94%e9%99%a4-frustum-culling"></a>
视锥剔除 (Frustum Culling)
</h3><p>视锥剔除是相对直接的步骤。我预先在CPU端计算好当前摄像机视锥的六个平面方程，并将其作为Uniform数据传入Shader。平面方程的形式为 $Ax + By + Cz + D = 0$，其中法线 $(A, B, C)$ 指向视锥内部。</p>
<p>剔除测试基于球体-平面相交检测。对于一个中心在 $C_{view}$、半径为 $r$ 的包围球（在观察空间下），它与一个平面 $P$ 的带符号距离为 $d = \vec{N} \cdot C_{view} + D$。</p>
<ul>
<li>如果 $d > r$，球体完全在平面内侧。</li>
<li>如果 $d < -r$，球体完全在平面外侧（被剔除）。</li>
<li>如果 $-r \le d \le r$，球体与平面相交。</li>
</ul>
<p>为了保守起见，我们只剔除完全在视锥外的物体。因此，只要球体与所有六个平面都满足 $d > -r$ 的条件，它就被认为是视锥内可见的。</p>
<h3 id="遮挡剔除-occlusion-culling">
<a class="header-anchor" href="#%e9%81%ae%e6%8c%a1%e5%89%94%e9%99%a4-occlusion-culling"></a>
遮挡剔除 (Occlusion Culling)
</h3><p>遮挡剔除利用了上一帧的深度信息构建的层级Z缓冲（Hierarchical-Z Buffer），也即深度金字塔（Depth Pyramid）。</p>
<p>深度金字塔是一个Mipmap链，但它的每个层级存储的不是平均颜色，而是其覆盖的4个子像素（或上一层级纹素）中的最大深度值（最远深度）。这使得我们可以快速查询屏幕上一个区域内的“最远”遮挡物深度。</p>
<p>遮挡测试的逻辑如下：</p>
<ol>
<li>将物体的3D包围球投影到2D屏幕空间，得到一个2D包围盒（AABB）。</li>
<li>根据该2D包围盒的大小，选择深度金字塔中合适的Mipmap层级进行采样。</li>
<li>获取采样区域内的<strong>最远遮挡物深度</strong> $Z_{occluder}$。</li>
<li>计算物体本身投影到屏幕后的<strong>最近深度</strong> $Z_{object}$。</li>
<li>如果 $Z_{object} > Z_{occluder}$，意味着物体完全在已知遮挡物的后面，可以安全剔除。</li>
</ol>
<h4 id="包围球投影与mip层级选择">
<a class="header-anchor" href="#%e5%8c%85%e5%9b%b4%e7%90%83%e6%8a%95%e5%bd%b1%e4%b8%8emip%e5%b1%82%e7%ba%a7%e9%80%89%e6%8b%a9"></a>
包围球投影与Mip层级选择
</h4><p>将3D球体精确投影为2D屏幕范围并非易事。我参照了 Michael Mara 和 Morgan McGuire 在2013年提出的方法，它能为透视投影下的球体计算出紧密的2D多边形边界，我们这里简化为AABB。</p>
<p><code>project_sphere()</code> 函数实现了这个逻辑，它将观察空间下的球心 <code>C</code> 和半径 <code>r</code>，转换为屏幕UV空间的AABB <code>aabb</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// 2D Polyhedral Bounds of a Clipped, Perspective-Projected 3D Sphere. Michael Mara, Morgan McGuire. 2013</span>
</span></span><span class="line"><span class="cl"><span class="k">bool</span> <span class="n">project_sphere</span><span class="p">(</span><span class="k">vec3</span> <span class="n">C</span><span class="p">,</span> <span class="k">float</span> <span class="n">r</span><span class="p">,</span> <span class="k">float</span> <span class="n">znear</span><span class="p">,</span> <span class="k">float</span> <span class="n">P00</span><span class="p">,</span> <span class="k">float</span> <span class="n">P11</span><span class="p">,</span> <span class="k">out</span> <span class="k">vec4</span> <span class="n">aabb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// C.z 是观察空间深度，必须在近平面外</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">C</span><span class="p">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">znear</span><span class="p">)</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ... 复杂的数学变换，计算球体轮廓线投影后的边界 ...</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// P00 和 P11 是投影矩阵的 [0][0] 和 [1][1] 项</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">aabb</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">minx</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">minx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">P00</span><span class="p">,</span> <span class="n">miny</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">miny</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">P11</span><span class="p">,</span> <span class="n">maxx</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">maxx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">P00</span><span class="p">,</span> <span class="n">maxy</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">maxy</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">P11</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 将裁剪空间坐标 [-1, 1] 转换为 UV 空间 [0, 1]</span>
</span></span><span class="line"><span class="cl">  <span class="n">aabb</span> <span class="o">=</span> <span class="n">aabb</span><span class="p">.</span><span class="n">xwzy</span> <span class="o">*</span> <span class="k">vec4</span><span class="p">(</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="k">vec4</span><span class="p">(</span><span class="mf">0.5</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>得到屏幕空间的 <code>aabb</code> 后，我们可以计算其宽高，并使用 <code>log2</code> 来选择一个能大致覆盖此区域的Mipmap层级。这避免了在高分辨率深度图上进行大量采样的开销。</p>
<p><code>occlusion_cull()</code> 中的Mip层级选择：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// ... in occlusion_cull()</span>
</span></span><span class="line"><span class="cl"><span class="k">ivec2</span> <span class="n">depth_pyramid_size</span> <span class="o">=</span> <span class="n">textureSize</span><span class="p">(</span><span class="n">depth_pyramid_texture</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">float</span> <span class="n">width</span> <span class="o">=</span> <span class="p">(</span><span class="n">aabb</span><span class="p">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">aabb</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">depth_pyramid_size</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">float</span> <span class="n">height</span> <span class="o">=</span> <span class="p">(</span><span class="n">aabb</span><span class="p">.</span><span class="n">w</span> <span class="o">-</span> <span class="n">aabb</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">depth_pyramid_size</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 选择能覆盖AABB的最粗糙（但足够精细）的Mip层级</span>
</span></span><span class="line"><span class="cl"><span class="k">float</span> <span class="n">level</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">log2</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)));</span>
</span></span></code></pre></div><h4 id="深度比较">
<a class="header-anchor" href="#%e6%b7%b1%e5%ba%a6%e6%af%94%e8%be%83"></a>
深度比较
</h4><p>选定Mip层级后，我们在该层级上进行采样。为了提高准确性，我不仅采样了AABB的中心点，还采样了四个角点，并取其中的最大值作为最可靠的遮挡深度 $Z_{occluder}$。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// ... in occlusion_cull()</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 采样器设置为 MAX reduction，所以一次采样即可得到区域最大深度</span>
</span></span><span class="line"><span class="cl"><span class="k">vec2</span> <span class="n">uv</span> <span class="o">=</span> <span class="p">(</span><span class="n">aabb</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">aabb</span><span class="p">.</span><span class="n">zw</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">float</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">textureLod</span><span class="p">(</span><span class="n">depth_pyramid_texture</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">level</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ... (采样角点并取最大值)</span>
</span></span></code></pre></div><p>接下来，计算物体自身的最近深度。这个深度点是包围球表面上离摄像机最近的点。该点可以通过从球心沿“球心到摄像机”方向的反方向移动一个半径的距离得到。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// ... in occlusion_cull()</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 计算球体表面最靠近相机的点的深度</span>
</span></span><span class="line"><span class="cl"><span class="k">vec3</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">camera_world_position</span> <span class="o">-</span> <span class="n">world_bounding_center</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">vec4</span> <span class="n">sceen_space_center_last</span> <span class="o">=</span> <span class="n">culling_view_projection</span> <span class="o">*</span> <span class="k">vec4</span><span class="p">(</span><span class="n">world_bounding_center</span> <span class="o">+</span> <span class="n">dir</span> <span class="o">*</span> <span class="n">radius</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">float</span> <span class="n">depth_sphere</span> <span class="o">=</span> <span class="n">sceen_space_center_last</span><span class="p">.</span><span class="n">z</span> <span class="o">/</span> <span class="n">sceen_space_center_last</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
</span></span></code></pre></div><p>最后进行关键的比较：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// ... in occlusion_cull()</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 如果物体最近点的深度大于（远于）采样区域的最远遮挡物深度，则被遮挡</span>
</span></span><span class="line"><span class="cl"><span class="n">occlusion_visible</span> <span class="o">=</span> <span class="p">(</span><span class="n">depth_sphere</span> <span class="o">&lt;=</span> <span class="n">depth</span><span class="p">);</span>
</span></span></code></pre></div><p>这里的 <code>depth</code> 是上一帧的 $Z_{occluder}$，<code>depth_sphere</code> 是当前帧的 $Z_{object}$。如果 $Z_{object} \le Z_{occluder}$，则物体不被上一帧的深度所遮挡，判定为可见。</p>
<h3 id="原子操作生成绘制列表">
<a class="header-anchor" href="#%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c%e7%94%9f%e6%88%90%e7%bb%98%e5%88%b6%e5%88%97%e8%a1%a8"></a>
原子操作生成绘制列表
</h3><p>当一个物体通过了所有剔除测试后，我们需要将其加入到本帧的绘制列表中。在GPU上并行执行此操作，必须使用原子操作 (Atomic Operations) 来避免竞争条件。</p>
<p>我使用一个 <code>atomicAdd</code> 指令来安全地递增一个计数器，该计数器作为索引，将当前可见物体的绘制参数写入到一个SSBO（Shader Storage Buffer Object）中。这个SSBO的结构与Vulkan的 <code>VkDrawMeshTasksIndirectCommandNV</code> 完全匹配，可以直接用于后续的 <code>vkCmdDrawMeshTasksIndirectNV</code> 调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">// ... in main()</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">frustum_visible</span> <span class="o">&amp;&amp;</span> <span class="n">occlusion_visible</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 为不透明物体列表申请一个索引</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">draw_index</span> <span class="o">=</span> <span class="n">atomicAdd</span><span class="p">(</span><span class="n">opaque_mesh_visible_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 填充间接绘制指令</span>
</span></span><span class="line"><span class="cl">    <span class="n">draw_commands</span><span class="p">[</span><span class="n">draw_index</span><span class="p">].</span><span class="n">drawId</span> <span class="o">=</span> <span class="n">mesh_instance_index</span><span class="p">;</span> <span class="c1">// 传递实例ID</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... (填充 taskCount, firstTask 等)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">late_flag</span> <span class="o">==</span> <span class="mo">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// late_flag=0表示这是第一次剔除</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将被剔除的物体加入到“待重检”列表</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">draw_index</span> <span class="o">=</span> <span class="n">atomicAdd</span><span class="p">(</span><span class="n">opaque_mesh_culled_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">draw_late_commands</span><span class="p">[</span><span class="n">draw_index</span><span class="p">].</span><span class="n">drawId</span> <span class="o">=</span> <span class="n">mesh_instance_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>通过这种方式，整个剔除和绘制指令生成过程无需任何CPU干预，也无需GPU到CPU的数据回读，实现了真正高效的GPU驱动管线。</p>
<h2 id="task-shader-and-mesh-shader">
<a class="header-anchor" href="#task-shader-and-mesh-shader"></a>
Task Shader and Mesh Shader
</h2><ul>
<li><strong>输入</strong>：由第一阶段 Compute Shader 生成的、包含“可能可见”物体的间接绘制指令列表 (<code>DrawIndirect commands</code>)。同时，也接收上一帧生成的深度金字塔（Depth Pyramid）用于遮挡测试。</li>
<li><strong>处理</strong>：
<ul>
<li><strong>Task Shader</strong>：每个 Task Shader 工作组 (Workgroup) 负责处理一个或多个 Meshlet。它首先对每个 Meshlet 的包围体（通常是包围球）进行视锥剔除和遮挡剔除。然后，它会动态计算出有多少 Meshlet 通过了测试，并将这些可见的 Meshlet 索引传递给其对应的 Mesh Shader 工作组。</li>
<li><strong>Mesh Shader</strong>：Mesh Shader 只为那些由 Task Shader 确认可见的 Meshlet 生成顶点和图元。它从 Buffer 中读取顶点数据，进行模型-视图-投影变换，并输出最终的三角形图元给光栅化器。</li>
</ul>
</li>
<li><strong>输出</strong>：当前帧的 G-buffer（包含深度、法线、颜色等信息）。其中，深度缓冲将被用于构建当前帧的深度金字塔，为第四阶段的二次剔除做准备。</li>
</ul>
<h3 id="task-shader">
<a class="header-anchor" href="#task-shader"></a>
Task Shader
</h3><p>Task Shader 是剔除逻辑的核心。它像一个调度员，决定了哪些 Meshlet 值得后续的 Mesh Shader 去处理。让我们逐段分析代码。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ... Buffer Definitions ...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">out</span> <span class="n">taskNV</span> <span class="n">block</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">meshlet_indices</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span> <span class="c1">// 输出给 Mesh Shader 的共享数据</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 索引计算</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">task_index</span> <span class="o">=</span> <span class="n">gl_LocalInvocationID</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">meshlet_group_index</span> <span class="o">=</span> <span class="n">gl_WorkGroupID</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">global_meshlet_index</span> <span class="o">=</span> <span class="n">meshlet_group_index</span> <span class="o">*</span> <span class="mi">32</span> <span class="o">+</span> <span class="n">task_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 获取模型矩阵等实例数据 ...</span>
</span></span><span class="line"><span class="cl">    <span class="n">mat4</span> <span class="n">model</span> <span class="o">=</span> <span class="n">mesh_instance_draws</span><span class="p">[</span><span class="n">mesh_instance_index</span><span class="p">].</span><span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Meshlet 包围体变换</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">world_center</span> <span class="o">=</span> <span class="n">model</span> <span class="o">*</span> <span class="k">vec4</span><span class="p">(</span><span class="n">meshlets</span><span class="p">[</span><span class="n">global_meshlet_index</span><span class="p">].</span><span class="n">center</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">model</span><span class="p">[</span><span class="mo">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">meshlets</span><span class="p">[</span><span class="n">global_meshlet_index</span><span class="p">].</span><span class="n">radius</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">*</span> <span class="mf">1.1</span><span class="p">;</span> <span class="c1">// 稍微放大包围球，避免精度问题</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 背面剔除 (Cone Culling) ...</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">bool</span> <span class="n">accept</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">view_center</span> <span class="o">=</span> <span class="n">world_to_camera_debug</span> <span class="o">*</span> <span class="n">world_center</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 视锥剔除</span>
</span></span><span class="line"><span class="cl">    <span class="k">bool</span> <span class="n">frustum_visible</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">frustum_visible</span> <span class="o">=</span> <span class="n">frustum_visible</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">frustum_planes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">view_center</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">radius</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 遮挡剔除... </span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">uvec4</span> <span class="n">ballot</span> <span class="o">=</span> <span class="n">subgroupBallot</span><span class="p">(</span><span class="n">accept</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">index</span> <span class="o">=</span> <span class="n">subgroupBallotExclusiveBitCount</span><span class="p">(</span><span class="n">ballot</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">accept</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">meshlet_indices</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">global_meshlet_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">count</span> <span class="o">=</span> <span class="n">subgroupBallotBitCount</span><span class="p">(</span><span class="n">ballot</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">task_index</span> <span class="o">==</span> <span class="mo">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">gl_TaskCountNV</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
</span></span></code></pre></div><h4 id="cone-culling">
<a class="header-anchor" href="#cone-culling"></a>
Cone Culling
</h4><p>在传统的渲染管线中，背面剔除（Backface Culling）通常发生在光栅化阶段，由硬件对逐个三角形进行。然而，在以 Meshlet 为单位的渲染管线中，我们有机会在更早的 Task Shader 阶段，对一整个网格簇（Meshlet）进行剔除。</p>
<p><strong>核心思想</strong>：一个 Meshlet 是由一组朝向大致相同的三角形构成的。我们可以计算出这些三角形法线的平均方向，并构建一个能够包裹所有法线的“锥体”（Cone）。如果摄像机位于这个锥体的“背面”，那么这个 Meshlet 内的所有三角形都将是不可见的，可以被安全地剔除。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// As described in meshoptimizer.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="nf">coneCull</span><span class="p">(</span><span class="n">vec3</span> <span class="n">center</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">cone_axis</span><span class="p">,</span> <span class="kt">float</span> <span class="n">cone_cutoff</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">camera_position</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">camera_position</span><span class="p">,</span> <span class="n">cone_axis</span><span class="p">)</span> <span class="o">&gt;=</span>
</span></span><span class="line"><span class="cl">         <span class="n">cone_cutoff</span> <span class="o">*</span> <span class="n">length</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">camera_position</span><span class="p">)</span> <span class="o">+</span> <span class="n">radius</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这个函数返回 <code>true</code> 代表“应该被剔除”，<code>false</code> 代表“可能可见”。</p>
<ul>
<li><code>vec3 center</code>: Meshlet 的包围球中心点（世界空间）。</li>
<li><code>float radius</code>: Meshlet 的包围球半径。</li>
<li><code>vec3 cone_axis</code>: 锥体的中心轴，通常是 Meshlet 内所有三角形法线的平均值，并且是单位向量。它代表了整个 Meshlet 的“平均朝向”。</li>
<li><code>float cone_cutoff</code>: 锥体张角的余弦值。它定义了锥体的“胖瘦”。<code>cone_cutoff = cos(α)</code>，其中 <code>α</code> 是锥体轴与锥体表面之间的夹角（锥体的半角）。该值在预处理阶段生成，与 <code>cone_axis</code> 一同存储。</li>
<li><code>vec3 camera_position</code>: 摄像机的位置（世界空间）。</li>
</ul>
<p>让我们来拆解这个不等式，理解其几何意义。</p>
<p><code>dot(center - camera_position, cone_axis) &gt;= cone_cutoff * length(center - camera_position) + radius;</code></p>
<p>为方便理解，我们定义几个向量和变量：</p>
<ul>
<li>视角向量 $\vec{V} = \text{center} - \text{camera\_position}$，即从摄像机指向 Meshlet 中心的向量。</li>
<li>锥体轴向量 $\vec{A} = \text{cone\_axis}$ (单位向量)。</li>
<li>锥体张角余弦值 $k = \text{cone\_cutoff}$。</li>
<li>包围球半径 $r = \text{radius}$。</li>
</ul>
$$\vec{V} \cdot \vec{A} \ge k \cdot ||\vec{V}|| + r$$<p>我们可以分两步来理解它：</p>
<p><strong>第一步：基础点对象的锥体测试</strong></p>
<p>首先忽略半径 <code>r</code>，我们来看 <code>dot(V, A) &gt;= k * ||V||</code>。
根据点积的定义，我们知道 $\vec{V} \cdot \vec{A} = ||\vec{V}|| \cdot ||\vec{A}|| \cdot \cos(\theta)$，其中 $\theta$ 是视角向量 $\vec{V}$ 和锥体轴 $\vec{A}$ 之间的夹角。</p>
$$||\vec{V}|| \cdot \cos(\theta) \ge k \cdot ||\vec{V}||$$$$\cos(\theta) \ge k$$$$\cos(\theta) \ge \cos(\alpha)$$$$\theta \le \alpha$$<p><strong>几何意义</strong>：这个不等式判断了视角向量 $\vec{V}$ 是否在锥体内部。如果夹角 $\theta$ 小于或等于锥体的半角 $\alpha$，意味着摄像机正对着锥体的“正面”，Meshlet 可能是可见的。反之，如果 $\theta > \alpha$ (即 $\cos(\theta) < k$)，则意味着摄像机在锥体的“背面”，Meshlet 是不可见的。</p>
<p>因此，<code>dot(V, A) &lt; k * ||V||</code> 是剔除条件。我们的代码使用了 <code>&gt;=</code>，这意味着它判断的是“<strong>不剔除</strong>”的对立面，也就是“<strong>剔除</strong>”。</p>
<p><strong>第二步：考虑包围球的保守测试</strong></p>
$$ \vec{V} \cdot \vec{A} \ge k \cdot ||\vec{V}|| + r $$<p>为什么要加上这个 <code>r</code>？</p>
<p>因为基础的锥体测试是针对一个<strong>点</strong>（Meshlet 的中心 <code>center</code>）进行的。但 Meshlet 是一个有体积的物体，由一个半径为 <code>r</code> 的包围球所包裹。</p>
<p>如上图所示，即使 Meshlet 的中心点 <code>C</code> 根据基础锥体测试判断应该被剔除（即摄像机 <code>P</code> 在剔除区域），但由于 Meshlet 自身有半径，它的边缘（点 <code>E</code>）仍然可能延伸到可见区域内。直接剔除会导致视觉错误。</p>
<p><code>+ r</code> 这一项就是为了解决这个问题。它是一个<strong>保守的补偿项</strong>。它通过在不等式的右侧增加一个正值，使得不等式更难成立。换句话说，它<strong>收缩了剔除区域</strong>，扩大了“安全区域”（不被剔除的区域），确保只有当整个包围球都完全处于锥体背面时，剔除才会发生。这是一种用略微降低剔除率来换取绝对渲染正确性的经典策略。</p>
<h4 id="subgroup-操作与动态任务分发">
<a class="header-anchor" href="#subgroup-%e6%93%8d%e4%bd%9c%e4%b8%8e%e5%8a%a8%e6%80%81%e4%bb%bb%e5%8a%a1%e5%88%86%e5%8f%91"></a>
Subgroup 操作与动态任务分发
</h4><ul>
<li><strong>原理</strong>：Task Shader 以工作组（Workgroup）为单位执行，一个工作组通常包含多个线程（例如这里的32个）。我们需要一种高效的方式来汇总组内所有线程的剔除结果。Vulkan 中的 Subgroup (在 CUDA 中称为 Warp) 操作提供了硬件级别的支持。</li>
<li><strong>代码实现</strong>：
<ul>
<li><code>subgroupBallot(accept)</code>: 这是核心。它会收集当前 Subgroup 中所有线程的 <code>accept</code> 布尔值，并生成一个位掩码（<code>uvec4 ballot</code>）。如果第 N 个线程的 <code>accept</code> 为 <code>true</code>，那么结果位掩码的第 N 位就为 1。</li>
<li><code>subgroupBallotBitCount(ballot)</code>: 计算位掩码中为 1 的位的数量，即通过剔除测试的 Meshlet 数量。</li>
<li><code>subgroupBallotExclusiveBitCount(ballot)</code>: 计算在当前线程之前，有多少个线程的 <code>accept</code> 为 <code>true</code>。这个结果可以完美地用作写入共享数组 <code>meshlet_indices</code> 的本地索引，实现了一个无冲突的并行数据压缩。</li>
<li><code>gl_TaskCountNV = count</code>: 最后，工作组的第一个线程 (lane 0) 将可见的 Meshlet 总数写入 <code>gl_TaskCountNV</code>。GPU 会根据这个值，启动相应数量的 Mesh Shader 工作组。如果 <code>count</code> 为 0，则不会启动任何 Mesh Shader。</li>
</ul>
</li>
</ul>
<h3 id="mesh-shader">
<a class="header-anchor" href="#mesh-shader"></a>
Mesh Shader
</h3><p>只有在 Task Shader 判定有可见的 Meshlet 时，Mesh Shader 才会被启动。它的任务很简单：根据传入的 Meshlet 索引，生成最终的顶点和图元。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">max_vertices</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span> <span class="n">max_primitives</span> <span class="o">=</span> <span class="mi">124</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ... Buffer Definitions ...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">in</span> <span class="n">taskNV</span> <span class="n">block</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">meshlet_indices</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span> <span class="c1">// 从 Task Shader 接收的共享数据</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ... Output Vertex Attributes ...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 获取 Meshlet 索引</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">task_index</span> <span class="o">=</span> <span class="n">gl_LocalInvocationID</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 注意：这里 gl_WorkGroupID.x 不再是 Meshlet 组索引，而是可见 Meshlet 的索引</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">global_meshlet_index</span> <span class="o">=</span> <span class="n">meshlet_indices</span><span class="p">[</span><span class="n">gl_WorkGroupID</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 解压 Meshlet 数据</span>
</span></span><span class="line"><span class="cl">    <span class="n">Meshlet</span> <span class="n">meshlet</span> <span class="o">=</span> <span class="n">meshlets</span><span class="p">[</span><span class="n">global_meshlet_index</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">vertex_count</span> <span class="o">=</span> <span class="n">uint</span><span class="p">(</span><span class="n">meshlet</span><span class="p">.</span><span class="n">vertex_count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">triangle_count</span> <span class="o">=</span> <span class="n">uint</span><span class="p">(</span><span class="n">meshlet</span><span class="p">.</span><span class="n">triangle_count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">data_offset</span> <span class="o">=</span> <span class="n">meshlet</span><span class="p">.</span><span class="n">data_offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">vertexOffset</span> <span class="o">=</span> <span class="n">data_offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">indexOffset</span> <span class="o">=</span> <span class="n">data_offset</span> <span class="o">+</span> <span class="n">vertex_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 获取模型矩阵 ...</span>
</span></span><span class="line"><span class="cl">    <span class="n">mat4</span> <span class="n">model</span> <span class="o">=</span> <span class="n">mesh_instance_draws</span><span class="p">[</span><span class="n">mesh_instance_index</span><span class="p">].</span><span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 顶点处理 (并行)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 每个线程处理一部分顶点</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="n">task_index</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vertex_count</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">32</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">uint</span> <span class="n">vi</span> <span class="o">=</span> <span class="n">meshletData</span><span class="p">[</span><span class="n">vertexOffset</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span> <span class="c1">// 获取局部顶点索引</span>
</span></span><span class="line"><span class="cl">        <span class="k">vec3</span> <span class="n">position</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// 从 Buffer 中读取顶点位置</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// ... 法线、切线等属性的解压和变换 ...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 核心：顶点变换</span>
</span></span><span class="line"><span class="cl">        <span class="n">gl_MeshVerticesNV</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">gl_Position</span> <span class="o">=</span> <span class="n">view_projection</span> <span class="o">*</span> <span class="p">(</span><span class="n">model</span> <span class="o">*</span> <span class="k">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// ... 设置其他输出给片元着色器的 varying 变量 ...</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4. 索引处理 (并行)</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">indexGroupCount</span> <span class="o">=</span> <span class="p">(</span><span class="n">indexCount</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// 索引被打包存储</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="n">task_index</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">indexGroupCount</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">32</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 高效的索引解包函数</span>
</span></span><span class="line"><span class="cl">        <span class="n">writePackedPrimitiveIndices4x8NV</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">meshletData</span><span class="p">[</span><span class="n">indexOffset</span> <span class="o">+</span> <span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 5. 设置图元数量</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">task_index</span> <span class="o">==</span> <span class="mo">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">gl_PrimitiveCountNV</span> <span class="o">=</span> <span class="n">triangle_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="并行顶点生成与图元装配">
<a class="header-anchor" href="#%e5%b9%b6%e8%a1%8c%e9%a1%b6%e7%82%b9%e7%94%9f%e6%88%90%e4%b8%8e%e5%9b%be%e5%85%83%e8%a3%85%e9%85%8d"></a>
并行顶点生成与图元装配
</h4><ul>
<li><strong>并行处理</strong>：Mesh Shader 的一个工作组（<code>local_size_x = 32</code>）共同负责一个 Meshlet 的绘制。工作组内的线程并行处理顶点和索引。代码中的 <code>for (uint i = task_index; i &lt; vertex_count; i += 32)</code> 循环就是一个典型的并行处理模式，每个线程以 32 为步长处理顶点数组中的一部分数据。</li>
<li><strong>数据解压</strong>：顶点属性（法线、切线）和索引通常会经过压缩存储（例如，法线用8位整数表示，索引打包到一个 <code>uint</code> 中）以减少显存占用和带宽。在 Mesh Shader 中，这些数据被实时解压。<code>i8_inverse = 1.0 / 127.0</code> 就是用于将 8 位有符号整数还原为 <code>[-1, 1]</code> 范围的浮点数。</li>
<li><strong>图元输出</strong>：
<ul>
<li><code>gl_MeshVerticesNV</code>：这是一个内置的输出数组，用于存放变换后的顶点数据。</li>
<li><code>gl_PrimitiveCountNV</code>：设置当前 Meshlet 包含的图元（三角形）数量。</li>
<li><code>writePackedPrimitiveIndices4x8NV()</code>：这是一个 NVidia 扩展提供的函数，用于高效地从一个 32 位整数中解压出四个 8 位的局部顶点索引。</li>
</ul>
</li>
</ul>
<h4 id="primitiveindices">
<a class="header-anchor" href="#primitiveindices"></a>
PrimitiveIndices
</h4><p>简单来说，<code>PrimitiveIndices</code> 指的是<strong>定义图元（在这里是三角形）的局部顶点索引 (Local Vertex Indices)</strong>。</p>
<p>在传统的渲染管线（Vertex Shader）中，我们有一个全局的顶点缓冲区（Vertex Buffer）和一个全局的索引缓冲区（Index Buffer）。索引缓冲区中的每个数字都是一个<strong>全局顶点索引</strong>，它直接指向全局顶点缓冲区中的一个顶点。</p>
<p>然而，在 Mesh Shader 的世界里，数据被组织成了更小的块，也就是 <strong>网格簇（Meshlet）</strong>。每个 Meshlet 包含：</p>
<ol>
<li><strong>一小部分顶点</strong> (例如，最多64个顶点)。</li>
<li><strong>一小部分图元</strong> (例如，最多124个三角形)，这些图元完全由上述的这些顶点构成。</li>
</ol>
<p>这里的 <code>PrimitiveIndices</code> 就是用来定义这些图元的索引列表。它的关键特性是：</p>
<ul>
<li><strong>它是局部的 (Local)</strong>：这些索引指向的是<strong>当前 Meshlet 自带的顶点列表</strong>，而不是整个模型的全局顶点列表。如果一个 Meshlet 有64个顶点，那么它的 <code>PrimitiveIndices</code> 的值范围就在 <code>[0, 63]</code> 之间。</li>
<li><strong>它定义了连接关系</strong>：和传统的索引一样，它的作用是告诉 GPU 如何将顶点连接起来形成三角形。一个三角形由三个索引构成。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="n">writePackedPrimitiveIndices4x8NV</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">meshletData</span><span class="p">[</span><span class="n">indexOffset</span> <span class="o">+</span> <span class="n">i</span><span class="p">]);</span>
</span></span></code></pre></div><ol>
<li>
<p><strong><code>meshletData[indexOffset + i]</code></strong>: 这是一个 <code>uint</code> 类型的值（32位）。它从一个名为 <code>MeshletData</code> 的大缓冲区中被读取。这个 <code>uint</code> 并不是一个索引，而是<strong>包含了多个索引的压缩包</strong>。</p>
</li>
<li>
<p><strong>Packed (压缩)</strong>: 因为每个局部顶点索引通常很小（例如，一个 Meshlet 最多64或128个顶点，用一个8位的 <code>uchar</code> 就足够表示了），为了节省显存和带宽，我们会把多个局部索引“塞进”一个更大的数据类型里。在这里，一个32位的 <code>uint</code> 被用来存储 <strong>4个</strong> 8位的局部顶点索引。</p>
</li>
<li>
<p><strong><code>writePackedPrimitiveIndices4x8NV</code></strong>: 这是一个由 NVIDIA 扩展提供的、高度优化的 Mesh Shader 内置函数。它的作用是：</p>
<ul>
<li>接收一个压缩好的 <code>uint</code> 值。</li>
<li>在硬件内部高效地将其解包（Unpack），得到4个8位的局部顶点索引。</li>
<li>将这些索引添加到图元流中。GPU 会根据 <code>layout(triangles)</code> 的设置，将这些索引三个一组，自动装配成三角形。</li>
</ul>
</li>
</ol>
<table>
  <thead>
      <tr>
          <th style="text-align: left"></th>
          <th style="text-align: left">传统的 Index Buffer</th>
          <th style="text-align: left">Mesh Shader 的 PrimitiveIndices</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>指的是</strong></td>
          <td style="text-align: left">全局顶点索引 (Global Vertex Index)</td>
          <td style="text-align: left"><strong>局部顶点索引 (Local Vertex Index)</strong></td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>指向</strong></td>
          <td style="text-align: left">整个模型的全局顶点缓冲区</td>
          <td style="text-align: left"><strong>当前 Meshlet 自己的那一小部分顶点</strong></td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>数值范围</strong></td>
          <td style="text-align: left"><code>[0, 总顶点数 - 1]</code> (可能很大)</td>
          <td style="text-align: left"><code>[0, Meshlet内顶点数 - 1]</code> (通常很小, 如 <code>[0, 63]</code>)</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>作用</strong></td>
          <td style="text-align: left">定义如何连接全局顶点来组成三角形</td>
          <td style="text-align: left">定义如何连接<strong>局部</strong>顶点来组成三角形</td>
      </tr>
  </tbody>
</table>
<p>所以，<code>PrimitiveIndices</code> 可以理解为：“<strong>一个定义了如何将当前 Meshlet 的内部顶点连接成三角形的、经过压缩的局部索引列表。</strong>”</p>
<h2 id="深度金字塔">
<a class="header-anchor" href="#%e6%b7%b1%e5%ba%a6%e9%87%91%e5%ad%97%e5%a1%94"></a>
深度金字塔
</h2><p>深度金字塔本质上是场景深度缓冲（Depth Buffer）的一个Mipmap链。但它与普通的Mipmap不同：普通Mipmap通常对颜色值进行平均，而深度金字塔的每个像素存储的是其对应到上一级更高分辨率纹理中<strong>2x2区域内最远（最大）的深度值</strong>。</p>
<p>这个特性让它成为遮挡查询的利器。当测试一个物体的包围盒（Bounding Box）是否被遮挡时，我们只需将包围盒投影到屏幕空间，然后在深度金字塔的某个Mipmap层级进行采样。如果包围盒的<strong>最近</strong>深度值大于采样到的<strong>最远</strong>深度值，那么这个包围盒所代表的物体一定被完全遮挡。我们可以在较低分辨率的层级上进行测试，极大地降低了采样和计算开销。</p>
<h3 id="资源创建与设置">
<a class="header-anchor" href="#%e8%b5%84%e6%ba%90%e5%88%9b%e5%bb%ba%e4%b8%8e%e8%ae%be%e7%bd%ae"></a>
资源创建与设置
</h3><p>在生成金字塔之前，我们必须先在GPU上分配好所需的资源。这包括多级Mipmap的纹理、每个Mipmap层级的视图（View）以及用于数据绑定的描述符集（Descriptor Set）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 资源创建
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">DepthPyramidPass</span><span class="o">::</span><span class="n">create_depth_pyramid_resource</span><span class="p">(</span><span class="n">Texture</span><span class="o">*</span> <span class="n">depth_texture</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">u32</span> <span class="n">width</span> <span class="o">=</span> <span class="n">depth_texture</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">u32</span> <span class="n">height</span> <span class="o">=</span> <span class="n">depth_texture</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 计算金字塔层数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">depth_pyramid_levels</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">width</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">height</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">depth_pyramid_levels</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">width</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">height</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 创建一个带有多级 Mipmap 的纹理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">TextureCreation</span> <span class="n">depth_hierarchy_creation</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">    <span class="n">depth_hierarchy_creation</span><span class="p">.</span><span class="n">set_format_type</span><span class="p">(</span><span class="n">VK_FORMAT_R32_SFLOAT</span><span class="p">,</span> <span class="n">TextureType</span><span class="o">::</span><span class="n">Enum</span><span class="o">::</span><span class="n">Texture2D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">set_flags</span><span class="p">(</span><span class="n">TextureFlags</span><span class="o">::</span><span class="n">Compute_mask</span><span class="p">)</span> <span class="c1">// 标记为可用于Compute Shader读写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">.</span><span class="n">set_size</span><span class="p">(</span><span class="n">depth_texture</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">depth_texture</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">set_name</span><span class="p">(</span><span class="s">&#34;depth_hierarchy&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">set_mips</span><span class="p">(</span><span class="n">depth_pyramid_levels</span><span class="p">);</span> <span class="c1">// 指定 Mipmap 层数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">depth_pyramid</span> <span class="o">=</span> <span class="n">gpu</span><span class="p">.</span><span class="n">create_texture</span><span class="p">(</span><span class="n">depth_hierarchy_creation</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 为每一层 Mipmap 创建独立的视图和描述符集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">depth_pyramid_levels</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 创建指向特定 Mip 层的视图
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">depth_pyramid_view_creation</span><span class="p">.</span><span class="n">sub_resource</span><span class="p">.</span><span class="n">mip_base_level</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">depth_pyramid_views</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">gpu</span><span class="p">.</span><span class="n">create_texture_view</span><span class="p">(</span><span class="n">depth_pyramid_view_creation</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 绑定输入和输出纹理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 第一层：输入是原始深度图
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">descriptor_set_creation</span><span class="p">.</span><span class="n">reset</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">texture</span><span class="p">(</span><span class="n">depth_texture</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// binding 0: src
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">.</span><span class="n">texture</span><span class="p">(</span><span class="n">depth_pyramid_views</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// binding 1: dst
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">.</span><span class="n">set_layout</span><span class="p">(</span><span class="n">depth_pyramid_layout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 后续层：输入是上一级 Mip
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">descriptor_set_creation</span><span class="p">.</span><span class="n">reset</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">texture</span><span class="p">(</span><span class="n">depth_pyramid_views</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// binding 0: src
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">.</span><span class="n">texture</span><span class="p">(</span><span class="n">depth_pyramid_views</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>     <span class="c1">// binding 1: dst
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">.</span><span class="n">set_layout</span><span class="p">(</span><span class="n">depth_pyramid_layout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">depth_hierarchy_descriptor_set</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">gpu</span><span class="p">.</span><span class="n">create_descriptor_set</span><span class="p">(</span><span class="n">descriptor_set_creation</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol>
<li><strong>计算层数</strong>: 代码通过不断将分辨率减半来确定金字塔需要多少个Mipmap层级，直到尺寸过小为止。</li>
<li><strong>创建纹理</strong>: 创建了一个<code>R32_SFLOAT</code>格式的2D纹理，这是存储高精度深度值的标准格式。<code>Compute_mask</code>（在Vulkan中对应<code>VK_IMAGE_USAGE_STORAGE_BIT</code>）是关键，它允许我们在Compute Shader中通过<code>imageStore</code>直接写入纹理的特定像素。</li>
<li><strong>视图与描述符</strong>: 这是现代图形API（如Vulkan）的核心。我们不能直接将整个带Mipmap的纹理作为写入目标。相反，我们为<strong>每一层Mipmap</strong>创建一个独立的<code>ImageView</code>。在每一轮的降采样（downsampling）中，我们将上一层的视图作为输入（<code>src</code>），当前层的视图作为输出（<code>dst</code>），并将它们绑定到一个描述符集中，以便在Shader中访问。</li>
</ol>
<h3 id="降采样与最大值合并">
<a class="header-anchor" href="#%e9%99%8d%e9%87%87%e6%a0%b7%e4%b8%8e%e6%9c%80%e5%a4%a7%e5%80%bc%e5%90%88%e5%b9%b6"></a>
降采样与最大值合并
</h3><p>这是深度金字塔构建的算法核心。一个Compute Shader被派发来执行这个任务，它并行处理所有像素。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">set</span> <span class="o">=</span> <span class="n">MATERIAL_SET</span><span class="p">,</span> <span class="n">binding</span> <span class="o">=</span> <span class="mo">0</span><span class="p">)</span> <span class="k">uniform</span> <span class="k">sampler2D</span> <span class="n">src</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">set</span> <span class="o">=</span> <span class="n">MATERIAL_SET</span><span class="p">,</span> <span class="n">binding</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">uniform</span> <span class="n">writeonly</span> <span class="n">image2D</span> <span class="n">dst</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 计算当前线程ID对应的输出纹理坐标</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec2</span> <span class="n">out_coords</span> <span class="o">=</span> <span class="k">ivec2</span><span class="p">(</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 计算在源纹理（大一倍）中对应的 2x2 像素区域的左上角坐标</span>
</span></span><span class="line"><span class="cl">    <span class="k">ivec2</span> <span class="n">texel_position00</span> <span class="o">=</span> <span class="n">out_coords</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 采样 2x2 区域的四个深度值</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">d00</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span> <span class="n">src</span><span class="p">,</span> <span class="n">texel_position00</span><span class="p">,</span> <span class="mo">0</span> <span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">d01</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span> <span class="n">src</span><span class="p">,</span> <span class="n">texel_position00</span> <span class="o">+</span> <span class="k">ivec2</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mo">0</span> <span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">d10</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span> <span class="n">src</span><span class="p">,</span> <span class="n">texel_position00</span> <span class="o">+</span> <span class="k">ivec2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mo">0</span><span class="p">),</span> <span class="mo">0</span> <span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">d11</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span> <span class="n">src</span><span class="p">,</span> <span class="n">texel_position00</span> <span class="o">+</span> <span class="k">ivec2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mo">0</span> <span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4. 找出四个深度值中的最大值</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">result</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">d00</span><span class="p">,</span> <span class="n">d01</span><span class="p">),</span> <span class="n">max</span><span class="p">(</span><span class="n">d10</span><span class="p">,</span> <span class="n">d11</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 5. 将最大值写入目标纹理的对应位置</span>
</span></span><span class="line"><span class="cl">    <span class="n">imageStore</span><span class="p">(</span> <span class="n">dst</span><span class="p">,</span> <span class="n">out_coords</span><span class="p">,</span> <span class="k">vec4</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li><strong><code>texelFetch</code> vs. <code>texture</code></strong>: 这里使用<code>texelFetch</code>而不是<code>texture</code>，因为它允许我们使用精确的整数坐标来获取未经任何过滤（如线性插值）的原始像素值，这对于保留精确的深度信息至关重要。</li>
<li>一些现代GPU和API（如Vulkan的<code>VK_SAMPLER_REDUCTION_MODE_MAX</code>）提供了硬件级别的最大值/最小值缩减采样器。如果使用这种采样器，<code>texture()</code>函数就可以在硬件层面自动完成上述的4次<code>texelFetch</code>和<code>max</code>操作，从而使Shader更简洁，性能也可能更高。</li>
</ul>
<h3 id="执行与同步">
<a class="header-anchor" href="#%e6%89%a7%e8%a1%8c%e4%b8%8e%e5%90%8c%e6%ad%a5"></a>
执行与同步
</h3><p>最后，我们需要一个循环来驱动整个金字塔的生成过程，并确保每一步操作的顺序正确，避免数据竞争（Data Hazard）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 确保原始深度图可以作为Shader资源被读取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">util_add_image_barrier</span><span class="p">(</span><span class="n">gpu</span><span class="p">,</span> <span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">vk_command_buffer</span><span class="p">,</span> <span class="n">depth_texture</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="n">RESOURCE_STATE_SHADER_RESOURCE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 循环生成每一层 Mipmap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="n">u32</span> <span class="n">mip_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mip_index</span> <span class="o">&lt;</span> <span class="n">depth_pyramid_texture</span><span class="o">-&gt;</span><span class="n">mip_level_count</span><span class="p">;</span> <span class="o">++</span><span class="n">mip_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 内存屏障：转换当前 Mip 层的布局，准备写入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">util_add_image_barrier</span><span class="p">(</span><span class="n">gpu</span><span class="p">,</span> <span class="p">...,</span> <span class="n">RESOURCE_STATE_UNDEFINED</span><span class="p">,</span> <span class="n">RESOURCE_STATE_UNORDERED_ACCESS</span><span class="p">,</span> <span class="n">mip_index</span><span class="p">,</span> <span class="p">...);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 绑定当前层对应的描述符集 (包含了输入和输出)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">bind_descriptor_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">depth_hierarchy_descriptor_set</span><span class="p">[</span><span class="n">mip_index</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 派发 Compute Shader
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">u32</span> <span class="n">group_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span> <span class="c1">// (width / 8)向上取整
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">u32</span> <span class="n">group_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span> <span class="c1">// (height / 8)向上取整
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">gpu_commands</span><span class="o">-&gt;</span><span class="n">dispatch</span><span class="p">(</span><span class="n">group_x</span><span class="p">,</span> <span class="n">group_y</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4. 内存屏障：转换当前 Mip 层的布局，确保写入完成，并准备好在下一轮作为输入被读取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">util_add_image_barrier</span><span class="p">(</span><span class="n">gpu</span><span class="p">,</span> <span class="p">...,</span> <span class="n">RESOURCE_STATE_UNORDERED_ACCESS</span><span class="p">,</span> <span class="n">RESOURCE_STATE_SHADER_RESOURCE</span><span class="p">,</span> <span class="n">mip_index</span><span class="p">,</span> <span class="p">...);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">width</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">height</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="improved-culling-for-tiled-and-clustered-rendering">
<a class="header-anchor" href="#improved-culling-for-tiled-and-clustered-rendering"></a>
Improved Culling for Tiled and Clustered Rendering
</h1><p>在现代实时渲染中，如何高效地处理成百上千个动态光源，始终是一个核心挑战。无论是华丽的爆炸效果、闪烁的霓虹灯，还是角色身上复杂的环境反射，都离不开大量光源的支撑。然而，传统的光照计算方法在面对“灯海”时，往往会力不从心。</p>
<p>这正是 <strong>Tiled Shading</strong> (分块着色) 和 <strong>Clustered Shading</strong> (集群着色) 等现代渲染技术大显身手的地方。动视（Activision）在 SIGGRAPH 2017 上提出的混合技术——<a href="https://www.activision.com/cdn/research/2017_Sig_Improved_Culling_final.pdf">SIGGRAPH 2017: Improved Culling for Tiled and Clustered Rendering</a>。它巧妙地结合了两种方法的优点，为海量光源下的实时渲染提供了一套极其高效的解决方案。</p>
<p>要理解这项技术的巧妙之处，我们首先需要回顾一下传统方法的局限性：</p>
<ul>
<li><strong>Forward Rendering (前向渲染):</strong> 这是最经典的方法。每个物体在绘制时，都需要遍历所有可能影响它的光源。当光源数量 N 和物体数量 M 都很大时，计算成本会以 $O(N \times M)$ 的级别暴增，性能开销难以承受。</li>
<li><strong>Classic Deferred Shading (经典延迟着色):</strong> 该方法将光照计算推迟到所有物体都绘制到 G-Buffer (几何缓冲) 之后。它通过在屏幕空间对每个像素进行光照计算来解决 $O(N \times M)$ 的问题。但当光源数量巨大时，每个像素依然需要遍历所有光源，计算量依然庞大。此外，G-Buffer 本身也需要巨大的显存带宽。</li>
</ul>
<p>为了突破这些瓶颈，渲染工程师们将目光投向了将计算任务“分而治之”的思路。</p>
<h2 id="分块-tiled-与集群-clustered">
<a class="header-anchor" href="#%e5%88%86%e5%9d%97-tiled-%e4%b8%8e%e9%9b%86%e7%be%a4-clustered"></a>
分块 (Tiled) 与集群 (Clustered)
</h2><p><strong>分块着色 (Tiled Shading)</strong> 将屏幕划分为一个个 2D 网格（Tiles）。它预先计算出每个 Tile 可能受哪些光源影响，并将这个光源列表存储起来。在最终着色时，一个片元（Fragment）只需要检查其所在 Tile 的光源列表即可，大大减少了需要遍历的光源数量。</p>
<p><strong>集群着色 (Clustered Shading)</strong> 则在 2D 的基础上增加了一个维度：<strong>深度</strong>。它将摄像机的视锥体（View Frustum）划分为一个 3D 网格（Clusters）。这样，剔除光源时不仅考虑了它们在屏幕上的位置，还考虑了它们的远近。这使得光源剔除更加精准，尤其是在场景深度复杂的情况下。</p>
<h2 id="混合动力activision-的改进方案">
<a class="header-anchor" href="#%e6%b7%b7%e5%90%88%e5%8a%a8%e5%8a%9bactivision-%e7%9a%84%e6%94%b9%e8%bf%9b%e6%96%b9%e6%a1%88"></a>
混合动力：Activision 的改进方案
</h2><p>动视提出的这项技术，可以说是对上述两种思想的精炼与融合。它既利用了集群着色的深度信息，又保留了分块着色在屏幕空间的简洁性，形成了一套高效的混合剔除系统。</p>
<p>其核心算法流程如下：</p>
<ol>
<li>
<p><strong>光源排序 (Light Sorting):</strong> 首先，在<strong>相机空间 (Camera Space)</strong> 中，将所有光源根据深度进行排序。这一步是后续高效索引的基础。</p>
</li>
<li>
<p><strong>Z轴分箱 (Z-Binning):</strong> 接下来，算法并不会构建一个完整的 3D 网格，而是巧妙地将视锥体的深度（Z轴）划分为若干个“箱子”（Bins）。这些箱子可以是均匀划分的，也可以是<strong>对数 (Logarithmic)</strong> 划分的，以提高近处场景的精度。然后，根据每个光源的包围体（Bounding Volume）所覆盖的深度范围，将其分配到一个或多个 Z-bin 中。</p>
</li>
<li>
<p><strong>箱体索引 (Bin Indexing):</strong> 由于第一步已经对光源进行了排序，我们不需要在每个 Z-bin 中存储一个完整的光源列表。取而代之的是，我们只需为每个 bin 存储一个<strong>最小和最大光源索引 (min/max light indices)</strong>。这两个索引指向已排序的全局光源列表中的一个连续片段。这个设计极为节省内存，通常每个 bin 只需要 16 位（除非光源总数超过 65536 个）。</p>
</li>
<li>
<p><strong>屏幕分块 (Tile Division):</strong> 同时，屏幕空间被划分为许多小的 <strong>8×8 像素的瓦片 (Tiles)</strong>。对于每个 Tile，系统会计算出一个<strong>位掩码 (Bitfield)</strong>。这个位掩码的每一位对应一个光源，如果某个光源的包围体在屏幕上与该 Tile 有重叠，则其对应的位被设置为 1。</p>
</li>
<li>
<p><strong>最终光照查找 (Final Light Lookup):</strong> 当进入片元着色器（Fragment Shader）准备为某个像素着色时，魔法就发生了：</p>
<ul>
<li>GPU 首先获取当前片元的<strong>深度值</strong>，并以此确定它属于哪个 <strong>Z-bin</strong>。</li>
<li>通过 Z-bin 的索引，GPU 可以立刻得到一个可能影响该片元的光源索引范围 (<code>min_light_index</code>, <code>max_light_index</code>)。</li>
<li>同时，GPU 根据片元的屏幕坐标确定其所在的 <strong>Tile</strong>，并获取该 Tile 的<strong>光照位掩码</strong>。</li>
<li>最后，着色器只需遍历从 Z-bin 中获取的那个<strong>小范围</strong>内的光源。对于这个范围内的每一个光源，它会通过位运算检查其在 Tile 位掩码中对应的位是否为 1。</li>
</ul>
</li>
</ol>
<p>只有同时满足<strong>深度范围正确</strong>（来自 Z-bin）和<strong>屏幕范围重叠</strong>（来自 Tile Bitmask）这两个条件的光源，才是最终需要进行光照计算的有效光源。</p>
<h3 id="cpu端-light-culling-准备">
<a class="header-anchor" href="#cpu%e7%ab%af-light-culling-%e5%87%86%e5%a4%87"></a>
CPU端 Light Culling 准备
</h3><p>在上一篇文章中，我们介绍了动视这套混合剔除技术的理论：结合 <strong>Z轴分箱 (Z-Binning)</strong> 和 <strong>屏幕分块 (Tiled)</strong> 来高效确定光源列表。现在，我们将通过分析其 CPU 端的准备代码，来理解这套系统是如何构建其核心数据结构（Data Structures）的。</p>
<p>这个过程主要分为两大步：</p>
<ol>
<li><strong>构建Z轴分箱查找表 (Z-Bin LUT):</strong> 为每个深度“切片”生成一个包含潜在光源的索引范围。</li>
<li><strong>构建屏幕分块位掩码 (Tile Bitmask):</strong> 为每个屏幕“瓦片”生成一个位图，标记哪些光源与其重叠。</li>
</ol>
<h4 id="构建z轴分箱查找表-z-bin-lut">
<a class="header-anchor" href="#%e6%9e%84%e5%bb%baz%e8%bd%b4%e5%88%86%e7%ae%b1%e6%9f%a5%e6%89%be%e8%a1%a8-z-bin-lut"></a>
构建Z轴分箱查找表 (Z-Bin LUT)
</h4><p>这是整个流程的第一步，旨在将已按深度排序的光源分配到不同的深度区间（Z-Bins）中，并为每个区间生成一个紧凑的光源索引。</p>
<h5 id="为每个光源计算其覆盖的z-bin范围">
<a class="header-anchor" href="#%e4%b8%ba%e6%af%8f%e4%b8%aa%e5%85%89%e6%ba%90%e8%ae%a1%e7%ae%97%e5%85%b6%e8%a6%86%e7%9b%96%e7%9a%84z-bin%e8%8c%83%e5%9b%b4"></a>
为每个光源计算其覆盖的Z-Bin范围
</h5><p>首先，代码遍历所有已经排好序的光源，计算每个光源的包围球（Bounding Sphere）在深度上覆盖了哪些 Z-Bin。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// It might be better to use logarithmic slices to have better resolution
</span></span></span><span class="line"><span class="cl"><span class="c1">// closer to the camera.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="n">f32</span> <span class="n">bin_size</span> <span class="o">=</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="n">k_light_z_bins</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Array</span><span class="o">&lt;</span><span class="n">u32</span><span class="o">&gt;</span> <span class="n">bin_range_per_light</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">bin_range_per_light</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">scratch_allocator</span><span class="p">,</span> <span class="n">active_lights</span><span class="p">,</span> <span class="n">active_lights</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">active_lights</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">SortedLight</span><span class="o">&amp;</span> <span class="n">light</span> <span class="o">=</span> <span class="n">sorted_lights</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 跳过完全在摄像机背后的光源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">projected_z_min</span> <span class="o">&lt;</span> <span class="mf">0.0f</span> <span class="o">&amp;&amp;</span> <span class="n">light</span><span class="p">.</span><span class="n">projected_z_max</span> <span class="o">&lt;</span> <span class="mf">0.0f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">bin_range_per_light</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u32_max</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算光源覆盖的最小和最大 Z-Bin 索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// projected_z_min/max 已经是归一化到 [0, 1] 的深度值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="n">u32</span> <span class="n">min_bin</span> <span class="o">=</span> <span class="n">hydra</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hydra</span><span class="o">::</span><span class="n">floori32</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">projected_z_min</span> <span class="o">*</span> <span class="n">k_light_z_bins</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">u32</span> <span class="n">max_bin</span> <span class="o">=</span> <span class="n">hydra</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hydra</span><span class="o">::</span><span class="n">ceili32</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">projected_z_max</span> <span class="o">*</span> <span class="n">k_light_z_bins</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将 min_bin 和 max_bin 打包到一个 u32 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">bin_range_per_light</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_bin</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">max_bin</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li><code>projected_z_min</code> 和 <code>projected_z_max</code> 是光源包围球在相机空间下，经过投影变换后归一化到 <code>[0, 1]</code> 区间的最小和最大深度值。<code>0</code> 代表近平面（Near Plane），<code>1</code> 代表远平面（Far Plane）。</li>
<li>通过将归一化深度乘以总的 Bin 数量 <code>k_light_z_bins</code>，我们可以得到该深度对应的 Bin 索引。这里使用 <code>floor</code> 和 <code>ceil</code> 函数是为了确保能覆盖到光源包围球所接触到的所有 Bin。</li>
<li>位打包：<code>(min_bin &amp; 0xffff) | ((max_bin &amp; 0xffff) &lt;&lt; 16)</code>。它将两个 16 位的索引（<code>min_bin</code> 和 <code>max_bin</code>）合并存储到一个 32 位的整数中。这是一种常见的内存优化技巧，避免了为每个光源定义一个复杂的结构体。</li>
</ul>
<p>经过这个循环，我们得到了一个临时数组 <code>bin_range_per_light</code>，它记录了每个光源所影响的深度区间。</p>
<h5 id="为每个z-bin计算其包含的光源索引范围">
<a class="header-anchor" href="#%e4%b8%ba%e6%af%8f%e4%b8%aaz-bin%e8%ae%a1%e7%ae%97%e5%85%b6%e5%8c%85%e5%90%ab%e7%9a%84%e5%85%89%e6%ba%90%e7%b4%a2%e5%bc%95%e8%8c%83%e5%9b%b4"></a>
为每个Z-Bin计算其包含的光源索引范围
</h5><p>接下来，代码反过来遍历每一个 Z-Bin，并根据上一步的结果，找出影响该 Bin 的所有光源，并记录下它们在已排序光源列表中的最小和最大索引。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">u32</span> <span class="n">bin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bin</span> <span class="o">&lt;</span> <span class="n">k_light_z_bins</span><span class="p">;</span> <span class="o">++</span><span class="n">bin</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">u32</span> <span class="n">min_light_id</span> <span class="o">=</span> <span class="n">k_num_lights</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 初始为一个无效的最大值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">u32</span> <span class="n">max_light_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>               <span class="c1">// 初始为一个无效的最小值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">active_lights</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">u32</span> <span class="n">light_bins</span> <span class="o">=</span> <span class="n">bin_range_per_light</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">light_bins</span> <span class="o">==</span> <span class="n">u32_max</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 从 u32 中解包出 min_bin 和 max_bin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">const</span> <span class="n">u32</span> <span class="n">min_bin</span> <span class="o">=</span> <span class="n">light_bins</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">u32</span> <span class="n">max_bin</span> <span class="o">=</span> <span class="n">light_bins</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 检查当前光源是否覆盖了当前正在处理的 bin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">bin</span> <span class="o">&gt;=</span> <span class="n">min_bin</span> <span class="o">&amp;&amp;</span> <span class="n">bin</span> <span class="o">&lt;=</span> <span class="n">max_bin</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果是，更新这个 bin 所见光源的最小和最大索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">min_light_id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">min_light_id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">max_light_id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">max_light_id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将这个 bin 的光源索引范围打包并存入最终的 LUT
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">lights_lut</span><span class="p">[</span><span class="n">bin</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_light_id</span> <span class="o">|</span> <span class="p">(</span><span class="n">max_light_id</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>技术细节解析:</strong></p>
<ul>
<li>外层循环遍历所有 Z-Bin。</li>
<li>内层循环遍历所有光源，检查光源的 <code>[min_bin, max_bin]</code> 范围是否包含了当前的 <code>bin</code>。</li>
<li>如果包含，就用该光源的索引 <code>i</code> 来更新 <code>min_light_id</code> 和 <code>max_light_id</code>。</li>
<li><strong>核心优势</strong>：由于所有光源已经预先按深度排序，因此对于任何一个 Z-Bin，影响它的所有光源在 <code>sorted_lights</code> 数组中必然形成一个<strong>连续的块</strong>。因此，我们只需要存储这个连续块的起始和结束索引即可。这正是 <code>min_light_id</code> 和 <code>max_light_id</code> 的含义。</li>
<li>最后，和之前一样，将 <code>min_light_id</code> 和 <code>max_light_id</code> 打包进一个 <code>u32</code>，存入最终的查找表 <code>lights_lut</code>。</li>
</ul>
<p>至此，Z-Bin LUT 构建完毕。GPU 稍后只需根据片元的深度找到对应的 <code>bin</code>，就能从 <code>lights_lut</code> 中瞬间读出一个需要检查的光源索引范围。</p>
<h4 id="构建屏幕分块位掩码-tile-bitmask">
<a class="header-anchor" href="#%e6%9e%84%e5%bb%ba%e5%b1%8f%e5%b9%95%e5%88%86%e5%9d%97%e4%bd%8d%e6%8e%a9%e7%a0%81-tile-bitmask"></a>
构建屏幕分块位掩码 (Tile Bitmask)
</h4><p>这一步的目标是为屏幕上的每个 Tile 创建一个位掩码，用于快速判断哪些光源的投影与该 Tile 重叠。</p>
<h5 id="计算光源在屏幕空间的2d包围盒">
<a class="header-anchor" href="#%e8%ae%a1%e7%ae%97%e5%85%89%e6%ba%90%e5%9c%a8%e5%b1%8f%e5%b9%95%e7%a9%ba%e9%97%b4%e7%9a%842d%e5%8c%85%e5%9b%b4%e7%9b%92"></a>
计算光源在屏幕空间的2D包围盒
</h5><p>这是整个 CPU 准备阶段中数学上最复杂的部分。我们需要将三维世界中的光源包围球，精确地投影为屏幕上的一个二维矩形包围盒 (AABB)。简单地投影球心再在屏幕空间加上半径是<strong>不精确</strong>的。正确的方法需要找到从视点到球体的切线，并计算这些切线与投影平面的交点。</p>
<p>这里可以直接复用前面Meshlet Culling的包围盒计算方法。我们将光源的包围球投影到屏幕空间，并计算出它在屏幕上的 AABB（Axis-Aligned Bounding Box）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 迭代所有激活的光源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">active_lights</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 获取光源位置和半径 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vec4s</span> <span class="n">view_space_pos</span> <span class="o">=</span> <span class="n">glms_mat4_mulv</span><span class="p">(</span><span class="n">game_camera</span><span class="p">.</span><span class="n">camera</span><span class="p">.</span><span class="n">view</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... (一系列复杂的数学计算) ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 最终目标是得到一个NDC坐标系下的AABB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vec4s</span> <span class="n">aabb</span><span class="p">{</span> <span class="n">min_ndc_x</span><span class="p">,</span> <span class="n">min_ndc_y</span><span class="p">,</span> <span class="n">max_ndc_x</span><span class="p">,</span> <span class="n">max_ndc_y</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将NDC坐标 [-1, 1] 转换为屏幕像素坐标 [0, width] / [0, height]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vec4s</span> <span class="n">aabb_screen</span><span class="p">{(</span><span class="n">aabb</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="mf">0.5f</span> <span class="o">+</span> <span class="mf">0.5f</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gpu</span><span class="p">.</span><span class="n">swapchain_width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                      <span class="p">(</span><span class="n">aabb</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="mf">0.5f</span> <span class="o">+</span> <span class="mf">0.5f</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gpu</span><span class="p">.</span><span class="n">swapchain_height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                      <span class="p">(</span><span class="n">aabb</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="mf">0.5f</span> <span class="o">+</span> <span class="mf">0.5f</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gpu</span><span class="p">.</span><span class="n">swapchain_width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                      <span class="p">(</span><span class="n">aabb</span><span class="p">.</span><span class="n">w</span> <span class="o">*</span> <span class="mf">0.5f</span> <span class="o">+</span> <span class="mf">0.5f</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gpu</span><span class="p">.</span><span class="n">swapchain_height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)};</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>精确计算球体投影边界通常涉及求解视点、球心和切点构成的直角三角形。通过一系列的向量和矩阵运算，可以找到球体在视锥体近平面上投影的边界点。</p>
<p>最终，无论使用哪种方法，我们都会得到一个在归一化设备坐标（NDC）下的 <code>aabb</code>，然后通过简单的线性变换，将其映射到屏幕像素坐标 <code>aabb_screen</code>。</p>
<h5 id="将光源信息填充到tile网格中">
<a class="header-anchor" href="#%e5%b0%86%e5%85%89%e6%ba%90%e4%bf%a1%e6%81%af%e5%a1%ab%e5%85%85%e5%88%b0tile%e7%bd%91%e6%a0%bc%e4%b8%ad"></a>
将光源信息填充到Tile网格中
</h5><p>有了每个光源在屏幕上的像素包围盒，我们就可以确定它覆盖了哪些 Tile，并在这些 Tile 的位掩码中进行标记。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="c1">// 计算 Tile 的数量和尺寸
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">k_num_lights</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">k_light_z_bins</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">k_tile_size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">k_num_words</span> <span class="o">=</span> <span class="p">(</span><span class="n">k_num_lights</span> <span class="o">+</span> <span class="mi">31</span><span class="p">)</span> <span class="o">/</span> <span class="mi">32</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">u32</span> <span class="n">tile_x_count</span> <span class="o">=</span> <span class="n">scene_data</span><span class="p">.</span><span class="n">resolution_x</span> <span class="o">/</span> <span class="n">k_tile_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">u32</span> <span class="n">tile_y_count</span> <span class="o">=</span> <span class="n">scene_data</span><span class="p">.</span><span class="n">resolution_y</span> <span class="o">/</span> <span class="n">k_tile_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Assign light
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Array</span><span class="o">&lt;</span><span class="n">u32</span><span class="o">&gt;</span> <span class="n">light_tiles_bits</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">light_tiles_bits</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">tile_x_count</span> <span class="o">*</span> <span class="n">tile_y_count</span> <span class="o">*</span> <span class="n">k_num_words</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 计算得到屏幕坐标 aabb_screen ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 裁剪和边界检查，确保 AABB 在屏幕范围内
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">min_x</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">min_x</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">min_y</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">min_y</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">max_x</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">max_x</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">gpu</span><span class="p">.</span><span class="n">swapchain_width</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">max_y</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">max_y</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">gpu</span><span class="p">.</span><span class="n">swapchain_height</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 根据AABB计算它覆盖的 tile 范围
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">u32</span> <span class="n">first_tile_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">min_x</span> <span class="o">*</span> <span class="n">tile_size_inv</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">u32</span> <span class="n">last_tile_x</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tile_x_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">max_x</span> <span class="o">*</span> <span class="n">tile_size_inv</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">u32</span> <span class="n">first_tile_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">min_y</span> <span class="o">*</span> <span class="n">tile_size_inv</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">u32</span> <span class="n">last_tile_y</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tile_y_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">max_y</span> <span class="o">*</span> <span class="n">tile_size_inv</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历所有被该光源覆盖的 tile
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">u32</span> <span class="n">y</span> <span class="o">=</span> <span class="n">first_tile_y</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">last_tile_y</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">u32</span> <span class="n">x</span> <span class="o">=</span> <span class="n">first_tile_x</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">last_tile_x</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 计算当前 tile 在一维数组中的索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">u32</span> <span class="n">array_index</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">tile_stride</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">k_num_words</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 计算当前光源 i 应该在位掩码的哪个 u32 的哪一位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">u32</span> <span class="n">word_index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">32</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">u32</span> <span class="n">bit_index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">32</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 将对应的位置1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">light_tiles_bits</span><span class="p">[</span><span class="n">array_index</span> <span class="o">+</span> <span class="n">word_index</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><ul>
<li><code>tile_size_inv</code> 是 <code>1.0f / k_tile_size</code>，用于快速将像素坐标转换为 Tile 索引。</li>
<li>双层循环 <code>for (u32 y ...)</code> <code>for (u32 x ...)</code> 遍历了光源AABB覆盖的所有Tile。</li>
<li><code>light_tiles_bits</code> 是一个一维数组，模拟一个二维的 Tile 网格。每个 Tile 自身又由 <code>k_num_words</code> 个 <code>u32</code> 组成，以容纳所有光源的位信息（例如，如果有 100 个光源，每个 Tile 就需要 4 个 <code>u32</code> 来做位掩码）。</li>
<li><code>word_index = i / 32</code> 和 <code>bit_index = i % 32</code> 是标准的位操作，用于定位到第 <code>i</code> 个光源在位掩码数组中对应的比特位。</li>
<li><code>|= (1 &lt;&lt; bit_index)</code> 使用按位或（OR）操作，将该光源对应的比特位置为 <code>1</code>，表示“此光源与该 Tile 重叠”。</li>
</ul>
<p>至此，CPU 完成了它的使命。GPU 此时拥有了完成高效剔除所需的一切：一个按深度排序的光源列表、一个深度过滤的查找表和一个屏幕空间过滤的位掩码网格。下一阶段，片元着色器将利用这些数据，以极低的成本找出最终影响每个像素的光源列表。</p>
<h3 id="gpu端-光照剔除与计算">
<a class="header-anchor" href="#gpu%e7%ab%af-%e5%85%89%e7%85%a7%e5%89%94%e9%99%a4%e4%b8%8e%e8%ae%a1%e7%ae%97"></a>
GPU端 光照剔除与计算
</h3><p>当渲染管线进入像素着色阶段，GPU 面临着为屏幕上数百万个像素独立计算颜色的艰巨任务。我们的目标是，让每个像素都能高效地从成百上千的光源中，只挑选出真正对它有贡献的几个，并完成光照计算。</p>
<h4 id="双重过滤获取初步光源列表">
<a class="header-anchor" href="#%e5%8f%8c%e9%87%8d%e8%bf%87%e6%bb%a4%e8%8e%b7%e5%8f%96%e5%88%9d%e6%ad%a5%e5%85%89%e6%ba%90%e5%88%97%e8%a1%a8"></a>
双重过滤，获取初步光源列表
</h4><p>对于任意一个正在被着色的片元（Fragment/Pixel），我们首先需要确定它在我们的剔除结构中的位置。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="k">vec4</span> <span class="n">final_color</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 1. 获取片元在相机空间的坐标</span>
</span></span><span class="line"><span class="cl"><span class="k">vec4</span> <span class="n">pos_camera_space</span> <span class="o">=</span> <span class="n">world_to_camera</span> <span class="o">*</span> <span class="k">vec4</span><span class="p">(</span><span class="n">world_position</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 2. 根据深度计算 Z-Bin 索引</span>
</span></span><span class="line"><span class="cl"><span class="k">float</span> <span class="n">linear_d</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos_camera_space</span><span class="p">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">z_near</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">z_light_far</span> <span class="o">-</span> <span class="n">z_near</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">int</span> <span class="n">bin_index</span> <span class="o">=</span> <span class="k">int</span><span class="p">(</span><span class="n">linear_d</span> <span class="o">/</span> <span class="n">BIN_WIDTH</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 3. 从 Z-Bin LUT 中获取光源索引范围</span>
</span></span><span class="line"><span class="cl"><span class="n">uint</span> <span class="n">bin_value</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="n">bin_index</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">uint</span> <span class="n">min_light_id</span> <span class="o">=</span> <span class="n">bin_value</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">uint</span> <span class="n">max_light_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_value</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 4. 根据屏幕坐标计算 Tile 地址</span>
</span></span><span class="line"><span class="cl"><span class="n">uvec2</span> <span class="n">tile</span> <span class="o">=</span> <span class="n">position</span> <span class="o">/</span> <span class="n">uint</span><span class="p">(</span><span class="n">TILE_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">uint</span> <span class="n">stride</span> <span class="o">=</span> <span class="n">uint</span><span class="p">(</span><span class="n">NUM_WORDS</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">uint</span><span class="p">(</span><span class="n">resolution</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">uint</span><span class="p">(</span><span class="n">TILE_SIZE</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">uint</span> <span class="n">address</span> <span class="o">=</span> <span class="n">tile</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">stride</span> <span class="o">+</span> <span class="n">tile</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span></code></pre></div><ol>
<li><strong>确定深度 (Z-Bin):</strong> 首先，将片元的世界坐标转换到相机空间，获取其深度值 <code>pos_camera_space.z</code>。通过线性化处理（映射到 <code>[0, 1]</code> 区间），我们能迅速计算出该片元所属的 <code>bin_index</code>。</li>
<li><strong>获取深度过滤结果:</strong> 使用 <code>bin_index</code> 从我们之前上传的 <code>bins</code> (即 <code>lights_lut</code>) 查找表中取出一个 <code>u32</code> 值。通过位运算，我们从中解包出 <code>min_light_id</code> 和 <code>max_light_id</code>。这给了我们一个经过深度过滤的、大大缩小的潜在光源索引范围。</li>
<li><strong>确定位置 (Tile):</strong> 使用片元的屏幕像素坐标 <code>position</code>，除以瓦片大小 <code>TILE_SIZE</code>，得到它所属的 <code>tile</code> 坐标。</li>
<li><strong>获取屏幕过滤地址:</strong> 将二维的 <code>tile</code> 坐标转换为一维数组 <code>tiles</code> (即 <code>light_tiles_bits</code>) 中的内存地址 <code>address</code>。这个地址指向了该 Tile 对应的位掩码数据的起始位置。</li>
</ol>
<p>现在，我们手上有了两样利器：一个来自 Z-Bin 的<strong>光源索引范围</strong> (<code>min_light_id</code> 到 <code>max_light_id</code>)，和一个来自 Tile 的<strong>位掩码</strong>（从 <code>address</code> 开始）。接下来就是将它们结合起来，找出最终的光源列表。</p>
<h4 id="朴素实现">
<a class="header-anchor" href="#%e6%9c%b4%e7%b4%a0%e5%ae%9e%e7%8e%b0"></a>
朴素实现
</h4><p>预编译宏 <code>#if ENABLE_OPTIMIZATION</code> 区分两种实现方式：一种是基础的朴素实现，另一种是利用现代 GPU <code>subgroup</code>（或称 <code>wavefront</code>）特性的高级优化实现。</p>
<p>朴素实现直接遍历由 Z-Bin 确定的光源范围，并对范围内的每个光源检查其在 Tile 位掩码中对应的位是否为1。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="cp">#else // 未开启优化</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 检查 min_light_id 是否有效</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">min_light_id</span> <span class="o">!=</span> <span class="n">NUM_LIGHTS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历 Z-Bin 给出的光源索引范围</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">light_id</span> <span class="o">=</span> <span class="n">min_light_id</span><span class="p">;</span> <span class="n">light_id</span> <span class="o">&lt;=</span> <span class="n">max_light_id</span><span class="p">;</span> <span class="o">++</span><span class="n">light_id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 计算该光源在位掩码中的位置</span>
</span></span><span class="line"><span class="cl">      <span class="n">uint</span> <span class="n">word_id</span> <span class="o">=</span> <span class="n">light_id</span> <span class="o">/</span> <span class="mi">32</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">uint</span> <span class="n">bit_id</span> <span class="o">=</span> <span class="n">light_id</span> <span class="o">%</span> <span class="mi">32</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// 检查 Tile 位掩码中对应的位是否为 1</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">((</span><span class="n">tiles</span><span class="p">[</span><span class="n">address</span> <span class="o">+</span> <span class="n">word_id</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit_id</span><span class="p">))</span> <span class="o">!=</span> <span class="mo">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果两个条件都满足，该光源有效，进行光照计算</span>
</span></span><span class="line"><span class="cl">        <span class="n">uint</span> <span class="n">global_light_index</span> <span class="o">=</span> <span class="n">light_indices</span><span class="p">[</span><span class="n">light_id</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">final_color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">+=</span>
</span></span><span class="line"><span class="cl">            <span class="n">calculate_point_light_contribution</span><span class="p">(...);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span></code></pre></div><p>这种方法的主要问题在于 <strong>线程发散 (Thread Divergence)</strong>。在 GPU 的 SIMD 执行模型（如一个包含 32 或 64 个线程的 <code>wavefront</code>）中，如果同一个 <code>wavefront</code> 内的线程执行了不同的分支（例如，某些像素的 <code>if</code> 条件为真，另一些为假），硬件的执行效率会下降，因为部分线程需要等待。</p>
<h4 id="基于-subgroup-的协同计算">
<a class="header-anchor" href="#%e5%9f%ba%e4%ba%8e-subgroup-%e7%9a%84%e5%8d%8f%e5%90%8c%e8%ae%a1%e7%ae%97"></a>
基于 Subgroup 的协同计算
</h4><p>为了解决线程发散问题，现代 GPU 提供了 <code>subgroup</code> 操作，允许一个 <code>wavefront</code> 内的所有线程协同工作，共享数据，并统一执行路径。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="cp">#if ENABLE_OPTIMIZATION</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 1. 在整个 subgroup 中找到一个统一的、更大的光源索引范围</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint</span> <span class="n">merged_min</span> <span class="o">=</span> <span class="n">subgroupBroadcastFirst</span><span class="p">(</span><span class="n">subgroupMin</span><span class="p">(</span><span class="n">min_light_id</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint</span> <span class="n">merged_max</span> <span class="o">=</span> <span class="n">subgroupBroadcastFirst</span><span class="p">(</span><span class="n">subgroupMax</span><span class="p">(</span><span class="n">max_light_id</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 计算这个统一范围覆盖了哪些 u32 &#34;words&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint</span> <span class="n">word_min</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">merged_min</span> <span class="o">/</span> <span class="mi">32</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint</span> <span class="n">word_max</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">merged_max</span> <span class="o">/</span> <span class="mi">32</span><span class="p">,</span> <span class="n">NUM_WORDS</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 2. 以统一的 word 范围进行循环，避免了循环本身的发散</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">word_index</span> <span class="o">=</span> <span class="n">word_min</span><span class="p">;</span> <span class="n">word_index</span> <span class="o">&lt;=</span> <span class="n">word_max</span><span class="p">;</span> <span class="o">++</span><span class="n">word_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">tiles</span><span class="p">[</span><span class="n">address</span> <span class="o">+</span> <span class="n">word_index</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 为每个线程重新构建其独立的 Z-Bin 掩码</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">local_min</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="k">int</span><span class="p">(</span><span class="n">min_light_id</span><span class="p">)</span> <span class="o">-</span> <span class="k">int</span><span class="p">((</span><span class="n">word_index</span> <span class="o">*</span> <span class="mi">32</span><span class="p">)),</span> <span class="mo">0</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">mask_width</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="k">int</span><span class="p">(</span><span class="n">max_light_id</span><span class="p">)</span> <span class="o">-</span> <span class="k">int</span><span class="p">(</span><span class="n">min_light_id</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">zbin_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask_width</span> <span class="o">==</span> <span class="mi">32</span><span class="p">)</span> <span class="o">?</span> <span class="n">uint</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">)</span> <span class="o">:</span> <span class="n">bit_field_mask</span><span class="p">(</span><span class="n">mask_width</span><span class="p">,</span> <span class="n">local_min</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 应用 Z-Bin 掩码</span>
</span></span><span class="line"><span class="cl">    <span class="n">mask</span> <span class="o">&amp;=</span> <span class="n">zbin_mask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4. 将 subgroup 中所有线程的有效光源掩码进行“或”操作，得到一个统一的掩码</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">merged_mask</span> <span class="o">=</span> <span class="n">subgroupBroadcastFirst</span><span class="p">(</span><span class="n">subgroupOr</span><span class="p">(</span><span class="n">mask</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 5. 在统一的掩码上循环，所有线程执行完全相同的路径</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">merged_mask</span> <span class="o">!=</span> <span class="mo">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">uint</span> <span class="n">bit_index</span> <span class="o">=</span> <span class="n">get_lowest_bit</span><span class="p">(</span><span class="n">merged_mask</span><span class="p">);</span> <span class="c1">// 找到第一个为1的位</span>
</span></span><span class="line"><span class="cl">      <span class="n">uint</span> <span class="n">light_index</span> <span class="o">=</span> <span class="mi">32</span> <span class="o">*</span> <span class="n">word_index</span> <span class="o">+</span> <span class="n">bit_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">merged_mask</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit_index</span><span class="p">);</span> <span class="c1">// 清除该位</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">uint</span> <span class="n">global_light_index</span> <span class="o">=</span> <span class="n">light_indices</span><span class="p">[</span><span class="n">light_index</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="n">final_color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">+=</span>
</span></span><span class="line"><span class="cl">          <span class="n">calculate_point_light_contribution</span><span class="p">(...);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span></code></pre></div><ol>
<li><strong>统一循环范围:</strong> 使用 <code>subgroupMin</code> 和 <code>subgroupMax</code> 在 <code>wavefront</code> 内找到所有线程中最小的 <code>min_light_id</code> 和最大的 <code>max_light_id</code>。<code>subgroupBroadcastFirst</code> 确保每个线程都使用这个<strong>统一的范围</strong> (<code>merged_min</code>, <code>merged_max</code>)。这使得外层的 <code>for</code> 循环对 <code>wavefront</code> 内所有线程来说都是一致的，<strong>消除了循环层面的发散</strong>。</li>
<li><strong>重建 Z-Bin 过滤:</strong> 虽然外层循环范围扩大了，但每个线程独立的 <code>min/max</code> 信息不能丢。因此，在循环内部，通过 <code>bit_field_mask</code> 为每个线程动态生成一个 <code>zbin_mask</code>。这个掩码代表了在该 32 位 <code>word</code> 中，哪些位是符合当前线程的 Z-Bin 范围的。<code>mask &amp;= zbin_mask;</code> 这一步，巧妙地将 Tile 掩码和 Z-Bin 掩码结合了起来。</li>
<li><strong>统一迭代掩码:</strong> 再次使用 <code>subgroupOr</code> 将 <code>wavefront</code> 内所有线程的 <code>mask</code> 合并成一个 <code>merged_mask</code>。这个 <code>merged_mask</code> 包含了对 <code>wavefront</code> 内<strong>任何一个线程</strong>有效的所有光源。</li>
<li><strong>无发散迭代:</strong> 最后的 <code>while</code> 循环在 <code>merged_mask</code> 上进行。因为 <code>merged_mask</code> 对所有线程都是相同的（标量），这个循环以及内部的位操作 (<code>get_lowest_bit</code>, <code>^=</code>) <strong>完全没有线程发散</strong>。</li>
<li><strong>代价与收益:</strong> 这种方法可能会让某些线程计算一些对它们来说本无效的光源，但因为避免了代价高昂的线程发散，总体性能通常会更高。这是用计算换取更高并行效率的典型案例。</li>
</ol>
<h4 id="光照合成与最终着色">
<a class="header-anchor" href="#%e5%85%89%e7%85%a7%e5%90%88%e6%88%90%e4%b8%8e%e6%9c%80%e7%bb%88%e7%9d%80%e8%89%b2"></a>
光照合成与最终着色
</h4><p>在通过上述剔除方法计算完所有动态点光源的贡献后，着色器还会继续完成其他光照成分的计算。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl">  <span class="c1">// ... 其他光源，如定向光、带阴影的光源 ...</span>
</span></span><span class="line"><span class="cl">  <span class="n">final_color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">+=</span> <span class="n">calculate_directional_light_contribution</span><span class="p">(...);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">vec3</span> <span class="n">F</span> <span class="o">=</span> <span class="n">fresnel_schlick_roughness</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">F0</span><span class="p">,</span> <span class="n">roughness</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...</span>
</span></span><span class="line"><span class="cl">  <span class="n">kD</span> <span class="o">*=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">metallic</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// 间接光照-漫反射</span>
</span></span><span class="line"><span class="cl">  <span class="k">vec3</span> <span class="n">indirect_diffuse</span> <span class="o">=</span> <span class="n">indirect_irradiance</span> <span class="o">*</span> <span class="n">gi_intensity</span> <span class="o">*</span> <span class="n">base_colour</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">final_color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">+=</span> <span class="p">(</span><span class="n">kD</span> <span class="o">*</span> <span class="n">indirect_diffuse</span><span class="p">)</span> <span class="o">*</span> <span class="n">ao</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 间接光照-镜面反射</span>
</span></span><span class="line"><span class="cl">  <span class="k">vec2</span> <span class="n">envBRDF</span> <span class="o">=</span> <span class="n">textureLod</span><span class="p">(</span><span class="n">brdf_lut_texture</span><span class="p">,</span> <span class="k">vec2</span><span class="p">(</span><span class="n">NoV</span><span class="p">,</span> <span class="n">roughness</span><span class="p">),</span> <span class="mo">0</span><span class="p">).</span><span class="n">rg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">vec3</span> <span class="n">indirect_specular</span> <span class="o">=</span> <span class="n">reflection_color</span> <span class="o">*</span> <span class="p">(</span><span class="n">F</span> <span class="o">*</span> <span class="n">envBRDF</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">envBRDF</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">final_color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">+=</span> <span class="p">(</span><span class="n">indirect_specular</span><span class="p">)</span> <span class="o">*</span> <span class="n">ao</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ... 添加自发光 ...</span>
</span></span><span class="line"><span class="cl">  <span class="n">final_color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">+=</span> <span class="n">emissive</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ... sRGB 编码并返回 ...</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">vec4</span><span class="p">(</span><span class="n">encode_srgb</span><span class="p">(</span><span class="n">final_color</span><span class="p">.</span><span class="n">rgb</span><span class="p">),</span> <span class="n">final_color</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
</span></span></code></pre></div><p>这部分是标准的 PBR (Physically-Based Rendering) 流程，将直接光照、间接光照（漫反射和镜面反射）、自发光等所有成分叠加起来，构成最终的像素颜色。</p>
<h2 id="附录">
<a class="header-anchor" href="#%e9%99%84%e5%bd%95"></a>
附录
</h2><p>如何为一个三维的光源包围球计算出其在二维屏幕上的紧凑包围盒 (AABB)。</p>
<p>这是一个比看起来要复杂的问题。由于透视投影的非线性特性，我们不能简单地将球心投影到屏幕上，然后在屏幕空间加上半径——这样做会得到一个不准确、过大的包围盒。我查询到三种不同的实现方法，每种方法都在精度、鲁棒性和性能之间做出了不同的权衡。</p>
<h3 id="方法一2d-平面解法">
<a class="header-anchor" href="#%e6%96%b9%e6%b3%95%e4%b8%802d-%e5%b9%b3%e9%9d%a2%e8%a7%a3%e6%b3%95"></a>
方法一：2D 平面解法
</h3><p>其核心思想是，将 3D 问题分解为两个独立的 2D 问题来求解：一个在视图空间的 XZ 平面上，另一个在 YZ 平面上。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 1. 在 XZ 平面上求解
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vec2s</span> <span class="n">cx</span><span class="p">{</span><span class="n">view_space_pos</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">view_space_pos</span><span class="p">.</span><span class="n">z</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 计算相机到圆心的距离的平方 与 半径的平方 的差值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="n">f32</span> <span class="n">tx_squared</span> <span class="o">=</span> <span class="n">glms_vec2_dot</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">cx</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">bool</span> <span class="n">tx_camera_inside</span> <span class="o">=</span> <span class="n">tx_squared</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 计算一个包含切线信息的辅助向量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vec2s</span> <span class="n">vx</span><span class="p">{</span><span class="n">sqrtf</span><span class="p">(</span><span class="n">tx_squared</span><span class="p">),</span> <span class="n">radius</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 构造一个 2D 旋转缩放矩阵
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">mat2s</span> <span class="n">xtransf_min</span><span class="p">{</span><span class="n">vx</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">vx</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="n">vx</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">vx</span><span class="p">.</span><span class="n">x</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 计算下边界切点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vec2s</span> <span class="n">minx</span> <span class="o">=</span> <span class="n">glms_mat2_mulv</span><span class="p">(</span><span class="n">xtransf_min</span><span class="p">,</span> <span class="n">cx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 构造另一个旋转缩放矩阵
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">mat2s</span> <span class="n">xtransf_max</span><span class="p">{</span><span class="n">vx</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">vx</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">vx</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">vx</span><span class="p">.</span><span class="n">x</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 计算上边界切点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vec2s</span> <span class="n">maxx</span> <span class="o">=</span> <span class="n">glms_mat2_mulv</span><span class="p">(</span><span class="n">xtransf_max</span><span class="p">,</span> <span class="n">cx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 2. 在 YZ 平面上做同样的操作 (注意 Y 轴取反)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vec2s</span> <span class="n">cy</span><span class="p">{</span><span class="o">-</span><span class="n">view_space_pos</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">view_space_pos</span><span class="p">.</span><span class="n">z</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ... 类似的计算 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vec2s</span> <span class="n">miny</span> <span class="o">=</span> <span class="p">...;</span>
</span></span><span class="line"><span class="cl"><span class="n">vec2s</span> <span class="n">maxy</span> <span class="o">=</span> <span class="p">...;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 3. 将 2D 切点坐标转换为 NDC 坐标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vec4s</span> <span class="n">aabb</span><span class="p">{</span><span class="n">minx</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">minx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">game_camera</span><span class="p">.</span><span class="n">camera</span><span class="p">.</span><span class="n">projection</span><span class="p">.</span><span class="n">m00</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="n">miny</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">miny</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">game_camera</span><span class="p">.</span><span class="n">camera</span><span class="p">.</span><span class="n">projection</span><span class="p">.</span><span class="n">m11</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="n">maxx</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">maxx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">game_camera</span><span class="p">.</span><span class="n">camera</span><span class="p">.</span><span class="n">projection</span><span class="p">.</span><span class="n">m00</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="n">maxy</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">maxy</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">game_camera</span><span class="p">.</span><span class="n">camera</span><span class="p">.</span><span class="n">projection</span><span class="p">.</span><span class="n">m11</span><span class="p">};</span>
</span></span></code></pre></div><p>这个方法非常巧妙。让我们以 XZ 平面为例来剖析：</p>
<ol>
<li><strong>降维打击:</strong> 它将相机（位于原点）和球体在 XZ 平面上的投影视为一个 2D 的圆。我们的目标是找到从原点到这个圆的两条切线。</li>
<li><strong>寻找切点:</strong>
<ul>
<li><code>tx_squared</code> 计算的是从原点到圆的<strong>切线长度的平方</strong>。如果该值为负，说明原点在圆内。</li>
<li>向量 <code>vx</code> 包含了切线长度 <code>sqrt(tx_squared)</code> 和半径 <code>r</code>。这两个值与圆心向量 <code>cx</code> 构成了一个直角三角形。</li>
<li>矩阵 <code>xtransf_min</code> 和 <code>xtransf_max</code> 是两个未归一化的<strong>旋转矩阵</strong>。它们的作用是将圆心向量 <code>cx</code> 旋转一个角度 <code>θ</code> (或 <code>-θ</code>)，其中 <code>θ</code> 是圆心向量与切线向量之间的夹角。旋转后的结果 <code>minx</code> 和 <code>maxx</code> 就是切点在 XZ 平面上的坐标。这避免了使用 <code>atan</code> 等开销较大的三角函数。</li>
</ul>
</li>
<li><strong>透视投影:</strong>
<ul>
<li>在视图空间中，一个点 <code>(x, y, z)</code> 投影到 NDC 坐标的计算公式与 <code>x/z</code> 和 <code>y/z</code> 相关。</li>
<li>因此，<code>minx.x / minx.y</code> 计算的正是切点的 <code>x</code> 坐标除以其 <code>z</code> 坐标。</li>
<li>最后乘以投影矩阵中的焦距项 (<code>projection.m00</code> 或 <code>projection.m11</code>)，就得到了最终的 NDC 坐标。</li>
</ul>
</li>
</ol>
<p>这个方法速度很快，因为它只涉及 2D 向量和 2x2 矩阵运算。但它没有显式地处理与近裁剪面相交的情况，在某些极端场景下可能不够鲁棒。</p>
<h3 id="mcguire-方法-最精确">
<a class="header-anchor" href="#mcguire-%e6%96%b9%e6%b3%95-%e6%9c%80%e7%b2%be%e7%a1%ae"></a>
McGuire 方法 (最精确)
</h3><p>该方法基于 Michael Mara 和 Morgan McGuire 的论文《2D Polyhedral Bounds of a Clipped, Perspective-Projected 3D Sphere》，它能正确处理球体与近裁剪面相交的情况。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">use_mcguire_method</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vec3s</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">bottom</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 沿 X 轴 (1,0,0) 找到左右边界点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">get_bounds_for_axis</span><span class="p">(</span><span class="n">vec3s</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="n">view_space_pos</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                        <span class="n">game_camera</span><span class="p">.</span><span class="n">camera</span><span class="p">.</span><span class="n">near_plane</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 沿 Y 轴 (0,1,0) 找到上下边界点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">get_bounds_for_axis</span><span class="p">(</span><span class="n">vec3s</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="n">view_space_pos</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                        <span class="n">game_camera</span><span class="p">.</span><span class="n">camera</span><span class="p">.</span><span class="n">near_plane</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">bottom</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 将这些视图空间的边界点投影到 NDC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">left</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">game_camera</span><span class="p">.</span><span class="n">camera</span><span class="p">.</span><span class="n">projection</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">right</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">game_camera</span><span class="p">.</span><span class="n">camera</span><span class="p">.</span><span class="n">projection</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">top</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">game_camera</span><span class="p">.</span><span class="n">camera</span><span class="p">.</span><span class="n">projection</span><span class="p">,</span> <span class="n">top</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">bottom</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">game_camera</span><span class="p">.</span><span class="n">camera</span><span class="p">.</span><span class="n">projection</span><span class="p">,</span> <span class="n">bottom</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4. 组合成最终的 AABB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">aabb</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">right</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">aabb</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">left</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">aabb</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">top</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>     <span class="c1">// Y 轴在屏幕和 NDC 空间可能反向
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">aabb</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="o">-</span><span class="n">bottom</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>get_bounds_for_axis</code> 函数是此方法的核心：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">get_bounds_for_axis</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3s</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="cm">/* Bounding axis (e.g. {1,0,0})</span> <span class="err">*/</span> <span class="p">...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将球心 C 投影到由轴 a 和 z 轴定义的 2D 平面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="n">vec2s</span> <span class="n">c</span><span class="p">{</span><span class="n">glms_vec3_dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">C</span><span class="p">),</span> <span class="n">C</span><span class="p">.</span><span class="n">z</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 与方法一类似的切点计算 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 检查球体是否与近裁剪面相交
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="kt">bool</span> <span class="n">clipSphere</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">nearZ</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ... 计算切点 bounds[i] ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果切点在近平面内侧，并且球体与近平面相交
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">const</span> <span class="kt">bool</span> <span class="n">clipBound</span> <span class="o">=</span> <span class="n">cameraInsideSphere</span> <span class="o">||</span> <span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">nearZ</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">clipSphere</span> <span class="o">&amp;&amp;</span> <span class="n">clipBound</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 用球体与近平面相交的交点替换切点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec2s</span><span class="p">{</span><span class="n">c</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">nearZ</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 将 2D 边界点转换回 3D 摄像机空间 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol>
<li><strong>解耦坐标轴:</strong> 该方法通过 <code>get_bounds_for_axis</code> 函数分别计算水平（X）和垂直（Y）方向的边界，这和方法一的思路相似。</li>
<li><strong>鲁棒的近平面裁剪:</strong> 这是与方法一最大的不同。<code>get_bounds_for_axis</code> 显式地处理了球体与近裁剪面 (<code>nearZ</code>) 的关系。
<ul>
<li>当球体与近平面相交时，其在屏幕上的投影边界可能不再是平滑的切线，而是在近平面上形成的<strong>圆形切面</strong>的边界。</li>
<li>代码中的 <code>if (clipSphere &amp;&amp; clipBound)</code> 逻辑就是在判断是否需要用这个圆形切面的边界点来代替原始的切点，从而得到一个更紧凑、更正确的包围盒。</li>
</ul>
</li>
<li><strong>完整投影:</strong> 计算出的 <code>left</code>, <code>right</code>, <code>top</code>, <code>bottom</code> 是视图空间中的 3D 点，它们通过标准的 <code>project</code> 函数（矩阵乘法后进行透视除法）转换到 NDC，保证了结果的正确性。</li>
</ol>
<p>此方法是三者中最精确的，因为它严格遵循了经过验证的几何算法，但其计算开销也相对更高。</p>
<h3 id="3d-包围盒投影法-最简单近似">
<a class="header-anchor" href="#3d-%e5%8c%85%e5%9b%b4%e7%9b%92%e6%8a%95%e5%bd%b1%e6%b3%95-%e6%9c%80%e7%ae%80%e5%8d%95%e8%bf%91%e4%bc%bc"></a>
3D 包围盒投影法 (最简单，近似)
</h3><p>一种最简单直观，但也是最不精确的方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">use_view_aabb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vec3s</span> <span class="n">aabb_min</span><span class="p">{...},</span> <span class="n">aabb_max</span><span class="p">{...};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 遍历光源包围球的3D AABB的8个顶点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">u32</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">vec3s</span> <span class="n">corner</span><span class="p">{...};</span> <span class="c1">// 计算第c个角点世界坐标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 将角点转换到视图空间，并裁剪到近平面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">vec4s</span> <span class="n">corner_vs</span> <span class="o">=</span> <span class="n">glms_mat4_mulv</span><span class="p">(</span><span class="n">game_camera</span><span class="p">.</span><span class="n">camera</span><span class="p">.</span><span class="n">view</span><span class="p">,</span> <span class="p">...);</span>
</span></span><span class="line"><span class="cl">        <span class="n">corner_vs</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">glm_max</span><span class="p">(</span><span class="n">game_camera</span><span class="p">.</span><span class="n">camera</span><span class="p">.</span><span class="n">near_plane</span><span class="p">,</span> <span class="n">corner_vs</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 将视图空间角点投影到NDC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">vec4s</span> <span class="n">corner_ndc</span> <span class="o">=</span> <span class="n">glms_mat4_mulv</span><span class="p">(</span><span class="n">game_camera</span><span class="p">.</span><span class="n">camera</span><span class="p">.</span><span class="n">projection</span><span class="p">,</span> <span class="n">corner_vs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">corner_ndc</span> <span class="o">=</span> <span class="n">glms_vec4_divs</span><span class="p">(</span><span class="n">corner_ndc</span><span class="p">,</span> <span class="n">corner_ndc</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 4. 在 NDC 空间中更新 AABB 的 min/max
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">aabb_min</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">glm_min</span><span class="p">(</span><span class="n">aabb_min</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">corner_ndc</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ... aabb_min.y, aabb_max.x, aabb_max.y ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 5. 用 min/max 组合成最终 AABB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">aabb</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">aabb_min</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">aabb</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">aabb_max</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol>
<li><strong>近似思想:</strong> 该方法不再去求解复杂的切线，而是做了一个<strong>保守的近似</strong>。它首先为 3D 球体构建一个轴对齐包围盒 (AABB)，然后将这个 3D 包围盒的 8 个顶点全部投影到屏幕上，最后在屏幕空间找到这 8 个投影点的最小/最大坐标，以此作为最终的 2D AABB。</li>
<li><strong>结果的保守性:</strong> 关键在于，<strong>投影一个3D包围盒的顶点所形成的2D包围盒，并不等于对原始3D球体投影后的紧凑2D包围盒</strong>。前者通常会比后者大，尤其当球体靠近屏幕边缘时。</li>
<li><strong>优点与缺点:</strong>
<ul>
<li><strong>优点:</strong> 算法逻辑非常简单，易于理解和实现，且绝对“安全”，因为它产生的包围盒总是能完全包住球体的投影，不会漏掉任何像素。</li>
<li><strong>缺点:</strong> 包围盒不够紧凑（Overestimation），会导致光源影响不必要的 Tile，从而在 GPU 端产生额外的位掩码检查开销，降低剔除效率。</li>
</ul>
</li>
</ol>
<h3 id="总结">
<a class="header-anchor" href="#%e6%80%bb%e7%bb%93"></a>
总结
</h3><p>这三种方法为我们展示了在图形学中常见的工程权衡：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">方法</th>
          <th style="text-align: left">优点</th>
          <th style="text-align: left">缺点</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>默认方法</strong></td>
          <td style="text-align: left">计算高效，代码紧凑</td>
          <td style="text-align: left">对近平面裁剪处理不鲁棒</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>McGuire 方法</strong></td>
          <td style="text-align: left"><strong>最精确</strong>，鲁棒性强</td>
          <td style="text-align: left">计算开销相对最高</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>AABB投影法</strong></td>
          <td style="text-align: left"><strong>最简单</strong>，逻辑清晰</td>
          <td style="text-align: left">近似方法，包围盒<strong>不紧凑</strong></td>
      </tr>
  </tbody>
</table>
<p>选择哪种方法取决于具体的应用场景和性能要求。对于大多数情况，默认方法可能是性能和精度之间的一个很好的平衡点。而对于追求极致剔除精度的场景，McGuire 方法是最佳选择。</p>

      
    </div>
    <footer class="article-footer">
      

      

      

      

      

      

      
      <ul class="article-tag-list" itemprop="keywords">
  
</ul>

    </footer>
  </div>
  
    
  <nav
    id="article-nav"
    data-aos="fade-up"
  >
    
      <div class="article-nav-link-wrap article-nav-link-left">
        
          
          
            <img
              data-src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202412220910052.png"
              data-sizes="auto"
              alt="Real-Time High Quality Rendering"
              class="lazyload"
            />
          
        
        <a href="https://nothingtosay0031.github.io/post/games202/"></a>
        <div class="article-nav-caption">Newer</div>
        <h3 class="article-nav-title">
          
            Real-Time High Quality Rendering
          
        </h3>
      </div>
    

    
      <div class="article-nav-link-wrap article-nav-link-right">
        
          
          
            <img
              data-src="https://raw.githubusercontent.com/NothingToSay0031/Images/main/202412220910052.png"
              data-sizes="auto"
              alt="Sampling on the Unit Hemisphere and Disk"
              class="lazyload"
            />
          
        
        <a href="https://nothingtosay0031.github.io/post/sampling/"></a>
        <div class="article-nav-caption">Older</div>
        <h3 class="article-nav-title">
          
            Sampling on the Unit Hemisphere and Disk
          
        </h3>
      </div>
    
  </nav>


  
</article>










</section>
          
            <aside id="sidebar">
  <div class="sidebar-wrapper wrap-sticky">
    <div
      class="sidebar-wrap"
      data-aos="fade-up"
    >
      
        <div class="sidebar-toc-sidebar">
          <div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#mesh-shadervulkan-中的下一代渲染管线">Mesh Shader：Vulkan 中的下一代渲染管线</a>
      <ul>
        <li><a href="#为什么选择-mesh-shader">为什么选择 Mesh Shader？</a>
          <ul>
            <li><a href="#传统管线的瓶颈">传统管线的瓶颈</a></li>
            <li><a href="#mesh-shader-的解决方案">Mesh Shader 的解决方案</a></li>
          </ul>
        </li>
        <li><a href="#构建-meshlet">构建 Meshlet</a>
          <ul>
            <li><a href="#定义-meshlet-的大小并准备数据">定义 Meshlet 的大小并准备数据</a></li>
            <li><a href="#使用-meshoptimizer-构建-meshlet">使用 <code>meshoptimizer</code> 构建 Meshlet</a></li>
            <li><a href="#数据打包与优化">数据打包与优化</a></li>
            <li><a href="#生成最终的-gpu-meshlet-结构">生成最终的 GPU Meshlet 结构</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#two-pass-culling">Two-Pass Culling</a>
      <ul>
        <li><a href="#整体管线架构">整体管线架构</a></li>
        <li><a href="#剔除并生成draw指令">剔除并生成Draw指令</a>
          <ul>
            <li><a href="#视锥剔除-frustum-culling">视锥剔除 (Frustum Culling)</a></li>
            <li><a href="#遮挡剔除-occlusion-culling">遮挡剔除 (Occlusion Culling)</a>
              <ul>
                <li><a href="#包围球投影与mip层级选择">包围球投影与Mip层级选择</a></li>
                <li><a href="#深度比较">深度比较</a></li>
              </ul>
            </li>
            <li><a href="#原子操作生成绘制列表">原子操作生成绘制列表</a></li>
          </ul>
        </li>
        <li><a href="#task-shader-and-mesh-shader">Task Shader and Mesh Shader</a>
          <ul>
            <li><a href="#task-shader">Task Shader</a>
              <ul>
                <li><a href="#cone-culling">Cone Culling</a></li>
                <li><a href="#subgroup-操作与动态任务分发">Subgroup 操作与动态任务分发</a></li>
              </ul>
            </li>
            <li><a href="#mesh-shader">Mesh Shader</a>
              <ul>
                <li><a href="#并行顶点生成与图元装配">并行顶点生成与图元装配</a></li>
                <li><a href="#primitiveindices">PrimitiveIndices</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#深度金字塔">深度金字塔</a>
          <ul>
            <li><a href="#资源创建与设置">资源创建与设置</a></li>
            <li><a href="#降采样与最大值合并">降采样与最大值合并</a></li>
            <li><a href="#执行与同步">执行与同步</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#improved-culling-for-tiled-and-clustered-rendering">Improved Culling for Tiled and Clustered Rendering</a>
      <ul>
        <li><a href="#分块-tiled-与集群-clustered">分块 (Tiled) 与集群 (Clustered)</a></li>
        <li><a href="#混合动力activision-的改进方案">混合动力：Activision 的改进方案</a>
          <ul>
            <li><a href="#cpu端-light-culling-准备">CPU端 Light Culling 准备</a>
              <ul>
                <li><a href="#构建z轴分箱查找表-z-bin-lut">构建Z轴分箱查找表 (Z-Bin LUT)</a>
                  <ul>
                    <li><a href="#为每个光源计算其覆盖的z-bin范围">为每个光源计算其覆盖的Z-Bin范围</a></li>
                    <li><a href="#为每个z-bin计算其包含的光源索引范围">为每个Z-Bin计算其包含的光源索引范围</a></li>
                  </ul>
                </li>
                <li><a href="#构建屏幕分块位掩码-tile-bitmask">构建屏幕分块位掩码 (Tile Bitmask)</a>
                  <ul>
                    <li><a href="#计算光源在屏幕空间的2d包围盒">计算光源在屏幕空间的2D包围盒</a></li>
                    <li><a href="#将光源信息填充到tile网格中">将光源信息填充到Tile网格中</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#gpu端-光照剔除与计算">GPU端 光照剔除与计算</a>
              <ul>
                <li><a href="#双重过滤获取初步光源列表">双重过滤，获取初步光源列表</a></li>
                <li><a href="#朴素实现">朴素实现</a></li>
                <li><a href="#基于-subgroup-的协同计算">基于 Subgroup 的协同计算</a></li>
                <li><a href="#光照合成与最终着色">光照合成与最终着色</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#附录">附录</a>
          <ul>
            <li><a href="#方法一2d-平面解法">方法一：2D 平面解法</a></li>
            <li><a href="#mcguire-方法-最精确">McGuire 方法 (最精确)</a></li>
            <li><a href="#3d-包围盒投影法-最简单近似">3D 包围盒投影法 (最简单，近似)</a></li>
            <li><a href="#总结">总结</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
        </div>
        <div class="sidebar-common-sidebar hidden">
          
<div class="sidebar-author">
  <img
    data-src="https://nothingtosay0031.github.io/avatar/../avatar.webp"
    data-sizes="auto"
    alt="NothingToSay0031"
    class="lazyload"
  />
  <div class="sidebar-author-name">NothingToSay0031</div>
  <div class="sidebar-description">又是一个做水果蛋糕的好天气啊！</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div>
    
    <div class="sidebar-state-number">24</div>
  </div>
  <div class="sidebar-state-category">
    <div>Categories</div>
    <div class="sidebar-state-number">
      0
    </div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tags</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-email sidebar-social-icon">
      <a
        href="mailto:jhwzju@gmail.com"
        itemprop="url"
        target="_blank"
        aria-label="email"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-github sidebar-social-icon">
      <a
        href="https://github.com/NothingToSay0031"
        itemprop="url"
        target="_blank"
        aria-label="github"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-linkedin sidebar-social-icon">
      <a
        href="https://www.linkedin.com/in/hongweiji"
        itemprop="url"
        target="_blank"
        aria-label="linkedin"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/"
        aria-label="Home"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Home</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/archives"
        aria-label="Archives"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Archives</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/about"
        aria-label="About"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">About</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/friend"
        aria-label="Friend"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Friend</div>
    </div>
  
</div>

        </div>
      

      
        <div class="sidebar-btn-wrapper" style="position:static">
          <div class="sidebar-toc-btn current"></div>
          <div class="sidebar-common-btn"></div>
        </div>
      
    </div>
  </div>

  
</aside>

          
        </main>
        



  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  



<footer id="footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div id="footer-info">
    <div>
      <span class="icon-copyright"></span>
      2021 -
      2025
      <span class="footer-info-sep rotate"></span>
      NothingToSay0031
    </div>
    
      <div>
        Powered by&nbsp;<a
          href="https://gohugo.io/"
          target="_blank"
          >Hugo</a
        >&nbsp; Theme.<a
          href="https://github.com/D-Sketon/hugo-theme-reimu"
          target="_blank"
          >Reimu</a
        >
      </div>
    
    
      <div>
        <span class="icon-brush"
          >&nbsp;
            66.0k
          </span
        >
        &nbsp;|&nbsp;
        <span class="icon-coffee">&nbsp;
          
          

          05:24
        </span>
      </div>
    
    
    
    
      <div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv"
          >Number of visits&nbsp;<span
            id="busuanzi_value_site_pv"
          ></span
        ></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv"
          >Number of visitors&nbsp;<span
            id="busuanzi_value_site_uv"
          ></span
        ></span>
      </div>
    
  </div>
</footer>

        
          <div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div>
        
        <div id="mask" class="hide"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar">
        <div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#mesh-shadervulkan-中的下一代渲染管线">Mesh Shader：Vulkan 中的下一代渲染管线</a>
      <ul>
        <li><a href="#为什么选择-mesh-shader">为什么选择 Mesh Shader？</a>
          <ul>
            <li><a href="#传统管线的瓶颈">传统管线的瓶颈</a></li>
            <li><a href="#mesh-shader-的解决方案">Mesh Shader 的解决方案</a></li>
          </ul>
        </li>
        <li><a href="#构建-meshlet">构建 Meshlet</a>
          <ul>
            <li><a href="#定义-meshlet-的大小并准备数据">定义 Meshlet 的大小并准备数据</a></li>
            <li><a href="#使用-meshoptimizer-构建-meshlet">使用 <code>meshoptimizer</code> 构建 Meshlet</a></li>
            <li><a href="#数据打包与优化">数据打包与优化</a></li>
            <li><a href="#生成最终的-gpu-meshlet-结构">生成最终的 GPU Meshlet 结构</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#two-pass-culling">Two-Pass Culling</a>
      <ul>
        <li><a href="#整体管线架构">整体管线架构</a></li>
        <li><a href="#剔除并生成draw指令">剔除并生成Draw指令</a>
          <ul>
            <li><a href="#视锥剔除-frustum-culling">视锥剔除 (Frustum Culling)</a></li>
            <li><a href="#遮挡剔除-occlusion-culling">遮挡剔除 (Occlusion Culling)</a>
              <ul>
                <li><a href="#包围球投影与mip层级选择">包围球投影与Mip层级选择</a></li>
                <li><a href="#深度比较">深度比较</a></li>
              </ul>
            </li>
            <li><a href="#原子操作生成绘制列表">原子操作生成绘制列表</a></li>
          </ul>
        </li>
        <li><a href="#task-shader-and-mesh-shader">Task Shader and Mesh Shader</a>
          <ul>
            <li><a href="#task-shader">Task Shader</a>
              <ul>
                <li><a href="#cone-culling">Cone Culling</a></li>
                <li><a href="#subgroup-操作与动态任务分发">Subgroup 操作与动态任务分发</a></li>
              </ul>
            </li>
            <li><a href="#mesh-shader">Mesh Shader</a>
              <ul>
                <li><a href="#并行顶点生成与图元装配">并行顶点生成与图元装配</a></li>
                <li><a href="#primitiveindices">PrimitiveIndices</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#深度金字塔">深度金字塔</a>
          <ul>
            <li><a href="#资源创建与设置">资源创建与设置</a></li>
            <li><a href="#降采样与最大值合并">降采样与最大值合并</a></li>
            <li><a href="#执行与同步">执行与同步</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#improved-culling-for-tiled-and-clustered-rendering">Improved Culling for Tiled and Clustered Rendering</a>
      <ul>
        <li><a href="#分块-tiled-与集群-clustered">分块 (Tiled) 与集群 (Clustered)</a></li>
        <li><a href="#混合动力activision-的改进方案">混合动力：Activision 的改进方案</a>
          <ul>
            <li><a href="#cpu端-light-culling-准备">CPU端 Light Culling 准备</a>
              <ul>
                <li><a href="#构建z轴分箱查找表-z-bin-lut">构建Z轴分箱查找表 (Z-Bin LUT)</a>
                  <ul>
                    <li><a href="#为每个光源计算其覆盖的z-bin范围">为每个光源计算其覆盖的Z-Bin范围</a></li>
                    <li><a href="#为每个z-bin计算其包含的光源索引范围">为每个Z-Bin计算其包含的光源索引范围</a></li>
                  </ul>
                </li>
                <li><a href="#构建屏幕分块位掩码-tile-bitmask">构建屏幕分块位掩码 (Tile Bitmask)</a>
                  <ul>
                    <li><a href="#计算光源在屏幕空间的2d包围盒">计算光源在屏幕空间的2D包围盒</a></li>
                    <li><a href="#将光源信息填充到tile网格中">将光源信息填充到Tile网格中</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#gpu端-光照剔除与计算">GPU端 光照剔除与计算</a>
              <ul>
                <li><a href="#双重过滤获取初步光源列表">双重过滤，获取初步光源列表</a></li>
                <li><a href="#朴素实现">朴素实现</a></li>
                <li><a href="#基于-subgroup-的协同计算">基于 Subgroup 的协同计算</a></li>
                <li><a href="#光照合成与最终着色">光照合成与最终着色</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#附录">附录</a>
          <ul>
            <li><a href="#方法一2d-平面解法">方法一：2D 平面解法</a></li>
            <li><a href="#mcguire-方法-最精确">McGuire 方法 (最精确)</a></li>
            <li><a href="#3d-包围盒投影法-最简单近似">3D 包围盒投影法 (最简单，近似)</a></li>
            <li><a href="#总结">总结</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
      </div>
      <div class="sidebar-common-sidebar hidden">
        
<div class="sidebar-author">
  <img
    data-src="https://nothingtosay0031.github.io/avatar/../avatar.webp"
    data-sizes="auto"
    alt="NothingToSay0031"
    class="lazyload"
  />
  <div class="sidebar-author-name">NothingToSay0031</div>
  <div class="sidebar-description">又是一个做水果蛋糕的好天气啊！</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div>
    
    <div class="sidebar-state-number">24</div>
  </div>
  <div class="sidebar-state-category">
    <div>Categories</div>
    <div class="sidebar-state-number">
      0
    </div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tags</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-email sidebar-social-icon">
      <a
        href="mailto:jhwzju@gmail.com"
        itemprop="url"
        target="_blank"
        aria-label="email"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-github sidebar-social-icon">
      <a
        href="https://github.com/NothingToSay0031"
        itemprop="url"
        target="_blank"
        aria-label="github"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-linkedin sidebar-social-icon">
      <a
        href="https://www.linkedin.com/in/hongweiji"
        itemprop="url"
        target="_blank"
        aria-label="linkedin"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/"
        aria-label="Home"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Home</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/archives"
        aria-label="Archives"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Archives</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/about"
        aria-label="About"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">About</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="https://nothingtosay0031.github.io/friend"
        aria-label="Friend"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">Friend</div>
    </div>
  
</div>

      </div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    
    






  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js"
    
    
    
    
    integrity="sha384-3gT/vsepWkfz/ff7PpWNUeMzeWoH3cDhm/A8jM7ouoAK0/fP/9bcHHR5kHq2nf&#43;e" crossorigin="anonymous"
  ></script>




  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js"
    
    
    
    
    integrity="sha384-J08i8An/QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"
  ></script>









  
      
      <script src="https://nothingtosay0031.github.io/js/main.js" integrity="" crossorigin="anonymous" ></script>
      



  





  
      
      <script src="https://nothingtosay0031.github.io/js/aos.js" integrity="" crossorigin="anonymous" ></script>
      

  <script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", aosInit);
    } else {
      aosInit();
    }
  </script>








  
      
      <script src="https://nothingtosay0031.github.io/js/pjax_main.js" integrity="" crossorigin="anonymous" data-pjax></script>
      





  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/mouse-firework@0.0.6/dist/index.umd.js"
    
    
    
    
    integrity="sha384-vkGvf25gm1C1PbcoD5dNfc137HzNL/hr1RKA5HniJOaawtvUmH5lTVFgFAruE9Ge" crossorigin="anonymous"
  ></script>


<script>
  if (window.firework) {
    const options = JSON.parse("{\"excludeelements\":[\"a\",\"button\"],\"particles\":[{\"colors\":[\"#ff5252\",\"#ff7c7c\",\"#ffafaf\",\"#ffd0d0\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"emit\"],\"number\":20,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.3,0.5],\"radius\":[16,32]}},{\"colors\":[\"#ff0000\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"diffuse\"],\"number\":1,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.2,0.5],\"lineWidth\":6,\"radius\":20}}]}");
    options.excludeElements = options.excludeelements;
    delete options.excludeelements;
    window.firework(options);
  }
</script>








<div id="lazy-script">
  <div>
    
    
      





  
      
      <script src="https://nothingtosay0031.github.io/js/insert_highlight.js" integrity="" crossorigin="anonymous" data-pjax></script>
      

      
      
      
      
      <script type="module" data-pjax>
        const PhotoSwipeLightbox = (await safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe-lightbox.esm.min.js", "sha384-DiL6M\/gG\u002bwmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF\/N6lrZi\/")).default;

        const pswp = () => {
          if (_$$('.article-entry a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-entry',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")
            }).init();
          }
          if(_$$('.article-gallery a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-gallery',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")
            }).init();
          }
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script>
      












    
    
      
        

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/katex@0.16.9/dist/katex.min.js"
    
    
    data-pjax
    
    integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8" crossorigin="anonymous"
  ></script>


        

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/katex@0.16.9/dist/contrib/auto-render.min.js"
    
    
    data-pjax
    
    integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05" crossorigin="anonymous"
  ></script>


        <script data-pjax>
          var renderMath = () => {
            if (!window.renderMathInElement) return;
            window.renderMathInElement(document.body, {
              delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "\\[", right: "\\]", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
              ],
            });
          };
          if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", renderMath, { once: true });
          } else {
            renderMath();
          }
        </script>
      
      
    
  </div>
</div>




  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js"
    
    async
    
    
    integrity="sha384-0M75wtSkhjIInv4coYlaJU83&#43;OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id&#43;S" crossorigin="anonymous"
  ></script>





  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then((registrations) => {
        for (let registration of registrations) {
          registration.unregister();
        }
      });
    }
  </script>


<script>
  const reimuCopyright = String.raw`
   ______     ______     __     __    __     __  __    
  /\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
  \ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
   \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
    \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                    
  `;
  console.log(String.raw`%c ${reimuCopyright}`, "color: #ff5252;");
  console.log(
    "%c Theme.Reimu" + " %c https://github.com/D-Sketon/hugo-theme-reimu ",
    "color: white; background: #ff5252; padding:5px 0;",
    "padding:4px;border:1px solid #ff5252;",
  );
</script>

  </body>
</html>
