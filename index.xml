<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>NothingToSay0031</title>
    <link>https://nothingtosay0031.github.io/</link>
    <description>Recent content on NothingToSay0031</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 29 Jul 2025 12:14:45 +0000</lastBuildDate>
    <atom:link href="https://nothingtosay0031.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>五种禁用Early-ZS与HSR的常见模式</title>
      <link>https://nothingtosay0031.github.io/post/earlyzs/</link>
      <pubDate>Tue, 29 Jul 2025 12:14:45 +0000</pubDate>
      <guid>https://nothingtosay0031.github.io/post/earlyzs/</guid>
      <description>&lt;h1 id=&#34;五种禁用gpu早期优化early-zs--hsr的常见模式&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e4%ba%94%e7%a7%8d%e7%a6%81%e7%94%a8gpu%e6%97%a9%e6%9c%9f%e4%bc%98%e5%8c%96early-zs--hsr%e7%9a%84%e5%b8%b8%e8%a7%81%e6%a8%a1%e5%bc%8f&#34;&gt;&lt;/a&gt;&#xD;&#xA;五种禁用GPU早期优化（Early-ZS &amp;amp; HSR）的常见模式&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;对于游戏开发者和图形程序员而言，充分压榨GPU的每一分性能是永恒的追求。在现代GPU渲染管线中，&lt;strong&gt;Early-Z&lt;/strong&gt;（早期深度测试）和 &lt;strong&gt;HSR&lt;/strong&gt;（Hidden Surface Removal，隐藏面消除）是两大“免费”的性能提升利器。它们能够在片元着色器（Fragment Shader）执行前，就剔除掉那些最终不可见的像素，从而节省大量的计算和带宽资源。&lt;/p&gt;&#xA;&lt;p&gt;然而，一些看似无害的着色器操作，却可能在不经意间“关闭”这些强大的优化，导致GPU做了大量无用功，帧率大跌。本文将剖析五种常见的、可能禁用Early-ZS和HSR的操作，帮助你识别并规避这些性能陷阱。&lt;/p&gt;&#xA;&lt;h2 id=&#34;什么是early-zs和hsr为何如此重要&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afearly-zs%e5%92%8chsr%e4%b8%ba%e4%bd%95%e5%a6%82%e6%ad%a4%e9%87%8d%e8%a6%81&#34;&gt;&lt;/a&gt;&#xD;&#xA;什么是Early-ZS和HSR？为何如此重要？&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;在深入探讨问题之前，我们先快速回顾一下这两个核心概念：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Early-ZS (Early Z/Stencil Test)&lt;/strong&gt;：传统的深度和模板测试（Late-ZS）发生在片元着色器之后。而Early-ZS则是一种优化，它将深度/模板测试提前到片元着色器之前。如果一个片元（像素）在深度测试中被遮挡（例如，它在一面墙的后面），GPU就会直接抛弃它，不再为其执行昂贵的着色器代码。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;HSR (Hidden Surface Removal)&lt;/strong&gt;：这是现代移动GPU（尤其是基于Tile-Based Deferred Rendering, TBDR架构的，如Arm Mali系列）的一项关键技术。HSR能够在光栅化阶段，高效地分析一个渲染区块（Tile）内的所有图元，只保留最顶层的、最终可见的片元送入渲染管线，从源头上就避免了大量被遮挡像素的产生。这比Early-Z更为高效，因为它在更早的阶段就完成了隐藏面消除。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;简而言之，Early-ZS和HSR的目标都是同一个：让片元着色器只为最终显示在屏幕上的像素工作。一旦它们被禁用，GPU就不得不回到“先计算，再判断”的低效模式，造成严重的性能浪费，即所谓的“Overdraw”（过度绘制）。&lt;/p&gt;&#xA;&lt;h2 id=&#34;early-zs和hsr的杀手&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#early-zs%e5%92%8chsr%e7%9a%84%e6%9d%80%e6%89%8b&#34;&gt;&lt;/a&gt;&#xD;&#xA;Early-ZS和HSR的“杀手”&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;现在，让我们来看看是哪些操作会成为这些优化的“杀手”。&lt;/p&gt;&#xA;&lt;h3 id=&#34;在着色器中使用discard语句&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e5%9c%a8%e7%9d%80%e8%89%b2%e5%99%a8%e4%b8%ad%e4%bd%bf%e7%94%a8discard%e8%af%ad%e5%8f%a5&#34;&gt;&lt;/a&gt;&#xD;&#xA;在着色器中使用&lt;code&gt;discard&lt;/code&gt;语句&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;discard&lt;/code&gt;（在HLSL中是&lt;code&gt;clip()&lt;/code&gt;) 允许着色器动态地抛弃当前片元。这在实现一些特殊效果，如镂空材质时非常有用。但它的代价是巨大的。&lt;/p&gt;&#xA;&lt;p&gt;影响：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;强制Late-ZS Update，可能禁用Early-ZS Test&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;通常会禁用HSR&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;原因剖析： GPU的Early-ZS单元需要在一个片元进入着色器之前，就“确定”它是否会被写入深度缓冲。但当着色器中存在&lt;code&gt;discard&lt;/code&gt;时，这个决定变得不确定——只有执行完着色器代码，GPU才知道这个片元是否被抛弃。&lt;/p&gt;&#xA;&lt;p&gt;为了保证渲染结果的正确性，GPU必须采取保守策略：先执行片元着色器，然后再根据其结果（是否被discard）来决定是否更新深度/模板缓冲。这就强制了Late-ZS Update（晚期深度更新）。&lt;/p&gt;&#xA;&lt;p&gt;虽然在某些架构上，如果深度写入被关闭，Early-ZS &lt;em&gt;Test&lt;/em&gt; 可能仍然可以剔除一部分片元。但更重要的是，对于依赖确定性来消除隐藏面的HSR来说，&lt;code&gt;discard&lt;/code&gt;带来的不确定性是致命的，通常会导致HSR被完全禁用。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：一些操作只禁用Early-ZS &lt;em&gt;Update&lt;/em&gt;，但仍然可以从Early-ZS &lt;em&gt;Test&lt;/em&gt; 中受益。这意味着GPU可以先进行一次早期深度测试来剔除部分片元，但对于通过测试的片元，其深度值的最终写入仍需等待着色器执行完毕。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;在着色器中写入gl_fragdepth&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e5%9c%a8%e7%9d%80%e8%89%b2%e5%99%a8%e4%b8%ad%e5%86%99%e5%85%a5gl_fragdepth&#34;&gt;&lt;/a&gt;&#xD;&#xA;在着色器中写入&lt;code&gt;gl_FragDepth&lt;/code&gt;&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;手动修改片元的深度值（在GLSL中是&lt;code&gt;gl_FragDepth&lt;/code&gt;，HLSL中是&lt;code&gt;SV_Depth&lt;/code&gt;）是实现某些高级渲染技巧（如深度偏移、自定义深度剔除）的手段。然而，这也是一个经典的性能陷阱。&lt;/p&gt;&#xA;&lt;p&gt;影响：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;强制Late-ZS Test and Update&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;禁用HSR&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;原因剖析： 这个原因非常直观。Early-ZS测试依赖的是光栅化后、进入着色器前的那个原始深度值。如果你在着色器内部修改了它，那么早期的测试结果就是无效的、错误的。&lt;/p&gt;&#xA;&lt;p&gt;因此，一旦GPU检测到着色器会写入深度值，它就必须完全禁用Early-ZS，等待着色器执行完毕，拿到最终的&lt;code&gt;gl_FragDepth&lt;/code&gt;值后，才能进行深度测试和更新（Late-ZS）。HSR同样因为无法在着色器执行前确定最终深度而被禁用。&lt;/p&gt;&#xA;&lt;h3 id=&#34;在着色器中读取深度模板缓冲&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e5%9c%a8%e7%9d%80%e8%89%b2%e5%99%a8%e4%b8%ad%e8%af%bb%e5%8f%96%e6%b7%b1%e5%ba%a6%e6%a8%a1%e6%9d%bf%e7%bc%93%e5%86%b2&#34;&gt;&lt;/a&gt;&#xD;&#xA;在着色器中读取深度/模板缓冲&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;在某些后处理或高级效果中，我们可能需要读取当前像素位置已经存在的深度或模板值。&lt;/p&gt;&#xA;&lt;p&gt;影响：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;强制Late-ZS Update&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;禁用HSR&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;原因剖析： 现代GPU为了追求高并行度，片元着色器的执行顺序是不确定的。假设片元A和片元B覆盖同一个像素，A在前，B在后。如果B的着色器需要读取深度缓冲，它必须确保A（以及所有在A之前的、覆盖同一像素的片元）已经完成了深度写入。&lt;/p&gt;</description>
    </item>
    <item>
      <title>GPU Architecture Evolution</title>
      <link>https://nothingtosay0031.github.io/post/gpu/</link>
      <pubDate>Tue, 03 Jun 2025 19:25:47 +0000</pubDate>
      <guid>https://nothingtosay0031.github.io/post/gpu/</guid>
      <description>&lt;h1 id=&#34;gpu-架构演进&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#gpu-%e6%9e%b6%e6%9e%84%e6%bc%94%e8%bf%9b&#34;&gt;&lt;/a&gt;&#xD;&#xA;GPU 架构演进&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/403345668&#34;&gt;Reference&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;从固定管线到-tesla-统一着色器&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e4%bb%8e%e5%9b%ba%e5%ae%9a%e7%ae%a1%e7%ba%bf%e5%88%b0-tesla-%e7%bb%9f%e4%b8%80%e7%9d%80%e8%89%b2%e5%99%a8&#34;&gt;&lt;/a&gt;&#xD;&#xA;从固定管线到 Tesla 统一着色器&#xD;&#xA;&lt;/h1&gt;&lt;h2 id=&#34;gpu-概念的诞生与早期发展&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#gpu-%e6%a6%82%e5%bf%b5%e7%9a%84%e8%af%9e%e7%94%9f%e4%b8%8e%e6%97%a9%e6%9c%9f%e5%8f%91%e5%b1%95&#34;&gt;&lt;/a&gt;&#xD;&#xA;GPU 概念的诞生与早期发展&#xD;&#xA;&lt;/h2&gt;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;GPU 名称的由来&lt;/strong&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1999年，NVIDIA 发布 GeForce 256 (代号 NV10)，首次将其搭载的芯片称为 GPU (Graphics Processing Unit)，意图与 CPU 平起平坐。&lt;/li&gt;&#xA;&lt;li&gt;在此之前，显卡通常被称为“图形加速器”或“显卡”。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;GeForce 256 的关键特性&lt;/strong&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将坐标变换、灯光照明、三角形设置/裁剪以及一个每秒能处理一千万个多边形的渲染引擎集成到单一芯片上。&lt;/li&gt;&#xA;&lt;li&gt;核心能力：对大量数据执行相同操作 (SIMD)，这是并行计算的基础。&lt;/li&gt;&#xA;&lt;li&gt;局限性：仍属于&lt;strong&gt;固定管线 (fixed-pipeline)&lt;/strong&gt; 架构，处理的数据操作是内置的，更像是特定算法的加速器。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;走向可编程性的-gpu-时代&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e8%b5%b0%e5%90%91%e5%8f%af%e7%bc%96%e7%a8%8b%e6%80%a7%e7%9a%84-gpu-%e6%97%b6%e4%bb%a3&#34;&gt;&lt;/a&gt;&#xD;&#xA;走向可编程性的 GPU 时代&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;为了克服固定管线的局限性，GPU 开始朝着可编程性发展：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;GeForce 3 (2001年, NVIDIA)&lt;/strong&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;引入了&lt;strong&gt;顶点着色器 (Vertex Shader)&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;拥有可配置的片元管线。&lt;/li&gt;&#xA;&lt;li&gt;进入 DirectX 8 时代。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Radeon 9700 (2002年, ATI)&lt;/strong&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;支持24位可编程的&lt;strong&gt;片元着色器 (Fragment Shader/Pixel Shader)&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;全面拥抱 DirectX 9。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;GeForce FX (2003年, NVIDIA)&lt;/strong&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;支持32位可编程片元着色器。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这一时期的核心主题是：&lt;strong&gt;GPU 可编程性的不断提高&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Unreal Engine 与着色器卡顿：PSO 预缓存解决方案</title>
      <link>https://nothingtosay0031.github.io/post/ue_pso/</link>
      <pubDate>Wed, 28 May 2025 12:16:31 +0800</pubDate>
      <guid>https://nothingtosay0031.github.io/post/ue_pso/</guid>
      <description>&lt;h1 id=&#34;unreal-engine-与着色器卡顿pso-预缓存解决方案&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#unreal-engine-%e4%b8%8e%e7%9d%80%e8%89%b2%e5%99%a8%e5%8d%a1%e9%a1%bfpso-%e9%a2%84%e7%bc%93%e5%ad%98%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88&#34;&gt;&lt;/a&gt;&#xD;&#xA;Unreal Engine 与着色器卡顿：PSO 预缓存解决方案&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://www.unrealengine.com/en-US/tech-blog/game-engines-and-shader-stuttering-unreal-engines-solution-to-the-problem&#34;&gt;Game engines and shader stuttering: Unreal Engine&amp;rsquo;s solution to the problem&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;核心问题着色器编译卡顿-shader-compilation-stuttering&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e6%a0%b8%e5%bf%83%e9%97%ae%e9%a2%98%e7%9d%80%e8%89%b2%e5%99%a8%e7%bc%96%e8%af%91%e5%8d%a1%e9%a1%bf-shader-compilation-stuttering&#34;&gt;&lt;/a&gt;&#xD;&#xA;核心问题：着色器编译卡顿 (Shader Compilation Stuttering)&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;当渲染引擎在绘制物体前发现需要一个新的着色器（Shader）但该着色器尚未编译时，会暂停所有操作等待驱动程序完成编译，导致画面卡顿。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;背景知识着色器与编译过程&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e8%83%8c%e6%99%af%e7%9f%a5%e8%af%86%e7%9d%80%e8%89%b2%e5%99%a8%e4%b8%8e%e7%bc%96%e8%af%91%e8%bf%87%e7%a8%8b&#34;&gt;&lt;/a&gt;&#xD;&#xA;背景知识：着色器与编译过程&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;着色器 (Shaders)&lt;/strong&gt;：在 GPU 上执行的小程序，用于渲染 3D 图像的各个步骤（如变换、光照、后处理等）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;编译流程&lt;/strong&gt;：&#xA;&lt;ol&gt;&#xA;&lt;li&gt;高级语言 (如 HLSL) -&amp;gt; 编译器 -&amp;gt; GPU 可执行的机器码。&lt;/li&gt;&#xA;&lt;li&gt;与 CPU 不同，GPU 型号繁多，指令集各异，甚至同厂商不同代产品指令集也可能不同。&lt;/li&gt;&#xA;&lt;li&gt;因此，游戏不直接分发 GPU 机器码，而是将高级着色器代码编译成&lt;strong&gt;中间表示 (Intermediate Representation) 或字节码 (Bytecode)&lt;/strong&gt; (如 Direct3D 11 的 DXBC, Direct3D 12 的 DXIL, Vulkan 的 SPIR-V)。&lt;/li&gt;&#xA;&lt;li&gt;游戏运行时，GPU &lt;strong&gt;驱动程序&lt;/strong&gt;会将字节码翻译成当前 GPU 可执行的机器码。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;早期问题&lt;/strong&gt;：起初游戏着色器简单量少，字节码到机器码的转换成本可忽略。随着 GPU 发展，着色器变多变复杂，驱动优化也更复杂，导致运行时编译成本显著增加，成为卡顿元凶。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;现代-api-的尝试管线状态对象-pipeline-state-objects---psos&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e7%8e%b0%e4%bb%a3-api-%e7%9a%84%e5%b0%9d%e8%af%95%e7%ae%a1%e7%ba%bf%e7%8a%b6%e6%80%81%e5%af%b9%e8%b1%a1-pipeline-state-objects---psos&#34;&gt;&lt;/a&gt;&#xD;&#xA;现代 API 的尝试：管线状态对象 (Pipeline State Objects - PSOs)&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;PSO 定义&lt;/strong&gt;：渲染一个物体通常涉及多个着色器（如顶点着色器和像素着色器）以及大量 GPU 设置（如剔除模式、混合模式、深度模板测试模式等）。PSO 将这些配置打包成一个单元。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;与旧 API 的区别&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;旧 API (如 Direct3D 11, OpenGL) 允许单独、任意时间修改状态，驱动只有在发出绘制指令时才能看到完整配置，此时才可能开始编译着色器，导致卡顿。&lt;/li&gt;&#xA;&lt;li&gt;现代 API (如 Direct3D 12, Vulkan) 要求开发者将所有着色器和设置打包进 PSO，并一次性设置。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;PSO 的优势&lt;/strong&gt;：理论上，引擎可以在加载等较早阶段创建所有需要的 PSO，让编译有足够时间在渲染前完成。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;理论与实践的挑战-unreal-engine-的情况&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e7%90%86%e8%ae%ba%e4%b8%8e%e5%ae%9e%e8%b7%b5%e7%9a%84%e6%8c%91%e6%88%98-unreal-engine-%e7%9a%84%e6%83%85%e5%86%b5&#34;&gt;&lt;/a&gt;&#xD;&#xA;理论与实践的挑战 (Unreal Engine 的情况)&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;材质系统的复杂性&lt;/strong&gt;：UE 强大的材质系统允许艺术家创建丰富的视觉效果，一个材质可能产生多种着色器变体（如静态网格、蒙皮网格、样条网格使用不同顶点着色器），再乘以不同的管线状态组合，可能导致&lt;strong&gt;数百万种不同的 PSO&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;全部预编译不可行&lt;/strong&gt;：预编译所有可能的 PSO 在时间和内存上都不可行（加载关卡可能耗费数小时）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;实际使用子集&lt;/strong&gt;：运行时实际用到的 PSO 只是一个小小子集，但仅通过分析材质无法确定该子集，且子集会因游戏会话（如更改画质设置）而变化。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;早期 D3D12 引擎的解决方法&lt;/strong&gt;：通过游戏测试、自动关卡漫游等方式记录遇到的 PSO，形成“&lt;strong&gt;捆绑 PSO 缓存 (Bundled PSO Cache)&lt;/strong&gt;”，在游戏启动或关卡加载时创建。这是 UE 5.2 版本之前的推荐做法。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;捆绑缓存的局限性&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;收集过程资源密集，内容更新时需保持同步。&lt;/li&gt;&#xA;&lt;li&gt;对于动态世界（如物体材质根据玩家行为改变）可能无法发现所有 PSO。&lt;/li&gt;&#xA;&lt;li&gt;如果会话间差异大（如多地图、多皮肤选择），缓存会变得过大。&lt;/li&gt;&#xA;&lt;li&gt;不适用于用户生成内容 (UGC)，因为需要为每个体验单独收集缓存。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;unreal-engine-的-pso-预缓存-pso-precaching-ue-52-及以后版本&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#unreal-engine-%e7%9a%84-pso-%e9%a2%84%e7%bc%93%e5%ad%98-pso-precaching-ue-52-%e5%8f%8a%e4%bb%a5%e5%90%8e%e7%89%88%e6%9c%ac&#34;&gt;&lt;/a&gt;&#xD;&#xA;Unreal Engine 的 PSO 预缓存 (PSO Precaching) (UE 5.2 及以后版本)&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;核心思想&lt;/strong&gt;：在加载时确定&lt;strong&gt;潜在的 PSO&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;工作方式&lt;/strong&gt;：&#xA;&lt;ol&gt;&#xA;&lt;li&gt;当对象（如模型、材质）加载时，系统检查其材质，并结合网格信息（静态 vs. 动画）和全局状态（如视频质量设置）来计算一个&lt;strong&gt;可能用于渲染该对象的 PSO 子集&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;这个子集仍比实际使用的多，但远小于所有可能性，使得在加载期间编译它们变得可行。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;示例&lt;/strong&gt;：《堡垒之夜》大逃杀模式一场比赛编译约 30,000 个 PSO，实际使用约 10,000 个，而总组合空间有数百万个。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;地图加载时创建的对象在加载屏幕显示时预缓存其 PSO。&lt;/li&gt;&#xA;&lt;li&gt;游戏过程中流式加载或生成的对象，可以等待其 PSO 就绪后再渲染，或使用一个已编译的默认材质（通常只延迟几帧，不明显）。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;效果&lt;/strong&gt;：已为材质消除了 PSO 编译卡顿，并能与用户生成内容无缝协作。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;pso-预缓存的当前挑战与未来工作&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#pso-%e9%a2%84%e7%bc%93%e5%ad%98%e7%9a%84%e5%bd%93%e5%89%8d%e6%8c%91%e6%88%98%e4%b8%8e%e6%9c%aa%e6%9d%a5%e5%b7%a5%e4%bd%9c&#34;&gt;&lt;/a&gt;&#xD;&#xA;PSO 预缓存的当前挑战与未来工作&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;已显示网格更换材质&lt;/strong&gt;：不希望隐藏或用默认材质渲染，正在开发 API 允许游戏代码提前提示，以便额外预缓存 PSO，并考虑在编译新材质时继续渲染旧材质。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;全局着色器 (Global Shaders)&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;与材质无关，用于渲染算法和效果（如动态模糊、升采样、降噪）。&lt;/li&gt;&#xA;&lt;li&gt;预缓存机制已覆盖全局&lt;strong&gt;计算 (compute)&lt;/strong&gt; 着色器，但截至 UE 5.5（文章发布时）尚未完全处理全局&lt;strong&gt;图形 (graphics)&lt;/strong&gt; 着色器。这些 PSO 仍可能导致首次使用时罕见的单次卡顿。正在努力弥补这一覆盖空白。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;捆绑缓存与预缓存结合&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可将一些通用材质包含在捆绑缓存中，在启动时编译，而非游戏过程中。&lt;/li&gt;&#xA;&lt;li&gt;有助于全局图形着色器，因为发现过程会记录它们。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;驱动程序缓存-driver-cache&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e9%a9%b1%e5%8a%a8%e7%a8%8b%e5%ba%8f%e7%bc%93%e5%ad%98-driver-cache&#34;&gt;&lt;/a&gt;&#xD;&#xA;驱动程序缓存 (Driver Cache)&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：驱动程序会将编译好的 PSO 保存到磁盘，在后续游戏会话中再次遇到时可直接加载。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;UE 的利用方式 (预缓存 Precaching)&lt;/strong&gt;：&#xA;&lt;ol&gt;&#xA;&lt;li&gt;UE 在加载时创建 PSO，并在它们完成编译后立即丢弃（确保它们已进入驱动缓存）。&lt;/li&gt;&#xA;&lt;li&gt;之后渲染需要该 PSO 时，引擎发出编译请求，驱动直接从其缓存中返回。&lt;/li&gt;&#xA;&lt;li&gt;一旦 PSO 用于绘制，会保持加载直到所有使用它的图元被移除。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;优缺点&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：不使用的 PSO 不会保留在内存中。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：在需要时从驱动缓存中获取 PSO 仍可能花费一些时间（远快于编译），可能导致材质首次渲染时的微小卡顿 (micro-stutters)。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;优化方向&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;保留预缓存的 PSO 而不是丢弃，但这会增加内存使用（可能超过 1GB），只适用于内存充足的机器。正在研究减少内存影响和自动决定何时保留预缓存 PSO 的方案。&lt;/li&gt;&#xA;&lt;li&gt;UE 利用一些实践知识在预缓存过程中跳过某些冗余的 PSO 排列（因为某些管线状态变化不影响最终可执行代码），以减少加载时间和内存使用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;移动平台和主机平台&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e7%a7%bb%e5%8a%a8%e5%b9%b3%e5%8f%b0%e5%92%8c%e4%b8%bb%e6%9c%ba%e5%b9%b3%e5%8f%b0&#34;&gt;&lt;/a&gt;&#xD;&#xA;移动平台和主机平台&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;移动平台&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同样使用设备端着色器编译模型，UE 的预缓存系统也有效。&lt;/li&gt;&#xA;&lt;li&gt;通常着色器比桌面端少，但 CPU 较慢导致 PSO 编译时间更长。&lt;/li&gt;&#xA;&lt;li&gt;调整：跳过一些不常用的排列（可能导致在渲染这些罕见状态时出现卡顿）；地图加载时预缓存有超时限制，以防加载屏幕过长（可能导致游戏开始时仍有编译任务，若立即需要则会卡顿，使用优先级提升系统尽量缓解）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;主机平台&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;不存在此问题&lt;/strong&gt;。主机只有单一目标 GPU，着色器直接编译成可执行代码随游戏分发。&lt;/li&gt;&#xA;&lt;li&gt;顶点着色器与多像素着色器组合或管线状态变化不会导致重编译。&lt;/li&gt;&#xA;&lt;li&gt;运行时组装 PSO 成本不高，因此没有 PSO 卡顿。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;关于-directx-11-怀旧论&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e5%85%b3%e4%ba%8e-directx-11-%e6%80%80%e6%97%a7%e8%ae%ba&#34;&gt;&lt;/a&gt;&#xD;&#xA;关于 &amp;ldquo;DirectX 11 怀旧论&amp;rdquo;&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;误解&lt;/strong&gt;：认为 D3D11 没有这些问题是片面的。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;事实&lt;/strong&gt;：D3D11 时代也有卡顿，且由于 API 设计，引擎无法阻止。卡顿较少或较短主要是因为当时游戏和着色器更简单，且某些特性（如光线追踪）不存在。&lt;/li&gt;&#xA;&lt;li&gt;D3D12 引入 PSO 是为了在问题恶化前提早解决，但引擎需要时间来有效利用它们。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;尚未完成的工作与开发者建议&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e5%b0%9a%e6%9c%aa%e5%ae%8c%e6%88%90%e7%9a%84%e5%b7%a5%e4%bd%9c%e4%b8%8e%e5%bc%80%e5%8f%91%e8%80%85%e5%bb%ba%e8%ae%ae&#34;&gt;&lt;/a&gt;&#xD;&#xA;尚未完成的工作与开发者建议&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;持续改进&lt;/strong&gt;：预缓存系统自 UE 5.2 实验性引入以来已大幅改进，但仍有覆盖缺口和局限性，正在持续优化。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;最终目标&lt;/strong&gt;：自动且最优地处理预缓存，使开发者无需额外操作即可避免卡顿。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;开发者建议 (在系统完善前)&lt;/strong&gt;：&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;使用最新引擎版本&lt;/strong&gt;：新版本通常有更好的预缓存行为。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;分析游戏中的 PSO 卡顿&lt;/strong&gt;：使用 &lt;code&gt;r.PSOPrecache.Validation=2&lt;/code&gt; 等工具识别 PSO 缺失或过迟，并理解原因。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;游戏测试前清除驱动缓存&lt;/strong&gt;：使用命令行参数 &lt;code&gt;-clearPSODriverCache&lt;/code&gt; 来模拟玩家首次运行游戏或更新驱动后的体验，关注此模式下的卡顿。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;定期重复此过程&lt;/strong&gt;：内容或代码更改可能引入新的卡顿。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;留意其他类型的卡顿&lt;/strong&gt;：PSO 编译不是唯一原因。定期分析游戏，追踪其他可能导致帧时间尖峰的高成本进程（如同步加载、过多生成、移动触发的场景捕获等）。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Realtime Ray Tracing with Vulkan</title>
      <link>https://nothingtosay0031.github.io/post/vulkanrtx/</link>
      <pubDate>Sun, 25 May 2025 15:11:48 +0000</pubDate>
      <guid>https://nothingtosay0031.github.io/post/vulkanrtx/</guid>
      <description>&lt;h1 id=&#34;dynamic-diffuse-global-illumination-ddgi&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#dynamic-diffuse-global-illumination-ddgi&#34;&gt;&lt;/a&gt;&#xD;&#xA;Dynamic Diffuse Global Illumination (DDGI)&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;动态漫反射全局光照（&lt;a href=&#34;https://www.jcgt.org/published/0008/02/01/paper-lowres.pdf&#34;&gt;DDGI&lt;/a&gt;）是一种用于实时渲染中模拟间接光照的强大技术。其核心思想是在场景中布置一个规则的探针网格（Probe Grid），并预计算每个探针接收到的来自周围环境的光照。&lt;/p&gt;&#xA;&lt;h2 id=&#34;工作流程&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b&#34;&gt;&lt;/a&gt;&#xD;&#xA;工作流程&#xD;&#xA;&lt;/h2&gt;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;辐射度采集 (Gather Radiance)&lt;/strong&gt;: 从每个探针位置向周围发射光线，采集光照信息。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;辐照度更新 (Update Irradiance)&lt;/strong&gt;: 使用采集到的光照信息更新探针的辐照度数据。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;可见性更新 (Update Visibility)&lt;/strong&gt;: 更新探针的可见性数据，用于后续的阴影计算。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;（可选）探针偏移更新 (Probe Offset Update)&lt;/strong&gt;: 根据光线追踪的距离调整每个探针的位置偏移，以更好地适应场景几何体。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;间接光照计算 (Indirect Lighting Calculation)&lt;/strong&gt;: 使用更新后的辐照度和可见性数据计算场景的间接光照。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;辐射度采集-gather-radiance&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e8%be%90%e5%b0%84%e5%ba%a6%e9%87%87%e9%9b%86-gather-radiance&#34;&gt;&lt;/a&gt;&#xD;&#xA;辐射度采集 (Gather Radiance)&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;此阶段的目标是为场景中的每个光照探针（Light Probe）计算其从各个方向接收到的入射光（Radiance）和对应的光线传播距离。这本质上是一个大规模的光线追踪过程，我们从每个探针的位置向半球或全球领域发射大量光线，记录它们击中场景后的光照信息。&lt;/p&gt;&#xA;&lt;p&gt;最终的输出是一张二维纹理 &lt;code&gt;probe_raytrace_radiance_texture&lt;/code&gt;，其尺寸为 &lt;code&gt;[num_rays, num_probes]&lt;/code&gt;。纹理中的每一个像素 &lt;code&gt;(x, y)&lt;/code&gt; 存储了第 &lt;code&gt;y&lt;/code&gt; 个探针沿第 &lt;code&gt;x&lt;/code&gt; 个方向发射的光线所采集到的辐射度（RGB）和距离（A）。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NothingToSay0031/Images/main/202507201311937.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;数据流与gpu调度&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e6%b5%81%e4%b8%8egpu%e8%b0%83%e5%ba%a6&#34;&gt;&lt;/a&gt;&#xD;&#xA;数据流与GPU调度&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;在CPU端，我们通过一个光线追踪指令来启动整个GPU计算过程。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 准备工作：确保目标纹理处于可写入状态&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;gpu_commands&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;issue_texture_barrier&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;probe_raytrace_radiance_texture&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                    &lt;span class=&#34;n&#34;&gt;RESOURCE_STATE_UNORDERED_ACCESS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 绑定光线追踪管线和所需的资源&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;gpu_commands&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bind_pipeline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;probe_raytrace_pipeline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;gpu_commands&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bind_descriptor_set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;probe_raytrace_descriptor_set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;nullptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 确定需要更新的探针数量&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u32&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;probe_count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;offsets_calculations_count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_total_probes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;per_frame_probe_updates&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 发射光线：为每个探针（probe_count）发射指定数量（probe_rays）的光线&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;gpu_commands&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;trace_rays&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;probe_raytrace_pipeline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;probe_rays&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;probe_count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 计算完成后，再次设置屏障，以便后续阶段可以读取该纹理&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;gpu_commands&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;issue_texture_barrier&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;probe_raytrace_radiance_texture&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RESOURCE_STATE_UNORDERED_ACCESS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;trace_rays&lt;/code&gt; 函数是核心。它在GPU上启动一个 &lt;code&gt;probe_rays * probe_count&lt;/code&gt; 的二维计算网格。GPU上的每个工作单元（线程）将负责处理一个探针的一条光线。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Temporal Anti-Aliasing稳定性探究</title>
      <link>https://nothingtosay0031.github.io/post/taa/</link>
      <pubDate>Fri, 16 May 2025 11:16:31 +0800</pubDate>
      <guid>https://nothingtosay0031.github.io/post/taa/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#introduction&#34;&gt;&lt;/a&gt;&#xD;&#xA;Introduction&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;最近在浏览知乎时，我注意到一篇关于“&lt;a href=&#34;https://www.zhihu.com/question/56388267/answer/2279081584&#34;&gt;Temporal AA 如何避免远处细小几何体闪烁？&lt;/a&gt;”的高质量讨论。其中一则答案分析得相当透彻，我认为有记录和分享的价值，因此整理如下：&lt;/p&gt;&#xA;&lt;p&gt;时间抗锯齿（Temporal Anti-Aliasing, TAA）无疑是现代图形渲染中一项革命性的技术。它以极小的性能代价，带来了显著的图像质量提升，有效解决了传统空间抗锯齿难以处理的锯齿和像素闪烁问题。然而，正如许多开发者在实践中遇到的那样，TAA并非完美无瑕。一个常见且棘手的痛点，便是远处或细小几何体（如电线、栏杆、稀疏的植被叶片等）在TAA下产生的恼人闪烁或“抖动”现象。&lt;/p&gt;&#xA;&lt;p&gt;这种闪烁，直观上看，似乎是由于TAA核心机制中的投影矩阵抖动 (projection matrix jitter) 导致的。在抖动作用下，那些在屏幕空间中尺寸小于一个像素的微小三角形，其光栅化结果可能在相邻的几个像素之间来回跳变，从而引发视觉上的不稳定性。但问题真的仅仅如此吗？&lt;/p&gt;&#xA;&lt;p&gt;事实上，这背后揭示了TAA在信息处理层面更为深刻的挑战：如何在历史帧的有效信息（可用于超采样以提升细节和抗锯齿）与无效信息（可能导致鬼影或错误的混合）之间做出准确的判断。尤其对于高频细节和细小几何体，这种判断变得异常困难。激进地剔除历史样本可能会加剧闪烁，而保守地混合又可能引入鬼影。&lt;/p&gt;&#xA;&lt;h1 id=&#34;核心问题&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e6%a0%b8%e5%bf%83%e9%97%ae%e9%a2%98&#34;&gt;&lt;/a&gt;&#xD;&#xA;核心问题&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;Temporal AA (TAA) 在处理远处细小几何体（如线状物）时，由于投影矩阵的抖动 (jitter)，导致这些不足一个像素的三角形在光栅化时，其覆盖的像素在相邻帧之间来回跳变，从而产生闪烁现象。&lt;/p&gt;&#xA;&lt;h1 id=&#34;根本原因false-positive-与-false-negative-的不兼容&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e6%a0%b9%e6%9c%ac%e5%8e%9f%e5%9b%a0false-positive-%e4%b8%8e-false-negative-%e7%9a%84%e4%b8%8d%e5%85%bc%e5%ae%b9&#34;&gt;&lt;/a&gt;&#xD;&#xA;根本原因：False Positive 与 False Negative 的不兼容&#xD;&#xA;&lt;/h1&gt;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;TAA 的目标与挑战：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;目标：&lt;/strong&gt; 通过混合历史帧和当前帧的信息，实现时间上的超采样，达到抗锯齿效果。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;挑战：&lt;/strong&gt; 如何区分历史帧的像素是有效的（可以用于超采样），还是无效的（例如因为物体移动、遮挡变化、光照变化导致的“鬼影”）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Ghosting (鬼影) 的处理与代价：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;去鬼影 (De-ghosting)：&lt;/strong&gt; 为了避免鬼影，TAA 通常会有一套机制来判断历史样本的有效性。如果一个历史样本被判定为无效（比如与当前帧差异过大），就会被拒绝 (reject) 或限制其贡献 (clip/clamp)。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;激进的拒绝/限制：&lt;/strong&gt; 如果去鬼影的策略过于激进（例如，Neighboring Clamp/Clip 范围过小，或对深度/速度差异容忍度低），虽然能有效去除大部分鬼影，但会带来新问题。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;激进拒绝带来的问题（闪烁的直接原因）：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;拒绝后的处理：&lt;/strong&gt; 当历史样本被拒绝后，当前像素如果完全依赖当前帧的原始信息 (raw pixel)，而这个原始信息又因为相机抖动而在几个像素间跳动，那么这个像素就会表现为闪烁或不稳定。这正是题目中描述的细小几何体闪烁的原因。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Neighboring Clamp/Clip 的副作用：&lt;/strong&gt; 作者特别指出，题目中提到的闪烁，&amp;ldquo;Neighboring Clamp/Clip 就是罪魁祸首&amp;rdquo;。这种方法试图将历史样本的颜色限制在当前帧邻近像素的颜色范围内。对于高频细节（如细线），其颜色可能与周围像素差异很大。如果 Clamp 的范围 (AABB) 很小，历史样本很容易被过度修正或拒绝，导致细节丢失和闪烁。Clamp 范围越小，闪烁可能越厉害。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;高频细节的困境：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;抗锯齿需求：&lt;/strong&gt; 对于几何边缘等高频细节，TAA 正是需要通过混合历史样本来实现抗锯齿（超采样）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;难以区分：&lt;/strong&gt; 系统很难判断一个像素的剧烈颜色变化，究竟是因为它本身就处于高频变化的区域（例如细线的边缘，抖动使其采样到了线的内部和外部），还是因为历史样本确实失效了（例如物体移动了）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;当前机制的假设：&lt;/strong&gt; 无论是 Neighboring Clip 还是基于深度/速度差异的拒绝策略，往往都倾向于假设历史样本失效（即后者）。这对于几何边缘来说是个问题，因为边缘处的深度差异本身就可能很大，即便物体没有移动，只是相机抖动。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;解决思路思想实验&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e8%a7%a3%e5%86%b3%e6%80%9d%e8%b7%af%e6%80%9d%e6%83%b3%e5%ae%9e%e9%aa%8c&#34;&gt;&lt;/a&gt;&#xD;&#xA;解决思路（思想实验）&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;作者强调这些是未经实际验证的思考，并分为静态和动态情况讨论。&lt;/p&gt;</description>
    </item>
    <item>
      <title>NVIDIA RTXPT: Code Walkthrough</title>
      <link>https://nothingtosay0031.github.io/post/rtxpt/</link>
      <pubDate>Fri, 09 May 2025 20:25:47 -0700</pubDate>
      <guid>https://nothingtosay0031.github.io/post/rtxpt/</guid>
      <description>&lt;p&gt;这篇博客主要探讨了 NVIDIA 开源的 &lt;a href=&#34;https://github.com/NVIDIA-RTX/RTXPT&#34;&gt;RTX Path Tracing (RTXPT)&lt;/a&gt; 项目。路径追踪的基础知识我是在 TU Wien 的 Rendering 课程上学习的，当时也写了一篇&lt;a href=&#34;https://nothingtosay0031.github.io/post/mis_nee/&#34;&gt;关于 MIS 和 NEE 的博客&lt;/a&gt;，但一直没有真正编写过完整的 Path Tracing 代码，对 NEE 和 BSDF 在 MIS 中的正确计算也只是略知一二。最近看到这个项目，觉得是个很好的学习机会，正好可以深入理解这些概念。虽然这个库还实现了许多实时路径追踪的优化算法，但本篇主要聚焦于 MIS 和 NEE 的实现过程。&lt;/p&gt;&#xA;&lt;h1 id=&#34;raygen-shader&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#raygen-shader&#34;&gt;&lt;/a&gt;&#xD;&#xA;&lt;code&gt;RayGen&lt;/code&gt; Shader&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;我们来开始解析 NVIDIA RTXPT 代码中的 &lt;code&gt;Sample.hlsl&lt;/code&gt; 文件，并从 &lt;code&gt;RayGen&lt;/code&gt; (光线生成) 着色器入手。这部分是路径追踪的起点，负责为每个像素生成初始光线并驱动整个追踪过程。&lt;/p&gt;&#xA;&lt;p&gt;在 DirectX Raytracing (DXR) 中，&lt;code&gt;RayGen&lt;/code&gt; 着色器是光线追踪管线的入口点。对于屏幕上的每一个像素（或者说，每一个调度），&lt;code&gt;RayGen&lt;/code&gt; 着色器都会被执行一次。它的主要任务是：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;初始化&lt;/strong&gt;：设置当前像素的追踪环境和状态。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;生成主光线&lt;/strong&gt; (Primary Ray)：根据相机参数计算从视点出发，穿过当前像素的光线。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;驱动光线追踪&lt;/strong&gt;：调用光线追踪的核心逻辑，模拟光线在场景中的传播、碰撞和着色。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;收集结果&lt;/strong&gt;：将最终计算得到的颜色写入输出纹理。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;现在，让我们深入 &lt;code&gt;Sample.hlsl&lt;/code&gt; 中的 &lt;code&gt;RayGen&lt;/code&gt; 函数：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-hlsl&#34; data-lang=&#34;hlsl&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shader&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;raygeneration&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RayGen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 1. 获取当前像素坐标&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;uint2&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pixelPos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DispatchRaysIndex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 2. 初始化工作上下文 (WorkingContext)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;PathTracer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WorkingContext&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;workingContext&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getWorkingContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pixelPos&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 根据不同的路径追踪模式进行初始化&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#if PATH_TRACER_MODE!=PATH_TRACER_MODE_REFERENCE&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 对于非参考模式，启动稳定平面相关的路径追踪过程&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;workingContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stablePlanes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;StartPathTracingPass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#endif&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#if PATH_TRACER_MODE!=PATH_TRACER_MODE_FILL_STABLE_PLANES&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 对于非填充稳定平面模式，重置调试信息&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;workingContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;debug&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Reset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mo&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#endif&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 子采样索引，这里固定为0，注释表明是为了降噪引导缓冲区的稳定性&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;uint&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;subSampleIndex&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mo&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// PathState 用于存储和管理一条光路的所有状态信息&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;PathState&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 3. 初始化路径状态并设置主光线&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;//    - EmptyPathInitialize: 初始化路径的基本状态 (如像素ID，相机像素锥角等)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;//    - computeCameraRay: 根据像素位置计算相机光线&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;//    - SetupPathPrimaryRay: 将计算出的相机光线设置到path状态中&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PathTracer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EmptyPathInitialize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pixelPos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g_Const&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptConsts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;camera&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PixelConeSpreadAngle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;PathTracer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SetupPathPrimaryRay&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Bridge&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;computeCameraRay&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pixelPos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/*subSampleIndex*/&lt;/span&gt;&lt;span class=&#34;mo&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 4. 【可选】根据稳定平面模式处理首次命中&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#if PATH_TRACER_MODE==PATH_TRACER_MODE_FILL_STABLE_PLANES&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 如果是 PATH_TRACER_MODE_FILL_STABLE_PLANES 模式，&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 光线的首次命中信息会从预计算的“基础稳定平面”(base stable plane, index 0)加载，&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 而不是实际追踪主光线。这是一种优化手段，可以复用之前计算的结果。&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;firstHitFromBasePlane&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mo&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;workingContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// lastOrigin = path.origin; // 记录光线起点，这里被注释掉了&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#endif&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 初始化用于构建稳定平面的次表面位置法线信息 (如果处于该模式)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#if PATH_TRACER_MODE_BUILD_STABLE_PLANES==1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;u_SecondarySurfacePositionNormal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pixelPos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mo&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#endif&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 5. 主路径追踪循环&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;//    只要光线路径仍然有效 (isActive)，就继续调用 nextHit 进行下一次弹射处理&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isActive&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;nextHit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;workingContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// false 参数表示不跳过稳定平面探索&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 6. 数据清理：处理 NaN 或 无穷大值&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;//    防止计算过程中出现非法数值导致最终结果异常&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;SanitizeNaNs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;workingContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 7. 【可选】根据稳定平面模式提交降噪器相关的光照信息&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#if PATH_TRACER_MODE==PATH_TRACER_MODE_FILL_STABLE_PLANES&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;workingContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stablePlanes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CommitDenoiserRadiance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getStablePlaneIndex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;denoiserSampleHitTFromPlane&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;denoiserDiffRadianceHitDist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;denoiserSpecRadianceHitDist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;secondaryL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hasFlag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PathFlags&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stablePlaneBaseScatterDiff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hasFlag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PathFlags&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stablePlaneOnDeltaBranch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hasFlag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PathFlags&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stablePlaneOnDominantBranch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#endif    &lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 8. 根据不同的路径追踪模式，计算最终的路径光照贡献&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;float3&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pathRadiance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#if PATH_TRACER_MODE==PATH_TRACER_MODE_REFERENCE&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 参考模式：直接使用路径累计的光照 (path.L)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;pathRadiance&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#elif PATH_TRACER_MODE==PATH_TRACER_MODE_BUILD_STABLE_PLANES&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 构建稳定平面模式：完成稳定平面的构建过程，并返回相应光照&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;pathRadiance&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;workingContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stablePlanes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CompletePathTracingBuild&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#elif PATH_TRACER_MODE==PATH_TRACER_MODE_FILL_STABLE_PLANES&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 填充稳定平面模式：使用稳定平面数据完成光照计算&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;pathRadiance&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;workingContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stablePlanes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CompletePathTracingFill&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;g_Const&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptConsts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;denoisingEnabled&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#endif&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 调试相关的可视化功能 (如果启用)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#if PATH_TRACER_MODE==PATH_TRACER_MODE_BUILD_STABLE_PLANES &amp;amp;&amp;amp; ENABLE_DEBUG_DELTA_TREE_VIZUALISATION&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;DeltaTreeVizExplorePixel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;workingContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mo&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 调试可视化时可能直接返回&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#endif&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 9. 输出最终颜色&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#if PATH_TRACER_MODE!=PATH_TRACER_MODE_BUILD_STABLE_PLANES&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 如果不是构建稳定平面模式，则将计算得到的 pathRadiance 写入输出纹理 u_Output&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// alpha 设置为 1 对截图很重要&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;u_Output&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pixelPos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pathRadiance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#endif&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 下面是一些调试打印的示例代码，已被注释&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// ...&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;主要逻辑梳理：&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Ultimate Guide to Profiling Unity Games</title>
      <link>https://nothingtosay0031.github.io/post/profilingunity/</link>
      <pubDate>Sun, 04 May 2025 09:59:50 -0700</pubDate>
      <guid>https://nothingtosay0031.github.io/post/profilingunity/</guid>
      <description>&lt;h1 id=&#34;unity-游戏性能优化&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#unity-%e6%b8%b8%e6%88%8f%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96&#34;&gt;&lt;/a&gt;&#xD;&#xA;Unity 游戏性能优化&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://unity.com/resources/ultimate-guide-to-profiling-unity-games&#34;&gt;Ultimate Guide to Profiling Unity Games&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;核心目标&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e6%a0%b8%e5%bf%83%e7%9b%ae%e6%a0%87&#34;&gt;&lt;/a&gt;&#xD;&#xA;核心目标&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;流畅性能&lt;/strong&gt;是创造沉浸式游戏体验的基础。&lt;/li&gt;&#xA;&lt;li&gt;通过对游戏进行&lt;strong&gt;性能分析和优化&lt;/strong&gt;，适配更广泛的平台和设备，从而扩大玩家基础，提高成功机会。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;指南内容&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e6%8c%87%e5%8d%97%e5%86%85%e5%ae%b9&#34;&gt;&lt;/a&gt;&#xD;&#xA;指南内容&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;提供关于如何在 Unity 中进行应用&lt;strong&gt;性能分析&lt;/strong&gt;、&lt;strong&gt;内存管理&lt;/strong&gt;和&lt;strong&gt;功耗优化&lt;/strong&gt;的高级建议。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;性能分析工作流程-profiling-workflow&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b-profiling-workflow&#34;&gt;&lt;/a&gt;&#xD;&#xA;性能分析工作流程 (Profiling Workflow)&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;建立一个持续、端到端的性能分析工作流程对于高效游戏开发至关重要。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;关键三步：&lt;/strong&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;重大变更前分析 (Profile before changes):&lt;/strong&gt; 建立性能基准。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;开发过程中分析 (Profile during development):&lt;/strong&gt; 跟踪变更，确保不破坏性能或超出预算。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;变更后分析 (Profile after changes):&lt;/strong&gt; 验证变更是否达到预期效果。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;优化的益处&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e4%bc%98%e5%8c%96%e7%9a%84%e7%9b%8a%e5%a4%84&#34;&gt;&lt;/a&gt;&#xD;&#xA;优化的益处&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;精简、高效的代码&lt;/strong&gt;和&lt;strong&gt;优化的内存使用&lt;/strong&gt;能提升低端和高端设备的性能表现。&lt;/li&gt;&#xA;&lt;li&gt;关注&lt;strong&gt;散热控制 (Thermal control)&lt;/strong&gt; 有助于节省移动设备的宝贵电量。&lt;/li&gt;&#xA;&lt;li&gt;整体良好的性能可以提升&lt;strong&gt;玩家的舒适度&lt;/strong&gt;，从而可能带来更高的&lt;strong&gt;用户接纳度 (Adoption)&lt;/strong&gt; 和&lt;strong&gt;用户留存率 (Retention)&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;profiling-101&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#profiling-101&#34;&gt;&lt;/a&gt;&#xD;&#xA;Profiling 101&#xD;&#xA;&lt;/h1&gt;&lt;h2 id=&#34;什么是-profiler-性能分析器&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af-profiler-%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e5%99%a8&#34;&gt;&lt;/a&gt;&#xD;&#xA;什么是 Profiler (性能分析器)&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;是开发者工具箱中极其有用的工具，用于识别代码中的&lt;strong&gt;内存和性能瓶颈&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;如同侦探工具，帮助揭示应用性能滞后或内存分配过多的根本原因。&lt;/li&gt;&#xA;&lt;li&gt;有助于理解 Unity 引擎的底层运行机制。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;unity-的-profiling-工具&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#unity-%e7%9a%84-profiling-%e5%b7%a5%e5%85%b7&#34;&gt;&lt;/a&gt;&#xD;&#xA;Unity 的 Profiling 工具&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;Unity 自带多种分析工具，可在编辑器内使用或连接到硬件设备。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;主要工具包括：&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Unity Profiler:&lt;/strong&gt; 测量编辑器、播放模式下或连接到设备的应用性能。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Profiling Core package:&lt;/strong&gt; 提供 API，可向 Profiler 捕获的数据添加上下文信息。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Memory Profiler:&lt;/strong&gt; 提供深入的内存性能分析。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Profile Analyzer:&lt;/strong&gt; 用于比较两个性能分析数据集，评估代码更改对性能的影响。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;em&gt;建议同时使用目标平台的原生分析工具 (如 Arm, Apple, PlayStation, Xbox)。&lt;/em&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;性能分析方法-sample-based-vs-instrumentation&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e6%96%b9%e6%b3%95-sample-based-vs-instrumentation&#34;&gt;&lt;/a&gt;&#xD;&#xA;性能分析方法 (Sample-based vs. Instrumentation)&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;两种常见方法：&lt;/strong&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;基于采样 (Sample-based):&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定期探测调用堆栈，收集统计数据。&lt;/li&gt;&#xA;&lt;li&gt;通过提高采样频率来提高准确性，但这会增加开销。可能漏掉短时间的函数调用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;基于插桩 (Instrumentation-based):&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在代码中添加&lt;strong&gt;标记 (Profiler markers)&lt;/strong&gt;，记录每个标记内代码执行的详细计时信息。&lt;/li&gt;&#xA;&lt;li&gt;捕获每个标记的开始和结束事件，不会丢失信息，但依赖于标记的放置。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Unity Profiler 是基于插桩的。&lt;/strong&gt; 它通过标记大部分 Unity API 接口和重要的脚本消息调用（如 &lt;code&gt;Start()&lt;/code&gt;, &lt;code&gt;Update()&lt;/code&gt;），在细节和开销之间取得了良好平衡。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;基于插桩的-profiling-细节-unity&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e5%9f%ba%e4%ba%8e%e6%8f%92%e6%a1%a9%e7%9a%84-profiling-%e7%bb%86%e8%8a%82-unity&#34;&gt;&lt;/a&gt;&#xD;&#xA;基于插桩的 Profiling 细节 (Unity)&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;默认情况下，像 &lt;code&gt;Start()&lt;/code&gt;, &lt;code&gt;Update()&lt;/code&gt; 等 MonoBehaviour 方法会被插桩标记。&lt;/li&gt;&#xA;&lt;li&gt;当你的脚本调用已插桩的 Unity API 时（如 &lt;code&gt;Camera.main&lt;/code&gt; 会产生 &lt;code&gt;FindMainCamera&lt;/code&gt; 标记），也能在 Profiler 中看到。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;深度分析 (Deep Profiling):&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;自动为&lt;em&gt;所有&lt;/em&gt;脚本方法调用（包括 C# 属性的 Getter/Setter）插入标记。&lt;/li&gt;&#xA;&lt;li&gt;提供最全面的脚本分析细节，但会带来显著开销，可能影响报告的计时数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;手动添加 Profiler Markers:&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在关键函数中手动插入 &lt;code&gt;Profiler Marker&lt;/code&gt; 是一种有效的方式，可以在不承受深度分析全部开销的情况下，提高分析的详细程度。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;profiler-模块-profiler-modules&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#profiler-%e6%a8%a1%e5%9d%97-profiler-modules&#34;&gt;&lt;/a&gt;&#xD;&#xA;Profiler 模块 (Profiler Modules)&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;Profiler 按帧捕获性能指标。&lt;/li&gt;&#xA;&lt;li&gt;包含多个&lt;strong&gt;模块&lt;/strong&gt;（如 CPU 使用率、GPU、渲染、内存、物理等），用于深入分析特定性能领域。&lt;/li&gt;&#xA;&lt;li&gt;Profiler 窗口下方会显示当前选中模块捕获的详细信息（如 CPU 使用率模块的时间线或层级视图）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;重要实践建议-important-best-practice&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e9%87%8d%e8%a6%81%e5%ae%9e%e8%b7%b5%e5%bb%ba%e8%ae%ae-important-best-practice&#34;&gt;&lt;/a&gt;&#xD;&#xA;重要实践建议 (Important Best Practice)&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;注意：&lt;/strong&gt; 在编辑器中进行性能分析与在独立构建版本中分析，结果会有很大差异。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;强烈推荐：&lt;/strong&gt; 将 Profiler 连接到&lt;strong&gt;在目标硬件上运行的独立构建版本 (Standalone Build)&lt;/strong&gt; 进行分析。这样可以避免编辑器自身的开销，获得最准确的性能数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;性能分析工作流程&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b&#34;&gt;&lt;/a&gt;&#xD;&#xA;性能分析工作流程&#xD;&#xA;&lt;/h1&gt;&lt;h2 id=&#34;设定帧预算-set-a-frame-budget&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e8%ae%be%e5%ae%9a%e5%b8%a7%e9%a2%84%e7%ae%97-set-a-frame-budget&#34;&gt;&lt;/a&gt;&#xD;&#xA;设定帧预算 (Set a Frame Budget)&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;核心理念:&lt;/strong&gt; 不能仅看重平均帧率 (FPS)，应为每一帧设定一个明确的&lt;strong&gt;时间预算 (Frame Time Budget)&lt;/strong&gt;，单位为毫秒 (ms)。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;计算方法:&lt;/strong&gt; 帧时间预算 = 1000ms / 目标 FPS。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;目标 30 FPS → 每帧预算 33.33 ms&lt;/li&gt;&#xA;&lt;li&gt;目标 60 FPS → 每帧预算 16.66 ms&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;重要性:&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;提供清晰的优化目标，有助于创造更流畅、更一致的玩家体验。&lt;/li&gt;&#xA;&lt;li&gt;避免因单帧耗时过长（即使平均 FPS 达标）导致的&lt;strong&gt;卡顿 (stutter/hitch)&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;游戏进行中&lt;strong&gt;绝不能&lt;/strong&gt;超出预算，非交互部分（如菜单、加载）允许例外。&lt;/li&gt;&#xA;&lt;li&gt;对 VR 游戏尤其关键，稳定的高帧率可避免玩家不适，是平台认证的要求。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;fps-vs-帧时间-frame-time-一个易误导的指标&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#fps-vs-%e5%b8%a7%e6%97%b6%e9%97%b4-frame-time-%e4%b8%80%e4%b8%aa%e6%98%93%e8%af%af%e5%af%bc%e7%9a%84%e6%8c%87%e6%a0%87&#34;&gt;&lt;/a&gt;&#xD;&#xA;FPS vs. 帧时间 (Frame Time): 一个易误导的指标&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;常见误区:&lt;/strong&gt; 玩家常用 FPS 衡量性能，但对开发者而言，它有欺骗性。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;推荐指标:&lt;/strong&gt; 使用&lt;strong&gt;帧时间 (Frame Time, ms)&lt;/strong&gt; 进行性能基准测试和优化。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;原因:&lt;/strong&gt; FPS 的变化与实际耗时的变化不成线性关系。同样是增加 1.11ms 的耗时，可能导致 FPS 从 900 降到 450（看似腰斩），或者从 60 降到 56.25（看似小降）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;实践建议:&lt;/strong&gt; 关注点应是&lt;strong&gt;让帧时间稳定在预算内&lt;/strong&gt;，而不是盲目追求高 FPS（除非已低于目标帧率）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;移动端挑战散热控制与电池寿命&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e7%a7%bb%e5%8a%a8%e7%ab%af%e6%8c%91%e6%88%98%e6%95%a3%e7%83%ad%e6%8e%a7%e5%88%b6%e4%b8%8e%e7%94%b5%e6%b1%a0%e5%af%bf%e5%91%bd&#34;&gt;&lt;/a&gt;&#xD;&#xA;移动端挑战：散热控制与电池寿命&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;散热控制 (Thermal Control):&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;是移动平台优化的&lt;strong&gt;最重要领域之一&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;低效代码导致 CPU/GPU 持续高负载 → 芯片过热 → 操作系统&lt;strong&gt;降频 (Thermal Throttling)&lt;/strong&gt; 以免损坏硬件 → 性能下降、卡顿、用户体验差。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;电池寿命 (Battery Lifetime):&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;高帧率和高计算量（包括内存访问）会&lt;strong&gt;加速电池消耗&lt;/strong&gt;并产生更多&lt;strong&gt;热量&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;性能不佳可能导致无法覆盖低端设备，错失市场机会。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;应对策略:&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将散热视为系统级预算问题。&lt;/li&gt;&#xA;&lt;li&gt;尽早进行性能分析，从项目开始就进行优化。&lt;/li&gt;&#xA;&lt;li&gt;调整项目设置以适应目标硬件。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;调整移动端帧预算&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e8%b0%83%e6%95%b4%e7%a7%bb%e5%8a%a8%e7%ab%af%e5%b8%a7%e9%a2%84%e7%ae%97&#34;&gt;&lt;/a&gt;&#xD;&#xA;调整移动端帧预算&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;推荐做法:&lt;/strong&gt; 为应对长时间游戏产生的热量和电池消耗，建议在帧预算内预留约 &lt;strong&gt;35% 的空闲时间&lt;/strong&gt;。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;这让芯片有时间冷却，减少过度耗电。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;计算示例:&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;目标 30 FPS (预算 33.33ms): 实际执行时间目标 ≈ 33.33ms * (1 - 0.35) ≈ &lt;strong&gt;21.66ms&lt;/strong&gt; (通常取 &lt;strong&gt;22ms&lt;/strong&gt;)。&lt;/li&gt;&#xA;&lt;li&gt;目标 60 FPS (预算 16.66ms): 实际执行时间目标 ≈ 16.66ms * 0.65 ≈ &lt;strong&gt;10.83ms&lt;/strong&gt; (这在多数移动设备上难以稳定实现，且耗电量约是 30 FPS 的两倍)。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;普遍选择:&lt;/strong&gt; 基于以上原因，&lt;strong&gt;大多数移动游戏选择 30 FPS 作为目标&lt;/strong&gt;。可通过 &lt;code&gt;Application.targetFrameRate&lt;/code&gt; 设置。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;动态调频 (Frequency Scaling):&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;移动芯片会根据负载动态调整工作频率，这使得在 Profiler 中直接看帧时间判断优化效果变得复杂。优化可能导致频率降低（设备运行更凉爽），而不是帧时间显著缩短。&lt;/li&gt;&#xA;&lt;li&gt;建议使用 FTrace、Perfetto 等&lt;strong&gt;原生工具&lt;/strong&gt;监控移动芯片的频率、空闲时间和温度变化。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;优化成功的标准:&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在&lt;strong&gt;稳定达到目标帧率&lt;/strong&gt;（如 30 FPS）的前提下，观察到设备&lt;strong&gt;工作负载降低&lt;/strong&gt;（如芯片频率降低或温度下降）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;环境因素:&lt;/strong&gt; 预留一部分帧预算也有助于应对现实世界中&lt;strong&gt;环境温度升高&lt;/strong&gt;（如炎热天气）对设备散热能力的影响。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;减少内存访问操作-reduce-memory-access-operations&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e5%87%8f%e5%b0%91%e5%86%85%e5%ad%98%e8%ae%bf%e9%97%ae%e6%93%8d%e4%bd%9c-reduce-memory-access-operations&#34;&gt;&lt;/a&gt;&#xD;&#xA;减少内存访问操作 (Reduce Memory Access Operations)&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;核心原因:&lt;/strong&gt; DRAM（内存）访问在移动设备上是&lt;strong&gt;高耗电&lt;/strong&gt;操作（Arm 举例 LPDDR4 约 100 皮焦耳/字节）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;降低内存访问的方法:&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;降低目标帧率。&lt;/li&gt;&#xA;&lt;li&gt;在可能的情况下降低显示分辨率。&lt;/li&gt;&#xA;&lt;li&gt;使用更简单的网格模型（减少顶点数量、降低顶点属性精度）。&lt;/li&gt;&#xA;&lt;li&gt;使用纹理压缩和 Mipmapping 技术。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;相关工具:&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于 Arm 或 Arm Mali 硬件，可使用 &lt;strong&gt;Arm Mobile Studio&lt;/strong&gt;（特别是 &lt;strong&gt;Streamline Performance Analyzer&lt;/strong&gt;）工具，通过其提供的性能计数器来识别内存带宽问题（例如由 Overdraw 引起的带宽饱和）。&lt;em&gt;(注意：GPU 分析需 Arm Mali 硬件)&lt;/em&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;性能分析方法从高层到低层-from-high--to-low-level-profiling&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e6%96%b9%e6%b3%95%e4%bb%8e%e9%ab%98%e5%b1%82%e5%88%b0%e4%bd%8e%e5%b1%82-from-high--to-low-level-profiling&#34;&gt;&lt;/a&gt;&#xD;&#xA;性能分析方法：从高层到低层 (From High- to Low-Level Profiling)&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;推荐流程:&lt;/strong&gt; 采用&lt;strong&gt;自顶向下 (Top-to-bottom)&lt;/strong&gt; 的方法。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;第一步 (高层分析):&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在&lt;strong&gt;禁用深度分析 (Deep Profiling disabled)&lt;/strong&gt; 的情况下开始。&lt;/li&gt;&#xA;&lt;li&gt;收集数据，记录在核心游戏循环中导致&lt;strong&gt;不必要托管内存分配 (GC.Alloc markers)&lt;/strong&gt; 或 &lt;strong&gt;CPU 耗时过高&lt;/strong&gt;的场景。&lt;/li&gt;&#xA;&lt;li&gt;收集 &lt;code&gt;GC.Alloc&lt;/code&gt; 标记的调用堆栈信息。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;第二步 (低层分析 - 如有必要):&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果高层分析的调用堆栈不够详细，无法追踪分配或性能下降的源头，则进行第二次性能分析，此时&lt;strong&gt;启用深度分析 (Deep Profiling enabled)&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;记录要点:&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;记录耗时高的“罪魁祸首”时，要关注其&lt;strong&gt;相对于帧内其他部分的耗时比例&lt;/strong&gt;。因为启用深度分析会增加整体开销，影响绝对耗时数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;尽早并经常分析-profile-early-and-often&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e5%b0%bd%e6%97%a9%e5%b9%b6%e7%bb%8f%e5%b8%b8%e5%88%86%e6%9e%90-profile-early-and-often&#34;&gt;&lt;/a&gt;&#xD;&#xA;尽早并经常分析 (Profile Early and Often)&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;核心建议:&lt;/strong&gt; 在项目开发的&lt;strong&gt;早期&lt;/strong&gt;就开始性能分析，并&lt;strong&gt;经常进行&lt;/strong&gt;，这样能获得最大的优化收益。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;益处:&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;帮助团队理解并记住项目的“性能特征 (performance signature)”。&lt;/li&gt;&#xA;&lt;li&gt;当性能突然下降时，能更容易发现问题发生的时间点并进行修复。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;获取最准确结果:&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;始终在&lt;strong&gt;目标设备&lt;/strong&gt;上运行构建版本 (Build) 进行分析。&lt;/li&gt;&#xA;&lt;li&gt;结合使用&lt;strong&gt;平台特定的分析工具&lt;/strong&gt;来深入了解各平台的硬件特性。&lt;/li&gt;&#xA;&lt;li&gt;这种结合能提供跨所有目标设备的&lt;strong&gt;整体性能视图 (holistic view)&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;建立硬件分层基准-establish-hardware-tiers-for-benchmarking&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e5%bb%ba%e7%ab%8b%e7%a1%ac%e4%bb%b6%e5%88%86%e5%b1%82%e5%9f%ba%e5%87%86-establish-hardware-tiers-for-benchmarking&#34;&gt;&lt;/a&gt;&#xD;&#xA;建立硬件分层基准 (Establish Hardware Tiers for Benchmarking)&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;目的:&lt;/strong&gt; 确保游戏在所有目标硬件上都能良好运行。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;做法:&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为你希望支持的每个平台和质量等级，确定&lt;strong&gt;硬件分层 (tiers)&lt;/strong&gt; 或指定一个&lt;strong&gt;最低规格设备 (lowest-spec device)&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;针对&lt;strong&gt;每个层级的最低规格设备&lt;/strong&gt;进行性能分析和优化。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;示例:&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;移动平台：可能设定高、中、低三个层级，通过质量设置开关功能。优化时需确保每个层级的最低规格设备达标。&lt;/li&gt;&#xA;&lt;li&gt;主机平台：若同时为 PlayStation 4 和 PlayStation 5 开发，则必须在&lt;strong&gt;两个平台&lt;/strong&gt;上都进行性能分析。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;查找瓶颈-find-the-bottlenecks-cpu-限制-vs-gpu-限制&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e6%9f%a5%e6%89%be%e7%93%b6%e9%a2%88-find-the-bottlenecks-cpu-%e9%99%90%e5%88%b6-vs-gpu-%e9%99%90%e5%88%b6&#34;&gt;&lt;/a&gt;&#xD;&#xA;查找瓶颈 (Find the Bottlenecks): CPU 限制 vs. GPU 限制&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;目标:&lt;/strong&gt; 判断应用程序的性能瓶颈在于 &lt;strong&gt;CPU (CPU-bound)&lt;/strong&gt; 还是 &lt;strong&gt;GPU (GPU-bound)&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;识别方法:&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;平台工具:&lt;/strong&gt; 某些平台（如 Xcode for iOS）可以直接显示 CPU 和 GPU 的耗时对比图。&lt;em&gt;(注意：移动设备上显示的 CPU 时间通常包含等待 VSync 的时间)&lt;/em&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Unity Profiler:&lt;/strong&gt; 即使某些平台难以获取 GPU 计时数据，Unity Profiler 也提供了足够的信息来定位瓶颈。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用 &lt;strong&gt;CPU Usage 模块&lt;/strong&gt; 的 &lt;strong&gt;Timeline 视图&lt;/strong&gt;可以查看 CPU 的完整活动，包括&lt;strong&gt;等待 GPU (WaitForGPU 或类似标记)&lt;/strong&gt; 的时间。&lt;/li&gt;&#xA;&lt;li&gt;熟悉常见的 &lt;strong&gt;Profiler markers&lt;/strong&gt; (标记名称可能因平台而异)，通过在各目标平台上抓取性能数据来了解项目的“正常”表现。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;VSync (垂直同步) 解释:&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将应用的帧率与显示器的刷新率同步。&lt;/li&gt;&#xA;&lt;li&gt;作用：防止画面撕裂 (screen tearing)，减轻 GPU 负担。&lt;/li&gt;&#xA;&lt;li&gt;影响：如果游戏运行速度快于刷新率对应的时间（如 60Hz -&amp;gt; 16.66ms），会被强制等待，表现为恒定帧率。&lt;/li&gt;&#xA;&lt;li&gt;可在 Unity 的&lt;strong&gt;质量设置 (Quality Settings)&lt;/strong&gt; 中配置 VSync Count。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;瓶颈判断与优化策略:&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;瓶颈定义:&lt;/strong&gt; 性能受限于&lt;strong&gt;耗时最长&lt;/strong&gt;的那个部分（CPU 线程或 GPU）。优化应&lt;strong&gt;聚焦于瓶颈&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;示例场景分析 (假设目标 30fps ≈ 33.3ms, VSync 开启):&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPU 25ms, GPU 20ms: &lt;strong&gt;CPU 限制&lt;/strong&gt;，但均在预算内。优化任何一方不会提高帧率至 30fps 以上（除非两者都降到 16.66ms 以下才能跳到 60fps）。&lt;/li&gt;&#xA;&lt;li&gt;CPU 40ms, GPU 20ms: &lt;strong&gt;CPU 限制&lt;/strong&gt;，超出预算。&lt;strong&gt;需优化 CPU&lt;/strong&gt;。优化 GPU 无益；甚至可以考虑将部分 CPU 工作转移到 GPU (如使用 Compute Shaders) 来平衡负载。&lt;/li&gt;&#xA;&lt;li&gt;CPU 20ms, GPU 40ms: &lt;strong&gt;GPU 限制&lt;/strong&gt;，超出预算。&lt;strong&gt;需优化 GPU&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;CPU 40ms, GPU 40ms: &lt;strong&gt;两者都是瓶颈&lt;/strong&gt;，超出预算。&lt;strong&gt;需同时优化 CPU 和 GPU&lt;/strong&gt;，使两者都低于 33.3ms。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NothingToSay0031/Images/main/202505041035164.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Is unique_ptr Really Zero-Cost?</title>
      <link>https://nothingtosay0031.github.io/post/unique/</link>
      <pubDate>Sun, 27 Apr 2025 12:29:00 +0000</pubDate>
      <guid>https://nothingtosay0031.github.io/post/unique/</guid>
      <description>&lt;h1 id=&#34;the-hidden-cost-of-stdunique_ptr-why-its-not-always-zero-cost&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#the-hidden-cost-of-stdunique_ptr-why-its-not-always-zero-cost&#34;&gt;&lt;/a&gt;&#xD;&#xA;The Hidden Cost of &lt;code&gt;std::unique_ptr&lt;/code&gt;: Why It&amp;rsquo;s Not Always &amp;ldquo;Zero-Cost&amp;rdquo;&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://youtu.be/rHIkrotSwcc?si=ZZCm9hVf2a0UmMie&#34;&gt;CppCon 2019: Chandler Carruth “There Are No Zero-cost Abstractions”&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;One of the most beloved tools in the modern C++ developer&amp;rsquo;s toolbox is &lt;code&gt;std::unique_ptr&lt;/code&gt;. It dramatically simplifies resource management, especially memory, using the RAII (Resource Acquisition Is Initialization) paradigm, effectively preventing memory leaks. Many C++ developers operate under the assumption that &lt;code&gt;std::unique_ptr&lt;/code&gt; is a &amp;ldquo;zero-cost abstraction&amp;rdquo;—meaning its use incurs no additional runtime performance overhead compared to manually managing raw pointers.&lt;/p&gt;</description>
    </item>
    <item>
      <title>ReSTIR: Path Reuse in Real-time</title>
      <link>https://nothingtosay0031.github.io/post/restir/</link>
      <pubDate>Mon, 21 Apr 2025 17:23:03 +0000</pubDate>
      <guid>https://nothingtosay0031.github.io/post/restir/</guid>
      <description>&lt;h1 id=&#34;restir&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#restir&#34;&gt;&lt;/a&gt;&#xD;&#xA;ReSTIR&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;This is my &lt;a href=&#34;https://github.com/NothingToSay0031/ReSTIR&#34;&gt;ReSTIR implementation&lt;/a&gt;, developed on top of Microsoft’s DirectX 12 Raytracing Samples.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://intro-to-restir.cwyman.org/&#34;&gt;A Gentle Introduction to ReSTIR: Path Reuse in Real-time&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h1 id=&#34;resampled-importance-sampling-ris&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#resampled-importance-sampling-ris&#34;&gt;&lt;/a&gt;&#xD;&#xA;Resampled Importance Sampling (RIS)&#xD;&#xA;&lt;/h1&gt;&lt;h2 id=&#34;proof-mathbbew_x-is-to-estimate-frac1hatpx&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#proof-mathbbew_x-is-to-estimate-frac1hatpx&#34;&gt;&lt;/a&gt;&#xD;&#xA;Proof: $\mathbb{E}[W_X]$ is to estimate $\frac{1}{\hat{p}(X)}$&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;We begin by computing the expectation of $W_X$ over the samples $X_1, \dots, X_M$, conditioning on $X$:&lt;/p&gt;&#xA;$$&#xA;\mathbb{E}_{X_1, \dots, X_M} \left[ W_X \right] &#xA;= \mathbb{E} \left[ \frac{1}{\hat{p}(X)} \cdot \frac{1}{M} \sum_{i=1}^M \frac{\hat{p}(X_i)}{p(X_i)} \right]&#xA;$$&lt;p&gt;Using linearity of expectation:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Compression-Oriented Programming</title>
      <link>https://nothingtosay0031.github.io/post/compression/</link>
      <pubDate>Sat, 04 Jan 2025 22:47:09 +0800</pubDate>
      <guid>https://nothingtosay0031.github.io/post/compression/</guid>
      <description>&lt;h1 id=&#34;compression-oriented-programming-a-practical-approach-to-abstraction&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#compression-oriented-programming-a-practical-approach-to-abstraction&#34;&gt;&lt;/a&gt;&#xD;&#xA;Compression-Oriented Programming: A Practical Approach to Abstraction&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;Casey Muratori&amp;rsquo;s blog post, &lt;a href=&#34;https://caseymuratori.com/blog_0015&#34;&gt;Semantic Compression&lt;/a&gt;, presents a compelling alternative to traditional object-oriented programming (OOP) practices. By optimizing the UI code for The Witness, the author demonstrates how step-by-step code compression can lead to improved readability, maintainability, and scalability. This article distills the core ideas and methodology outlined in the post.&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-concept-of-code-compression&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#the-concept-of-code-compression&#34;&gt;&lt;/a&gt;&#xD;&#xA;The Concept of Code Compression&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Code compression programming&lt;/strong&gt; refers to simplifying code to its minimal expression by extracting repetitive patterns, reducing redundancy, and increasing the level of abstraction.&lt;/li&gt;&#xA;&lt;li&gt;This approach &lt;strong&gt;starts with detailed optimization&lt;/strong&gt; and avoids relying on pre-planned architecture. Instead, &lt;strong&gt;the final system architecture emerges naturally&lt;/strong&gt; through iterative compression and optimization.&lt;/li&gt;&#xA;&lt;li&gt;Unlike the traditional top-down &amp;ldquo;design architecture first&amp;rdquo; approach in OOP, &lt;strong&gt;code compression minimizes the risk of overlooking details or creating suboptimal solutions&lt;/strong&gt; during architectural design.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;optimization-starting-from-details&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#optimization-starting-from-details&#34;&gt;&lt;/a&gt;&#xD;&#xA;Optimization Starting from Details&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;The author &lt;strong&gt;extracts patterns from repetitive code&lt;/strong&gt;, such as button calculation logic and row management in UI layouts.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Local variables are abstracted into shared structures&lt;/strong&gt; (e.g., &lt;code&gt;Panel_Layout&lt;/code&gt;) to enable data sharing and simplify logic.&lt;/li&gt;&#xA;&lt;li&gt;Each optimization step &lt;strong&gt;is intuitive and does not require complex tools&lt;/strong&gt; or workflows (e.g., UML diagrams or index cards).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;step-by-step-code-compression&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#step-by-step-code-compression&#34;&gt;&lt;/a&gt;&#xD;&#xA;Step-by-Step Code Compression&#xD;&#xA;&lt;/h3&gt;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Step 1: Establish a Shared Stack Framework&lt;/strong&gt;&lt;br&gt;&#xA;Extract variables related to panel layout (e.g., &lt;code&gt;row_height&lt;/code&gt; and &lt;code&gt;at_y&lt;/code&gt;) into the &lt;code&gt;Panel_Layout&lt;/code&gt; structure, &lt;strong&gt;acting as a shared state manager&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Balancing Light Sampling with MIS and NEE in Path Tracing</title>
      <link>https://nothingtosay0031.github.io/post/mis_nee/</link>
      <pubDate>Fri, 03 Jan 2025 20:25:47 +0800</pubDate>
      <guid>https://nothingtosay0031.github.io/post/mis_nee/</guid>
      <description>&lt;h1 id=&#34;monte-carlo-integration-correctness-convergence-and-application-in-rendering-equation&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#monte-carlo-integration-correctness-convergence-and-application-in-rendering-equation&#34;&gt;&lt;/a&gt;&#xD;&#xA;Monte Carlo Integration: Correctness, Convergence, and Application in Rendering Equation&#xD;&#xA;&lt;/h1&gt;&lt;h2 id=&#34;correctness-of-monte-carlo-integration&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#correctness-of-monte-carlo-integration&#34;&gt;&lt;/a&gt;&#xD;&#xA;Correctness of Monte Carlo Integration&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;Given a probability density function $p(x)$ over the interval $[a, b]$, we sample a dataset $\{X_1, X_2, \dots, X_N\}$.&lt;/p&gt;&#xA;&lt;p&gt;Define $F_N$:&lt;/p&gt;&#xA;$$F_N = \frac{1}{N} \sum_{i=1}^N \frac{f(X_i)}{p(X_i)}$$&lt;p&gt;&lt;strong&gt;Expected value of $F_N$:&lt;/strong&gt;&lt;/p&gt;&#xA;$$\begin{aligned}  &#xA;E[F_N] &amp;= E\left[\frac{1}{N} \sum_{i=1}^N \frac{f(X_i)}{p(X_i)}\right] \\  &#xA;&amp;= \frac{1}{N} \sum_{i=1}^N E\left[\frac{f(X_i)}{p(X_i)}\right] \\  &#xA;&amp;= \frac{1}{N} \sum_{i=1}^N \int_a^b \frac{f(x)}{p(x)} p(x) dx \\  &#xA;&amp;= \int_a^b f(x) dx.  &#xA;\end{aligned}$$&lt;p&gt;Thus, &lt;strong&gt;Monte Carlo integration converges to the true integral&lt;/strong&gt; as $N \to \infty$:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Exploring False Sharing</title>
      <link>https://nothingtosay0031.github.io/post/falsesharing/</link>
      <pubDate>Fri, 03 Jan 2025 11:16:31 +0800</pubDate>
      <guid>https://nothingtosay0031.github.io/post/falsesharing/</guid>
      <description>&lt;h1 id=&#34;understanding-false-sharing-a-subtle-performance-killer-in-multithreaded-programs&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#understanding-false-sharing-a-subtle-performance-killer-in-multithreaded-programs&#34;&gt;&lt;/a&gt;&#xD;&#xA;Understanding False Sharing: A Subtle Performance Killer in Multithreaded Programs&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;Today, I stumbled upon an intriguing post on Twitter:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;em&gt;&amp;ldquo;If you can tell what&amp;rsquo;s wrong here, you&amp;rsquo;re better than 99.99% of CS grads.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;Here’s the code snippet from the post:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Point&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Point&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;point&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Thread 1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;point&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Thread 2&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;point&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;At first glance, nothing seems amiss—it looks like a straightforward implementation where two threads increment &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; independently.&#xA;But as the Twitter post boldly claimed, just figuring out the issue puts you ahead of 99.99% of CS graduates. Naturally, I couldn&amp;rsquo;t resist diving deeper to see what all the fuss was about!&lt;/p&gt;</description>
    </item>
    <item>
      <title>Sampling on the Unit Hemisphere and Disk</title>
      <link>https://nothingtosay0031.github.io/post/sampling/</link>
      <pubDate>Sat, 28 Dec 2024 16:55:53 +0800</pubDate>
      <guid>https://nothingtosay0031.github.io/post/sampling/</guid>
      <description>&lt;h1 id=&#34;deriving-pdf-for-hemisphere-sampling&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#deriving-pdf-for-hemisphere-sampling&#34;&gt;&lt;/a&gt;&#xD;&#xA;Deriving PDF for Hemisphere Sampling&#xD;&#xA;&lt;/h1&gt;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Target distribution&lt;/strong&gt; in $\omega$, which is $(x, y, z)$ with $\sqrt{x^2 + y^2 + z^2} = 1$.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;The transformation $T$&lt;/strong&gt; from $(r, \theta, \phi)$ to $(x, y, z)$:&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;$$x = r \sin \theta \cos \phi$$$$y = r \sin \theta \sin \phi$$$$z = r \cos \theta$$&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;The Jacobian&lt;/strong&gt; of the transformation $T$ gives $|J_T| = r^2 \sin \theta$.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;$r = 1$, so we have:&lt;/p&gt;</description>
    </item>
    <item>
      <title>GPU-Driven Rendering Pipelines and Clustered Tile-Based Deferred Shading</title>
      <link>https://nothingtosay0031.github.io/post/gpudriven/</link>
      <pubDate>Wed, 25 Dec 2024 18:11:48 +0000</pubDate>
      <guid>https://nothingtosay0031.github.io/post/gpudriven/</guid>
      <description>&lt;h1 id=&#34;mesh-shader&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#mesh-shader&#34;&gt;&lt;/a&gt;&#xD;&#xA;Mesh Shader&#xD;&#xA;&lt;/h1&gt;&lt;h2 id=&#34;为什么选择-mesh-shader&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%80%89%e6%8b%a9-mesh-shader&#34;&gt;&lt;/a&gt;&#xD;&#xA;为什么选择 Mesh Shader&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;在深入代码之前，我们先来聊聊“为什么”。传统的顶点着色 (Vertex Shading) 管线虽然服务了我们很多年，但它存在一些固有的效率瓶颈。&lt;a href=&#34;https://developer.nvidia.com/blog/introduction-turing-mesh-shaders/&#34;&gt;Mesh Shader&lt;/a&gt; 的出现正是为了解决这些痛点。&lt;/p&gt;&#xA;&lt;h3 id=&#34;传统管线的瓶颈&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e4%bc%a0%e7%bb%9f%e7%ae%a1%e7%ba%bf%e7%9a%84%e7%93%b6%e9%a2%88&#34;&gt;&lt;/a&gt;&#xD;&#xA;传统管线的瓶颈&#xD;&#xA;&lt;/h3&gt;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;重复的顶点批处理&lt;/strong&gt;：即使场景中模型的拓扑结构（顶点连接关系）固定不变，硬件的“图元分发器” (Primitive Distributor) 每次绘制时仍然需要扫描整个索引缓冲区来创建顶点批次。这是一种不必要的重复劳动。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;无效的数据拉取&lt;/strong&gt;：传统管线会拉取并处理大量最终不可见的顶点数据。这些顶点可能因为背面剔除 (Back-face Culling)、视锥剔除 (Frustum Culling) 或被遮挡而被丢弃，但 GPU 带宽和计算资源已经被浪费了。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;mesh-shader-的解决方案&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#mesh-shader-%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88&#34;&gt;&lt;/a&gt;&#xD;&#xA;Mesh Shader 的解决方案&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;Mesh Shader 引入了两个新的可编程阶段：Task Shader 和 Mesh Shader，它们以工作组 (workgroup) 的形式运作，将更多的控制权交给了开发者。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Task Shader&lt;/strong&gt; (可选): 任务着色器，负责剔除和分发工作。它可以看作是 Mesh Shader 工作组的“调度员”，能够高效地剔除掉整个物体或大块的网格，决定是否需要启动后续的 Mesh Shader。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Mesh Shader&lt;/strong&gt;: 网格着色器，负责生成图元。它取代了传统的顶点、几何和曲面细分着色器，直接在一个工作组内生成一小批顶点和图元。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这种新模式带来了三大核心优势：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;极致的性能与可扩展性&lt;/strong&gt;：通过减少固定功能硬件的干预，渲染负载更多地转移到通用的着色器核心上。这意味着我们可以充分利用现代 GPU 强大的并行计算能力。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;显著的带宽节省&lt;/strong&gt;：顶点重用 (vertex re-use) 可以在预处理阶段完成，并将结果（称为 &lt;strong&gt;Meshlet&lt;/strong&gt;）缓存起来复用。Meshlet 是一种高度优化的微型网格，它包含一小撮唯一的顶点和引用这些顶点的图元。这意味着 GPU 不再需要每次都扫描庞大的主索引缓冲区。使用 Meshlet 后，索引数据的大小通常能减少到原来的 75% 左右。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;前所未有的灵活性&lt;/strong&gt;：开发者可以自由定义网格拓扑，甚至在 GPU 上程序化地生成几何体，而无需受限于旧管线的固定模式。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;更详细的分析可见 &lt;a href=&#34;https://nothingtosay0031.github.io/post/gpu/#turing-%E6%9E%B6%E6%9E%84-mesh-shader&#34;&gt;Turing 架构: Mesh Shader&lt;/a&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Real-Time High Quality Rendering</title>
      <link>https://nothingtosay0031.github.io/post/games202/</link>
      <pubDate>Fri, 22 Nov 2024 12:33:58 +0000</pubDate>
      <guid>https://nothingtosay0031.github.io/post/games202/</guid>
      <description>&lt;h1 id=&#34;real-time-shadows&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#real-time-shadows&#34;&gt;&lt;/a&gt;&#xD;&#xA;Real-Time Shadows&#xD;&#xA;&lt;/h1&gt;&lt;h2 id=&#34;shadow-mapping&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#shadow-mapping&#34;&gt;&lt;/a&gt;&#xD;&#xA;Shadow Mapping&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;Shadow mapping is an &lt;strong&gt;image-space algorithm&lt;/strong&gt; to determine if a point is in shadow.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Pros&lt;/strong&gt;: Does not require scene geometry&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Cons&lt;/strong&gt;: Prone to &lt;strong&gt;self-occlusion&lt;/strong&gt; and &lt;strong&gt;aliasing&lt;/strong&gt; issues&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;algorithm-steps&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#algorithm-steps&#34;&gt;&lt;/a&gt;&#xD;&#xA;Algorithm Steps&#xD;&#xA;&lt;/h3&gt;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;Generate Depth Map&lt;/strong&gt;: Render the scene from the light’s perspective to create a &lt;strong&gt;depth map (shadow map)&lt;/strong&gt;.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Shadow Check&lt;/strong&gt;: Compare the shading point’s distance to the light with the &lt;strong&gt;shadow map&lt;/strong&gt; depth to decide if the point is in shadow.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;self-occlusion-shadow-acne&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#self-occlusion-shadow-acne&#34;&gt;&lt;/a&gt;&#xD;&#xA;Self-Occlusion (Shadow Acne)&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;Self-occlusion, also known as &lt;a href=&#34;https://digitalrune.github.io/DigitalRune-Documentation/html/3f4d959e-9c98-4a97-8d85-7a73c26145d7.htm&#34;&gt;shadow acne&lt;/a&gt;, happens when &lt;strong&gt;points that should be lit&lt;/strong&gt; are incorrectly shadowed. This often results from limited &lt;strong&gt;depth map resolution&lt;/strong&gt;, which cannot capture detailed depth variations within small areas.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Shadertoy Projects</title>
      <link>https://nothingtosay0031.github.io/post/shadertoy/</link>
      <pubDate>Fri, 20 Sep 2024 21:01:37 +0000</pubDate>
      <guid>https://nothingtosay0031.github.io/post/shadertoy/</guid>
      <description>&lt;p&gt;Recently, I took part in Arm’s Shadertoy hackathon, where my team won the only Professional Award out of 11 teams. Here, I’ll document the projects I created and experimented with on Shadertoy.&lt;/p&gt;&#xA;&lt;h1 id=&#34;drawing-chinese-characters-with-bézier-curves&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#drawing-chinese-characters-with-b%c3%a9zier-curves&#34;&gt;&lt;/a&gt;&#xD;&#xA;Drawing Chinese Characters with Bézier Curves&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NothingToSay0031/Images/main/202409202131797.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;By utilizing the signed distance field (SDF) of Bézier curves—which include start and end points, start and end thickness, and curvature—we can create smooth, intricate lines. This technique is ideal for drawing the complex strokes of Chinese characters.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Rust Essentials</title>
      <link>https://nothingtosay0031.github.io/post/rust/</link>
      <pubDate>Sun, 15 Sep 2024 20:35:50 +0000</pubDate>
      <guid>https://nothingtosay0031.github.io/post/rust/</guid>
      <description>&lt;h1 id=&#34;memory-management-in-rust---stack-vs-heap&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#memory-management-in-rust---stack-vs-heap&#34;&gt;&lt;/a&gt;&#xD;&#xA;Memory Management in Rust - Stack vs. Heap&#xD;&#xA;&lt;/h1&gt;&lt;h2 id=&#34;introduction&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#introduction&#34;&gt;&lt;/a&gt;&#xD;&#xA;Introduction&#xD;&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;Rust emphasizes &lt;strong&gt;memory safety&lt;/strong&gt; without garbage collection.&lt;/li&gt;&#xA;&lt;li&gt;This session revisits fundamental concepts like memory, functions, and how data is stored.&lt;/li&gt;&#xA;&lt;li&gt;Many experienced engineers must revisit these basics to solve real-world issues like &lt;strong&gt;concurrent safety&lt;/strong&gt;.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;key-concepts&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#key-concepts&#34;&gt;&lt;/a&gt;&#xD;&#xA;Key Concepts&#xD;&#xA;&lt;/h2&gt;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;Memory in Programming&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Every program interacts with memory, whether &lt;strong&gt;stack&lt;/strong&gt;, &lt;strong&gt;heap&lt;/strong&gt;, or &lt;strong&gt;readonly data segments&lt;/strong&gt; (e.g., &lt;code&gt;.RODATA&lt;/code&gt; for string literals).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Interesting C&#43;&#43; Code Snippets</title>
      <link>https://nothingtosay0031.github.io/post/arm/</link>
      <pubDate>Tue, 18 Jun 2024 22:27:03 +0000</pubDate>
      <guid>https://nothingtosay0031.github.io/post/arm/</guid>
      <description>&lt;p&gt;A couple of fun and intriguing C++ code snippets I explored while developing a Vulkan trace tool at ARM.&lt;/p&gt;&#xA;&lt;h1 id=&#34;compile-time-type-to-type-map&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#compile-time-type-to-type-map&#34;&gt;&lt;/a&gt;&#xD;&#xA;Compile-Time Type-to-Type Map&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;While working on translating the Vulkan API into our own data structure, I developed a compile-time type-to-type map. This map allows us to retrieve the corresponding CreateInfo type for a given Vulkan object type. Here’s the implementation:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;tuple&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;TypeTag&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Pair&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FirstType&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SecondType&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Pair&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Element&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;enable_if_t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                            &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_same_v&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Pair&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;FirstType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TypeTag&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TypeTag&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Pair&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SecondType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Elems&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;TypeMap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Element&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Elems&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Element&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Elems&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;FindHelper&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;decltype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TypeMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TypeTag&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}))&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Find&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FindHelper&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Key types&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;TypeA&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;TypeB&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Value types&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;InfoA1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;InfoA2&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;InfoB&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Create a TypeMap with types&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TypeToInfoMap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TypeMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Pair&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TypeA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;InfoA1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;InfoA2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Pair&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TypeB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;InfoB&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Helper to get the type at a specific index in a tuple&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TupleElementType&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tuple_element_t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ValueA&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TypeToInfoMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Find&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TypeA&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;static_assert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_same_v&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ValueA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;InfoA1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;InfoA2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;s&#34;&gt;&amp;#34;Type mismatch!&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ValueB&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TypeToInfoMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Find&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TypeB&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;static_assert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_same_v&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ValueB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;InfoB&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Type mismatch!&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FirstTypeValueA&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tuple_element_t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ValueA&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;static_assert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_same_v&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;FirstTypeValueA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;InfoA1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Type mismatch!&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SecondTypeValueA&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TupleElementType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ValueA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;static_assert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_same_v&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SecondTypeValueA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;InfoA2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Type mismatch!&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;constexpr&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tuple_size_v&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ValueA&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;static_assert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Tuple size mismatch!&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;easily-ignoring-implicit-conversions&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#easily-ignoring-implicit-conversions&#34;&gt;&lt;/a&gt;&#xD;&#xA;Easily Ignoring Implicit Conversions&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;Here&amp;rsquo;s an odd case where passing an lvalue to a function expecting an rvalue doesn&amp;rsquo;t always cause a compiler complaint, depending on how it&amp;rsquo;s used. This snippet illustrates how you might unintentionally bypass this check:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Rendering and Game Engine Projects</title>
      <link>https://nothingtosay0031.github.io/post/games/</link>
      <pubDate>Sat, 24 Feb 2024 21:29:00 +0000</pubDate>
      <guid>https://nothingtosay0031.github.io/post/games/</guid>
      <description>&lt;h1 id=&#34;mini-game-engine&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#mini-game-engine&#34;&gt;&lt;/a&gt;&#xD;&#xA;Mini Game Engine&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/NothingToSay0031/GAMES104/&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;color-grading&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#color-grading&#34;&gt;&lt;/a&gt;&#xD;&#xA;Color Grading&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NothingToSay0031/Images/main/202403011741923.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;annimation-and-character-controller&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#annimation-and-character-controller&#34;&gt;&lt;/a&gt;&#xD;&#xA;Annimation and Character Controller&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NothingToSay0031/Images/main/202403011744806.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;reflection&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#reflection&#34;&gt;&lt;/a&gt;&#xD;&#xA;Reflection&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NothingToSay0031/Images/main/202403011745388.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;screen-space-ray-tracing&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#screen-space-ray-tracing&#34;&gt;&lt;/a&gt;&#xD;&#xA;Screen Space Ray Tracing&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;Test Reflection&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NothingToSay0031/Images/main/202403070212708.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Sample = 8&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NothingToSay0031/Images/main/202403070216481.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Depth Mipmap&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NothingToSay0031/Images/main/202403130309474.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Sample = 16, with Hi-Z Optimization&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NothingToSay0031/Images/main/202403070235487.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;shadow-map-pcf-and-pcss&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#shadow-map-pcf-and-pcss&#34;&gt;&lt;/a&gt;&#xD;&#xA;Shadow Map, PCF, and PCSS&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NothingToSay0031/Images/main/202402251757206.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Geometric Shape Modeling</title>
      <link>https://nothingtosay0031.github.io/post/csci-599/</link>
      <pubDate>Thu, 22 Feb 2024 22:56:51 +0000</pubDate>
      <guid>https://nothingtosay0031.github.io/post/csci-599/</guid>
      <description>&lt;h1 id=&#34;reconstruction&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#reconstruction&#34;&gt;&lt;/a&gt;&#xD;&#xA;Reconstruction&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;Implement a simplified version of the method in &amp;ldquo;Poisson Surface Reconstruction&amp;rdquo; by Kazhdan et al. 2006.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NothingToSay0031/Images/main/202402222342552.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;registration&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#registration&#34;&gt;&lt;/a&gt;&#xD;&#xA;Registration&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;Implement a version of the iterative closest point (ICP).&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NothingToSay0031/Images/main/202402222344314.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;smoothing&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#smoothing&#34;&gt;&lt;/a&gt;&#xD;&#xA;Smoothing&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;Smooth a data signal defined over a curved surface.&lt;/p&gt;&#xA;&lt;p&gt;This data could be a scalar field on the surface and smoothing corresponds to data denoising.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NothingToSay0031/Images/main/202402222344633.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Or the data could be the vector field of the surface&amp;rsquo;s own geometry. This corresponds to geometric smoothing.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Multimedia Systems Design</title>
      <link>https://nothingtosay0031.github.io/post/csci-576/</link>
      <pubDate>Sun, 08 Oct 2023 19:32:01 +0000</pubDate>
      <guid>https://nothingtosay0031.github.io/post/csci-576/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;I especially try to tell students, yeah, grade is something you need to worry about. But after five years when you graduate and you&amp;rsquo;re working in the industry, the grade is not. You&amp;rsquo;re not going to remember the grade. You&amp;rsquo;re going to remember what you learned and how you&amp;rsquo;re applying it.&lt;br&gt;&#xA;——Parag Havaldar&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;anti-aliasing&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#anti-aliasing&#34;&gt;&lt;/a&gt;&#xD;&#xA;Anti-aliasing&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;This assignment covers resampling and filtering for RGB images. The job is to display them using C++ without external libraries (except for WxWidgets).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Windows Development Environment</title>
      <link>https://nothingtosay0031.github.io/post/wsl/</link>
      <pubDate>Sun, 26 Mar 2023 15:04:10 +0000</pubDate>
      <guid>https://nothingtosay0031.github.io/post/wsl/</guid>
      <description>&lt;h1 id=&#34;windows&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#windows&#34;&gt;&lt;/a&gt;&#xD;&#xA;Windows&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;VS Code&lt;/p&gt;&#xA;&lt;p&gt;PowerToys&lt;/p&gt;&#xA;&lt;p&gt;Snipaste&lt;/p&gt;&#xA;&lt;p&gt;PicGo&lt;/p&gt;&#xA;&lt;p&gt;WSL2&lt;/p&gt;&#xA;&lt;p&gt;TeX Live&lt;/p&gt;&#xA;&lt;p&gt;Marktext&lt;/p&gt;&#xA;&lt;h1 id=&#34;windows-subsystem-for-linux&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#windows-subsystem-for-linux&#34;&gt;&lt;/a&gt;&#xD;&#xA;Windows Subsystem for Linux&#xD;&#xA;&lt;/h1&gt;&lt;h2 id=&#34;shell&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#shell&#34;&gt;&lt;/a&gt;&#xD;&#xA;Shell&#xD;&#xA;&lt;/h2&gt;&lt;h3 id=&#34;zsh&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#zsh&#34;&gt;&lt;/a&gt;&#xD;&#xA;zsh&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;将zsh作为默认的 Shell 环境 &lt;code&gt;chsh -s $(which zsh)&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;插件&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://ohmyz.sh/&#34;&gt;oh-my-zsh&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/romkatv/powerlevel10k&#34;&gt;powerlevel10k&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/zsh-users/zsh-syntax-highlighting&#34;&gt;zsh-syntax-highlighting&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/zsh-users/zsh-autosuggestions&#34;&gt;zsh-autosuggestions&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/zsh-users/zsh-history-substring-search&#34;&gt;zsh-history-substring-search&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;z&lt;/li&gt;&#xA;&lt;li&gt;sudo&lt;/li&gt;&#xA;&lt;li&gt;extract&lt;/li&gt;&#xA;&lt;li&gt;docker&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;配置与-github-连接的-ssh-密钥&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae%e4%b8%8e-github-%e8%bf%9e%e6%8e%a5%e7%9a%84-ssh-%e5%af%86%e9%92%a5&#34;&gt;&lt;/a&gt;&#xD;&#xA;配置与 GitHub 连接的 SSH 密钥&#xD;&#xA;&lt;/h3&gt;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在 WSL 下生成 SSH 公钥 — 私钥对（将邮箱替换为你的邮箱），此时生成的 SSH 密钥默认位于 &lt;code&gt;~/.ssh&lt;/code&gt; 路径下，公钥为 &lt;code&gt;id_rsa.pub&lt;/code&gt;，私钥为 &lt;code&gt;id_rsa&lt;/code&gt;：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ssh-keygen -t rsa -b &lt;span class=&#34;m&#34;&gt;4096&lt;/span&gt; -C &lt;span class=&#34;s2&#34;&gt;&amp;#34;email@ex.com&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;打开 ssh-agent 使之在后台运行：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nb&#34;&gt;eval&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;ssh-agent -s&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;将私钥添加到 ssh-agent 之中：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Experience of TOEFL and GRE Preparation</title>
      <link>https://nothingtosay0031.github.io/post/tg/</link>
      <pubDate>Sun, 05 Mar 2023 13:17:57 +0000</pubDate>
      <guid>https://nothingtosay0031.github.io/post/tg/</guid>
      <description>&lt;p&gt;8月开始准备托福，9月末准备GRE，托福和GRE分别于12.18和1.5出分。提交的成绩R26L28S23W25，V170Q158AW3，托福拼分105。&lt;/p&gt;&#xA;&lt;p&gt;我英语基础一直都不是很好，来自某不考听力的省份，高考二卷138，四级473，六级390。分享一下基础较差的我是如何备考的，如果能给还在备考的人一些教训和启示就再好不过了。&lt;/p&gt;&#xA;&lt;p&gt;如果需要文中提到的资料，可以直接给我发邮件。&lt;/p&gt;&#xA;&lt;h1 id=&#34;托福&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e6%89%98%e7%a6%8f&#34;&gt;&lt;/a&gt;&#xD;&#xA;托福&#xD;&#xA;&lt;/h1&gt;&lt;h2 id=&#34;阅读&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e9%98%85%e8%af%bb&#34;&gt;&lt;/a&gt;&#xD;&#xA;阅读&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;阅读备考期间看了费扬的2016年阅读课和新东方时期的课程，课程内容差不多，推荐看最新的（新东方）就行，做了16年阅读课的作业，背了他给的680个核心词。在9月中旬那会做TPO60左右，大概看题的难易程度，14个题中错0-4的都有，大部分是错1-2个。&lt;/p&gt;&#xA;&lt;p&gt;费扬讲的技巧听了还是蛮受用的，一些句子插入题技巧、细节题的排除技巧都不错，但是根据我考场上的经验，ETS现在阅读出的比TPO还是要长一些，而且有些题并不能直接从逻辑上得出答案，因此还是要求有阅读长难句和分析主干的能力。&lt;/p&gt;&#xA;&lt;p&gt;后期看了一下黎老师的阅读课，在看完GRE闫晨晨和费扬的课程之后技巧上没有新东西，就是有段时间都在练听力，闲着没事看一下避免太生疏。&lt;/p&gt;&#xA;&lt;p&gt;最后考试方法就是：每一段做结构式阅读法，看到题目对应关键词就直接找对应做题就好了，做完也不太管剩下的，直接下一题。托福阅读相比GRE还是简单的，大部分题找到位置就能做对。&lt;/p&gt;&#xA;&lt;p&gt;六选二的选项是按照文章顺序排列的，按行ab cd ef这样排列，刚读完最后一段印象最深，所以我每次都是先从最后一个选项往前开始判断。把明显错误的排除，过于细节的也排除，剩下的听天命。黎老师六选二的排除技巧还不错。&lt;/p&gt;&#xA;&lt;p&gt;我之前词汇题总会错一两个，但是背了网盘里那个&amp;quot;TOEFL 阅读机经词.pdf&amp;quot;就没错过了，高频的基本都覆盖了，不放心的话可以再背&amp;quot;词汇题 1500组.pdf&amp;quot;那个文件。&lt;/p&gt;&#xA;&lt;h3 id=&#34;资料实用程度&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e8%b5%84%e6%96%99%e5%ae%9e%e7%94%a8%e7%a8%8b%e5%ba%a6&#34;&gt;&lt;/a&gt;&#xD;&#xA;资料实用程度&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;词汇题的两个文件 5/5，背了没坏处，如果有词不认识可以背，比学科词好背且有用。&lt;/p&gt;&#xA;&lt;p&gt;费扬阅读课 4/5，如果以前没有接触过阅读方法论的可以尝试，如果基础还不错按照自己的方法来就好。&lt;/p&gt;&#xA;&lt;h3 id=&#34;训练方法&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e8%ae%ad%e7%bb%83%e6%96%b9%e6%b3%95&#34;&gt;&lt;/a&gt;&#xD;&#xA;训练方法&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;先分题型练习，再限时训练。&lt;/p&gt;&#xA;&lt;h2 id=&#34;听力&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e5%90%ac%e5%8a%9b&#34;&gt;&lt;/a&gt;&#xD;&#xA;听力&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;听力只听了微臣的课程，陈琦上课一半时间都在推销xs。课程作用没有那么大，方法论也不是很难掌握，主要作用还是带着你做一些题。&lt;/p&gt;&#xA;&lt;p&gt;详细可以看我笔记&amp;quot;听力.md&amp;quot;里的一些内容，记录了网上别处看到的一些常见考点&amp;quot;分类、列举、对比&amp;quot;之类的，感觉比微臣的课还有那么一点用。&lt;/p&gt;&#xA;&lt;p&gt;听力没有什么花里胡哨的方法论，听力的重点会重复，一些难懂的概念也会跟解释，有一处没听懂也可以靠后面理解补救。&lt;/p&gt;&#xA;&lt;p&gt;记笔记这个问题因人而异，我前几次都没记笔记，最后两次记了笔记。不过笔记类似于上课在听lecture的那种笔记。合适自己就行。综合口语和写作一般都要记，因为需要准确复述。&lt;/p&gt;&#xA;&lt;h3 id=&#34;资料实用程度-1&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e8%b5%84%e6%96%99%e5%ae%9e%e7%94%a8%e7%a8%8b%e5%ba%a6-1&#34;&gt;&lt;/a&gt;&#xD;&#xA;资料实用程度&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;微臣 3/5，如果对他的方法论感兴趣可以听一听。&lt;/p&gt;&#xA;&lt;p&gt;笔记 4/5，推荐了解。&lt;/p&gt;&#xA;&lt;h3 id=&#34;训练方法-1&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e8%ae%ad%e7%bb%83%e6%96%b9%e6%b3%95-1&#34;&gt;&lt;/a&gt;&#xD;&#xA;训练方法&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;做题，精听（可以加上跟读），有不同的训练方法，参见&amp;quot;听力.md&amp;quot;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;口语&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e5%8f%a3%e8%af%ad&#34;&gt;&lt;/a&gt;&#xD;&#xA;口语&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;我只看了吴奇的课程，这个东西应该用谁的框架都行，主要还是看自己的基础。&lt;/p&gt;&#xA;&lt;p&gt;吴奇课程还不错，除了废话稍微多了那么一丢丢233。Task1有60个范例，可以熟悉一下或自己回答试试，Task 2 3 4就完全靠吴奇的方法论和模板就好了。&lt;/p&gt;&#xA;&lt;p&gt;我的模板在&amp;quot;口语.md&amp;quot;、&amp;ldquo;背诵.md&amp;quot;这两个文件里可以找到。&lt;/p&gt;&#xA;&lt;p&gt;吴奇课上说想要达到23需要练够一定数量的题，我之前在TPO1-54大概练了15套左右口语，考场上就是17 18 19 20分。&lt;/p&gt;&#xA;&lt;p&gt;在最后一次考试前把TPO55-72的口语全练了，竟然神奇的达到了23分。&lt;/p&gt;&#xA;&lt;h3 id=&#34;资料实用程度-2&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e8%b5%84%e6%96%99%e5%ae%9e%e7%94%a8%e7%a8%8b%e5%ba%a6-2&#34;&gt;&lt;/a&gt;&#xD;&#xA;资料实用程度&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;吴奇 4/5，课程有点长可以按需看，模板用一用还挺好的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;训练方法-2&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e8%ae%ad%e7%bb%83%e6%96%b9%e6%b3%95-2&#34;&gt;&lt;/a&gt;&#xD;&#xA;训练方法&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;背/熟悉Task1的回答，吴奇公众号也会更新每次考试的题目。&lt;/p&gt;&#xA;&lt;p&gt;做题，自己说完后去吴奇公众号找他的笔记和范例回答，然后修改一下说流畅。&lt;/p&gt;&#xA;&lt;p&gt;跟读TPO口语材料。&lt;/p&gt;&#xA;&lt;p&gt;个人觉得没必要花钱评分或找外教，本身就是机考，自己录下来自己听就能听得出来说的哪里不行。&lt;/p&gt;&#xA;&lt;h2 id=&#34;写作&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e5%86%99%e4%bd%9c&#34;&gt;&lt;/a&gt;&#xD;&#xA;写作&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;我最开始看了新东方徐欣的写作课程，说实话我挺后悔的233。不如黎老师的好上手。&lt;/p&gt;&#xA;&lt;p&gt;最初看了黎老师的模板，心想这啥啊这是，然后就去看新东方的课了，最后还是把黎老师的课看完了xs。&lt;/p&gt;&#xA;&lt;p&gt;黎老师的课好就好在她给基础不好的同学一个非常简单的上手思路，从破题到逻辑到语言。不像新东方的那个，课看完了还不知道怎么写。&lt;/p&gt;&#xA;&lt;p&gt;而基础很好的同学则可以超脱这个框架，借鉴破题的思路和句间逻辑，自己设计整体行文逻辑。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Machine Learning and Deep Learning</title>
      <link>https://nothingtosay0031.github.io/post/dl/</link>
      <pubDate>Wed, 01 Feb 2023 12:14:45 +0000</pubDate>
      <guid>https://nothingtosay0031.github.io/post/dl/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/NothingToSay0031/CS_Notes/tree/main/Machine%20Learning%20and%20Deep%20Learning&#34;&gt;Source Documents&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>友情链接</title>
      <link>https://nothingtosay0031.github.io/friend/</link>
      <pubDate>Thu, 09 Jun 2022 20:12:52 +0800</pubDate>
      <guid>https://nothingtosay0031.github.io/friend/</guid>
      <description>&lt;h2 id=&#34;小伙伴们&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e5%b0%8f%e4%bc%99%e4%bc%b4%e4%bb%ac&#34;&gt;&lt;/a&gt;&#xD;&#xA;小伙伴们&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;div class=&#34;friend-wrap&#34; data-aos=&#34;zoom-in&#34;&gt;&#xD;&#xA;  &#xD;&#xA;    &lt;div class=&#34;friend-item-wrap&#34;&gt;&#xD;&#xA;      &lt;a href=&#34;https://d-sketon.github.io/&#34; rel=&#34;noopener external nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;/a&gt;&#xD;&#xA;      &lt;div class=&#34;friend-icon-wrap&#34;&gt;&#xD;&#xA;        &lt;div class=&#34;friend-icon&#34;&gt;&#xD;&#xA;          &lt;img&#xD;&#xA;            data-src=&#34;https://d-sketon.github.io/avatar/avatar.webp&#34;&#xD;&#xA;            data-sizes=&#34;auto&#34;&#xD;&#xA;            alt=&#34;D-Sketon&#34;&#xD;&#xA;            class=&#34;lazyload&#34;&#xD;&#xA;          /&gt;&#xD;&#xA;        &lt;/div&gt;&#xD;&#xA;      &lt;/div&gt;&#xD;&#xA;      &lt;div class=&#34;friend-info-wrap&#34;&gt;&#xD;&#xA;        &lt;div class=&#34;friend-name&#34;&gt;&#xD;&#xA;          D-Sketon&#xD;&#xA;        &lt;/div&gt;&#xD;&#xA;        &lt;div class=&#34;friend-desc&#34;&gt;&#xD;&#xA;          Hugo 主题开发者&#xD;&#xA;        &lt;/div&gt;&#xD;&#xA;      &lt;/div&gt;&#xD;&#xA;    &lt;/div&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>关于</title>
      <link>https://nothingtosay0031.github.io/about/</link>
      <pubDate>Wed, 01 Dec 2021 20:00:52 +0800</pubDate>
      <guid>https://nothingtosay0031.github.io/about/</guid>
      <description>&lt;h1 id=&#34;to-be-continued&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#to-be-continued&#34;&gt;&lt;/a&gt;&#xD;&#xA;To be continued&amp;hellip;&#xD;&#xA;&lt;/h1&gt;&lt;h2 id=&#34;dont-compare&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#dont-compare&#34;&gt;&lt;/a&gt;&#xD;&#xA;Don&amp;rsquo;t Compare&#xD;&#xA;&lt;/h2&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;When I was getting married, I was a PhD student at the time. My mom pulled me aside on my wedding day and said, &amp;ldquo;John, I want to give you some advice.&amp;rdquo;&#xA;I was like, oh, she’s going to tell me to listen to my wife or whatever. But she didn’t.&#xA;She said only two words that have stuck with me for a long time:&#xA;&lt;strong&gt;&amp;ldquo;Don’t compare.&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>CS Learning Road</title>
      <link>https://nothingtosay0031.github.io/post/cs/</link>
      <pubDate>Wed, 13 Oct 2021 13:09:03 +0000</pubDate>
      <guid>https://nothingtosay0031.github.io/post/cs/</guid>
      <description>&lt;p&gt;记录的&lt;a href=&#34;https://github.com/NothingToSay0031/Notes&#34;&gt;笔记&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;机器学习与深度学习&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e6%9c%ba%e5%99%a8%e5%ad%a6%e4%b9%a0%e4%b8%8e%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0&#34;&gt;&lt;/a&gt;&#xD;&#xA;机器学习与深度学习&#xD;&#xA;&lt;/h3&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;2020.12&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;李宏毅讲的好, 算是正儿八经刷的第一门公开课.&lt;/p&gt;&#xA;&lt;h3 id=&#34;cs61a-structure-and-interpretation-of-computer-programs&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#cs61a-structure-and-interpretation-of-computer-programs&#34;&gt;&lt;/a&gt;&#xD;&#xA;CS61A Structure and Interpretation of Computer Programs&#xD;&#xA;&lt;/h3&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;2021.12&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;CS61A主要介绍不同的抽象方法 (functional programming, data abstraction and object-oriented programming) , 讲授如何利用这些方法解决问题并控制程序的复杂度.&lt;/p&gt;&#xA;&lt;p&gt;课程从基本的语句对环境的影响开始, 逐渐深入到高阶函数, 递归, 数据抽象, 对象等抽象思想, 整体非常连贯. 最后讲了一部分Scheme, Interpreter, Regular Expression, BNF, SQL相关的知识, 内容广泛但不深入.&lt;/p&gt;&#xA;&lt;p&gt;作业难度不是很大, 指导详细 (尤其是Project) , 是优点也是缺点. 题目不会时, 很有可能是题意没有理解清楚.&lt;/p&gt;&#xA;&lt;h3 id=&#34;cs61b-data-structures&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#cs61b-data-structures&#34;&gt;&lt;/a&gt;&#xD;&#xA;CS61B Data Structures&#xD;&#xA;&lt;/h3&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;2022.01.12&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;Project Byow和Gitlet不提供基础框架, 更有挑战性.&lt;/p&gt;&#xA;&lt;p&gt;Spring 2018 作业代码量很多. 对于没有多少编程经验的人很有益处.&lt;/p&gt;&#xA;&lt;h3 id=&#34;15-213-introduction-to-computer-systems&#34;&gt;&#xD;&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#15-213-introduction-to-computer-systems&#34;&gt;&lt;/a&gt;&#xD;&#xA;15-213 Introduction to Computer Systems&#xD;&#xA;&lt;/h3&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;2022.02.28&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;配套教材Computer Systems: A Programmer&amp;rsquo;s Perspective的&lt;a href=&#34;http://csapp.cs.cmu.edu/3e/labs.html&#34;&gt;Lab&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
